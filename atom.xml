<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>零の杂货铺</title>
  <subtitle>Free and Share</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://phantom0301.github.io/"/>
  <updated>2016-07-30T01:30:40.965Z</updated>
  <id>http://phantom0301.github.io/</id>
  
  <author>
    <name>Phantom</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>再探Docker-另类Docker安全</title>
    <link href="http://phantom0301.github.io/2016/07/21/%E5%86%8D%E6%8E%A2Docker-%E5%8F%A6%E7%B1%BBDocker%E5%AE%89%E5%85%A8/"/>
    <id>http://phantom0301.github.io/2016/07/21/再探Docker-另类Docker安全/</id>
    <published>2016-07-21T05:53:06.000Z</published>
    <updated>2016-07-30T01:30:40.965Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x01-别人说&quot;&gt;&lt;a href=&quot;#0x01-别人说&quot; class=&quot;headerlink&quot; title=&quot;0x01 别人说&quot;&gt;&lt;/a&gt;0x01 别人说&lt;/h2&gt;&lt;p&gt;Docker安全的问题有许多的相关文章分析，援引“Docker安全那些事”中提到的，Docker安全具体应该说分为Docker自身安全和Docker镜像安全两种，Docker之前有记录的漏洞分别是1.3和1.6，而现在的版本已经到1.12，到现在为止都没有再爆出漏洞的信息，而且Docker自身的安全往往是和Linux的底层功能息息相关的，这也是我不懂的领域。&lt;/p&gt;
&lt;p&gt;还有一个特别的点就是Docker的远程调用API接口存在未授权访问，但其实导致这个问题的是Docker的服务端程序Docker daemon被绑定到了公网的端口上，并且没有增加认证。默认情况下Docker daemon使用的是sock监听，本身只有root和docker用户组才有权限，所以不进行验证。换句话说，如果你不打算通过网络执行Docker命令或者增加证书验证的环节,这种漏洞就可以避免。&lt;/p&gt;
&lt;p&gt;我们可以在本地复现一下这个漏洞，首先我们关闭Docker daemon的本地sock，开启远程访问，并绑定端口。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;service stop docker
docker daemon -H unix:///var/run/docker.sock -H 0.0.0.0:9090
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后我们访问&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl http://127.0.0.1:9090/containers/json
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们来获取一些敏感的信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl http://127.0.0.1:9090/containers/(id)/logs?stdout=1

curl http://127.0.0.1:9090/containers/(id)/json
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外通过Post包我们还可以新建、开启和关闭容器。&lt;/p&gt;
&lt;p&gt;相关的参考文件：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/48689&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://yq.aliyun.com/articles/48689&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed4fece7631040973b5b1597634b928d483493cf5f93130601127ba5e065635559809e203c4bee084beb812173401420b786cb8d4cdebf8f3c6ad567627f4adb104b8459b8ca3632b122872ae9b868edad834284afa2c4ae5244bb56120c82e7f8511715ba7881672692a6&amp;amp;p=8b2a9715d9c042a40caa8c0c4e47c6&amp;amp;newp=817ec54ad5c04ab94ebcc7710f0090231615d70e37d1da01298ffe0cc4241a1a1a3aecbf26201403d6cf7f6604a94c5feff53c78340634f1f689df08d2ecce7e399e76&amp;amp;user=baidu&amp;amp;fm=sc&amp;amp;query=Docker%B0%B2%C8%AB%C4%C7%D0%A9%CA%C2&amp;amp;qid=e65331f700005115&amp;amp;p1=5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker安全那些事&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.91ri.org/15837.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.91ri.org/15837.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x02-另类视角一：孤岛限制&quot;&gt;&lt;a href=&quot;#0x02-另类视角一：孤岛限制&quot; class=&quot;headerlink&quot; title=&quot;0x02 另类视角一：孤岛限制&quot;&gt;&lt;/a&gt;0x02 另类视角一：孤岛限制&lt;/h2&gt;&lt;p&gt;我们这里谈到的安全，将从另一个视角来解读，假设我们默认部署好的容器应用存在某种漏洞而被利用，最坏的情况是攻击者完全拿下了容器并且取得了root权限。可以预想到的是，在默认的配置下，拥有root权限的Docker就如同真正的跳板机一样，容器如同使用宿主机作为路由器的主机，不仅能够扫描到宿主机的端口情况，还可以扫描到宿主机所在网段的拓扑。&lt;/p&gt;
&lt;p&gt;最初是想在宿主机上做端口转发策略的限制，进而限制容器访问到更大范围的局域网。本以为在宿主机上的端口转发并不会影响宿主机的网络访问功能。使用如下指令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sysctl net.ipv4.ip_forward
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在宿主机上运行上面的指令可以查看当前的转发策略是否开启，当键值为1时表示开启，此时的容器网络访问是畅行无阻的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo sysctl -w net.ipv4.ip_forward=0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用上面的命令可以临时将这个参数的键值改为0，此时我们发现容器只能访问到同一网段的其它容器而无法访问到宿主机所在的局域网中，与此同时，我们只要保证作为路由器的宿主机上没有运行开启端口的应用，就应该是安全的。可是随后注意到一个问题，关闭容器对外的端口转发后，外界对于容器的访问也一起被禁止了。&lt;/p&gt;
&lt;p&gt;这样的话，只能乖乖的在iptables上做文章了。因为不是介绍iptables的文章，就不多对这个Linux下自带的防火墙做过多的介绍。我的想法是使用宿主机的iptables禁止相应的应用容器访问外网（包括宿主机所在的局域网），这样既能实现容器限制，又不会影响外界访问容器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo iptables -I FORWARD -i docker0 -o ens33 -j DROP
sudo iptables -I FORWARD -i docker0 -o ens33 -m state --state RELATED,ESTABLISHED  -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该命令可以从宿主机的层面限制容器对外的访问，这样可以从一定程度上解决通过容器做跳板的问题。这样的场景实际上就像是将容器设置成只有一条单向入口的孤岛，只允许外界对容器进行访问，而不允许使用容器在做进一步的其它网络访问。&lt;/p&gt;
&lt;h2 id=&quot;0x03-另类视角二：文件监控&quot;&gt;&lt;a href=&quot;#0x03-另类视角二：文件监控&quot; class=&quot;headerlink&quot; title=&quot;0x03 另类视角二：文件监控&quot;&gt;&lt;/a&gt;0x03 另类视角二：文件监控&lt;/h2&gt;&lt;p&gt;除了上述限制的方法外，我们还可以对于容器中的重点文件夹或文件做监控，一旦检测到相应的文件发生变化，可以立即重新生成新的镜像，以应对攻击。&lt;/p&gt;
&lt;p&gt;这里的架构思路如下，作为监控程序，它不应该位于目标容器内，所以我们考虑使用我在上一个谈论Docker日志的笔记里提到的挂载的方式，将容器内部重要的文件夹挂载进监控容器内，在监控容器内运行程序监控相应文件的增、删、改等操作，一旦发现不被允许的操作执行，就关闭容器或者重新构建容器。具体文件监控容器方面的学习有机会再在后面贴出。&lt;/p&gt;
&lt;h2 id=&quot;0x04-综述&quot;&gt;&lt;a href=&quot;#0x04-综述&quot; class=&quot;headerlink&quot; title=&quot;0x04 综述&quot;&gt;&lt;/a&gt;0x04 综述&lt;/h2&gt;&lt;p&gt;Docker一旦部署到真实环境中，我们就要对它的安全性做全面的衡量，不过通过上述分析，在排除可能存在0Day的情况下，只要配置得当，Docker的安全性还是有保障的。&lt;/p&gt;
&lt;p&gt;由于容器的便携性、易部署性、隔离性，我们可以很方便的在部署容器服务的同时，连带部署一系列的监控、处理容器对于服务容器做维护。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-别人说&quot;&gt;&lt;a href=&quot;#0x01-别人说&quot; class=&quot;headerlink&quot; title=&quot;0x01 别人说&quot;&gt;&lt;/a&gt;0x01 别人说&lt;/h2&gt;&lt;p&gt;Docker安全的问题有许多的相关文章分析，援引“Docker安全那些事”中提到的，Dock
    
    </summary>
    
      <category term="Docker" scheme="http://phantom0301.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://phantom0301.github.io/tags/Docker/"/>
    
      <category term="信息安全" scheme="http://phantom0301.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="入门" scheme="http://phantom0301.github.io/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>再探Docker-日志收集</title>
    <link href="http://phantom0301.github.io/2016/07/20/%E5%86%8D%E6%8E%A2Docker-%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/"/>
    <id>http://phantom0301.github.io/2016/07/20/再探Docker-日志收集/</id>
    <published>2016-07-20T08:11:59.000Z</published>
    <updated>2016-07-21T05:52:12.353Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x01-方法选择&quot;&gt;&lt;a href=&quot;#0x01-方法选择&quot; class=&quot;headerlink&quot; title=&quot;0x01 方法选择&quot;&gt;&lt;/a&gt;0x01 方法选择&lt;/h2&gt;&lt;p&gt;当我们的Docker部署完成后，为了能够掌握Docker的状态，除了使用logs、event、diff等实时运维命令查看外，我们还存在需要对Docker产生的日志进行收集整理分析的必要。&lt;/p&gt;
&lt;p&gt;网上能找到的日志收集系统有很多，例如Flume、Fluentd、Logstash等等。经过一段时间的摸索搭建，个人最容易搭建成功的是Logstash，而且整个ELK体系也提供一套完整的日志收集、存储、查找、可视化流程，可以省去很多编写中间件的精力。&lt;/p&gt;
&lt;h2 id=&quot;0x02-调试&quot;&gt;&lt;a href=&quot;#0x02-调试&quot; class=&quot;headerlink&quot; title=&quot;0x02 调试&quot;&gt;&lt;/a&gt;0x02 调试&lt;/h2&gt;&lt;p&gt;所以最终我的整体架构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker1\
        \
docker2——————&amp;gt;docker-logstash————&amp;gt;任意机器（可以不是宿主机）
        /
docker3/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ELK一整套工具可以很方便的从Elastic的官网上下到，在这里就不在赘述。在任意一台主机上安装Elasticsearch和Kibana，在宿主机上安装不同的Docker以及一个Logstash的Docker。这里我使用我在上一篇博客中编译好的Wordpress的Docker。不同的是我需要将WP中记录日志的文件夹挂载到logstash-docker上。命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -d -v /var/log/nginx/ --name wordpress -p 0.0.0.0:80:80 long/wordpress
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;简单解释一下这条命令，我们运行了之前编译好的Wordpress，将其中的Nginx下的日志挂载出来。&lt;/p&gt;
&lt;p&gt;接下来，我们再从官网仓库中pull下Docker版的Logstash，使用如下命令开启：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -it --rm --volumes-from wordpress -v &amp;quot;$PWD&amp;quot;:/home  logstash logstash -f /home/test.conf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里有几个坑要事先声明一下，一个是这里我使用了Logstash的配置文件，而这个配置文件我是从宿主机挂载到容器的home文件夹下，另一个点就是Logstash容器从Wordpress中接手之前挂载的文件夹，从里面实时增量读取日志，但是两个容器的权限不对应，所以要注意在Wordpress容器对相应的文件夹做权限变更。&lt;/p&gt;
&lt;p&gt;Logstash的配置文件我写法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;input {
    file {
        path =&amp;gt; &amp;quot;xxxx&amp;quot;
        start_position =&amp;gt; beginning
         }
      }
filter {

       }

output {
    stdout { }
       }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从日志中读取信息，打印在标准输出中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/docker21.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这一步调试成功后，我们接着调试Elastic的部分，Elastic+Kibana我是运行在一台Windows的主机上的，运行前调整Elastic的配置文件中的，使得宿主机可以访问到它，当然这里的访问是没有任何认证的，但是作为测试，我们先不讨论安全问题。&lt;/p&gt;
&lt;p&gt;通过windows主机访问宿主机上的Wordpress-docker，然后访问&lt;/p&gt;
&lt;p&gt;此时，宿主机中容器的日志已经显示在了Windows的主机中。&lt;/p&gt;
&lt;h2 id=&quot;0x03-总结&quot;&gt;&lt;a href=&quot;#0x03-总结&quot; class=&quot;headerlink&quot; title=&quot;0x03 总结&quot;&gt;&lt;/a&gt;0x03 总结&lt;/h2&gt;&lt;p&gt;利用这种方式，我们实现了容器日志传输到任意主机上存储的目的，而日志传输则是通过在多个容器之间挂载目录实现。这样做，可以很好的实现应用、日志（或数据）之间的解耦合，将重要日志存储在更安全的实体主机上，便于实现中心对应分布的日志分析。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-方法选择&quot;&gt;&lt;a href=&quot;#0x01-方法选择&quot; class=&quot;headerlink&quot; title=&quot;0x01 方法选择&quot;&gt;&lt;/a&gt;0x01 方法选择&lt;/h2&gt;&lt;p&gt;当我们的Docker部署完成后，为了能够掌握Docker的状态，除了使用logs、e
    
    </summary>
    
      <category term="Docker" scheme="http://phantom0301.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://phantom0301.github.io/tags/Docker/"/>
    
      <category term="入门" scheme="http://phantom0301.github.io/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>效率利器-NSSM</title>
    <link href="http://phantom0301.github.io/2016/07/19/%E6%95%88%E7%8E%87%E5%88%A9%E5%99%A8-NSSM/"/>
    <id>http://phantom0301.github.io/2016/07/19/效率利器-NSSM/</id>
    <published>2016-07-19T13:20:30.000Z</published>
    <updated>2016-07-19T13:45:41.203Z</updated>
    
    <content type="html">&lt;p&gt;NSSM(the Non-Sucking Service Manager),作为英语战五渣，为了弄清它的中文译名也是查了很多资料，关键在于Non-Sucking这个词应该如何翻译，姑且翻译成“不糟糕的服务管理器”这样页游装备名般的中文。&lt;/p&gt;
&lt;p&gt;言归正传，NSSM是一款开源的Windows下”好用的服务管理工具”，根据它自己的介绍，之所以叫“Non-Sucking”,是因为其他类似的工具都不能很好的处理正在运行中的应用失败的情况。感觉上它有点像Ubuntu下的supervisor。&lt;/p&gt;
&lt;p&gt;而服务管理工具的作用其实就是将运行的应用封装成系统服务，这样针对于一些bat的脚本程序可以快速执行操纵命令并监控程序是否存活,就像下面的样子，我将ELK应用作为服务来启动：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/N1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;下载方面可以访问这个地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nssm.cc/download&quot; title=&quot;https://nssm.cc/download&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://nssm.cc/download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用方面十分简单，将下载好的文件进行解压，再将nssm.exe复制到需要启动的应用所在目录中，在当前目录执行cmd命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nssm install &amp;lt;servicename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时就会弹出安装界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nssm.cc/images/install_application.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Application界面的Path配置需要启动的exe或者bat等程序的路径，Detail界面命名服务名和描述信息，Dependencies界面配置依赖的环境，就是已有的服务名。&lt;/p&gt;
&lt;p&gt;将这些基本信息配置好后，点击Install service安装完毕。&lt;/p&gt;
&lt;p&gt;这个时候，可以在控制面板-管理-服务中看到已经安装成功的服务，通过这个界面可以打开服务，这时，你所指定的程序应用就以服务的名义运行起来了。&lt;/p&gt;
&lt;p&gt;先在这里安利这款工具以及它的基本运行命令，详细的官方文档有时间会在后面翻译出来吧~~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;NSSM(the Non-Sucking Service Manager),作为英语战五渣，为了弄清它的中文译名也是查了很多资料，关键在于Non-Sucking这个词应该如何翻译，姑且翻译成“不糟糕的服务管理器”这样页游装备名般的中文。&lt;/p&gt;
&lt;p&gt;言归正传，NSSM是一
    
    </summary>
    
    
      <category term="工具" scheme="http://phantom0301.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Docker快速入门</title>
    <link href="http://phantom0301.github.io/2016/07/16/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://phantom0301.github.io/2016/07/16/Docker快速入门/</id>
    <published>2016-07-16T01:14:01.000Z</published>
    <updated>2016-07-18T13:30:14.029Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x01-开场白&quot;&gt;&lt;a href=&quot;#0x01-开场白&quot; class=&quot;headerlink&quot; title=&quot;0x01 开场白&quot;&gt;&lt;/a&gt;0x01 开场白&lt;/h2&gt;&lt;p&gt;套用介绍Docker的话，Docker是一个开源的引擎，可以创建一个轻量级的虚拟系统。由于它可以更加轻量级的实现虚拟机的作用，而且它自带很多很方便的监控运行系统状态的特性，所以受到大家的青睐。&lt;/p&gt;
&lt;p&gt;这篇博客旨在快速部署Docker，并不是对Docker进行深入研究，所以只会说说我在实际用Docker的过程中使用频次较高的实际指令，并不会详细介绍Docker基于Linux的底层实现原理和理论的东西，如果有错误请留言指正。&lt;/p&gt;
&lt;p&gt;这里我使用Ubuntu16.04进行测试。先说说Docker的安装，最简单的方法的直接使用Ubuntu的apt-get安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install docker
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而我为了能够安装最新版的Docker，使用下面更加复杂的方法：&lt;/p&gt;
&lt;p&gt;1.升级source列表，安装相应的ca证书&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install apt-transport-https ca-certificates
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.增加密钥&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.添加源列表文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo vi /etc/apt/sources.list.d/docker.list
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.按照系统版本增加entry&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo deb https://apt.dockerproject.org/repo ubuntu-xenial main
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.安装docker并测试&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install docker-engine
sudo service docker start
sudo docker run hello-world
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个时候docker程序会先检查本地仓库是否有镜像，如果没有，就会从官方的仓库中拉取相应的镜像并运行它。而这个hello-world的程序还会打印出官方的一些帮助信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/docker1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x02-常用命令&quot;&gt;&lt;a href=&quot;#0x02-常用命令&quot; class=&quot;headerlink&quot; title=&quot;0x02 常用命令&quot;&gt;&lt;/a&gt;0x02 常用命令&lt;/h2&gt;&lt;p&gt;接着上一节拉取到的镜像，我们就用这个镜像说明Docker会经常用到的一些指令。&lt;/p&gt;
&lt;p&gt;0.快速的搜寻镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker search 镜像名或id
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种方法可以快速的从官方仓库查找可用的镜像，相比起直接访问官网查询，这种方法不用太多的等待，不足之处在于，作为初心者，这种方式几乎看不到镜像的详细使用说明，对新手的使用并不够友好，而在官网上可以看到作者的详细使用说明和Dockerfile文件，更适合我们入门学习。&lt;/p&gt;
&lt;p&gt;1.安静的拉取镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker pull 镜像名或id
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个命令只会从官方仓库下载镜像到本地，并不会执行生成容器。 &lt;/p&gt;
&lt;p&gt;2.方便的掌握镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker images
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看本地仓库中的可用镜像&lt;/p&gt;
&lt;p&gt;3.常用的运行方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -it 镜像名或id /bin/bash
docker run -d 镜像名或id
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上两种是学习过程中经常能够看到的命令，前者适合对于生成的容器进行调试，而且即使没有前台进程（后面会说这个的关系），它也可以运行起来；后者多作为真正部署时使用。&lt;/p&gt;
&lt;p&gt;之所以会这样，当然是因为run后面不同的参数值了，i参数是为了保持stdin打开，t参数是为了维持一个为终端，而d参数测试在后台运行容器。&lt;/p&gt;
&lt;p&gt;当容器运行在后台时，它就有点像我们通常在Windows下执行可执行程序的逻辑，当没有循环或者其他逻辑维持它的前台进程时，容器就会自动结束。所以当使用d参数时，就需要有一个前台进程来保持容器的运行。&lt;/p&gt;
&lt;p&gt;run指令下还有一些常用的参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-a参数，负责进行连接附加，可以连接标准输入输出等
-e参数，设置环境变量，例如一些数据库镜像的生成时的参数
--name，重命名容器，方便进行管理，避免了你输入那些随机生成的科学家名或者ID
-p参数，将容器内的端口映射到宿主机相应端口
-v参数，挂载容器内的内容
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他参数可以直接查阅手册，这里只列出了我常用到的参数。&lt;/p&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;p&gt;我们运行一个由我自己编译的wordpress镜像，内置数据库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/docker2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们先用images查看可用的镜像&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/docker3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在使用下面这个指令来启动镜像，生成容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker -d --name wordpress -p 0.0.0.0：80：80 镜像名或id
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;生成的同时，容器被赋予了一个唯一的ID&lt;/p&gt;
&lt;p&gt;4.常用的维护命令&lt;/p&gt;
&lt;p&gt;还是如上图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker ps 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以查看正在运行的容器和基本信息，而-l参数则显示上一次运行过的容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker inspect 容器名或id
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以查看容器的详细信息，这个指令的输出较多，就不截图了。不过这个指令结果里有几个重要参数值的我们注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;容器的宿主机存储路径，包括容器主机名、配置信息、日志等&lt;/li&gt;
&lt;li&gt;容器映射出的端口信息&lt;/li&gt;
&lt;li&gt;网络服务的配置信息，包括容器ip、DNS等&lt;/li&gt;
&lt;li&gt;运行环境的配置信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这些信息可以帮助我们更好的去认识镜像、容器、宿主机之间的关系&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker exec -it 容器名 /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这条指令可以方便我们去访问后台运行状态的容器内部，进行修改添加应用，当然，也可以在一开始就给容器开一个ssh进行管理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker events/logs/info
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这几条指令都是将容器当前运行的一些事件、日志信息输出到宿主机界面上，方便我们进行容器部署应用的观察和管理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker commit 容器名 镜像名：标签
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;提交一个你修改满意的容器到本地仓库生成相应的镜像&lt;/p&gt;
&lt;p&gt;5.常用的删除启动命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker start/stop/restart 容器名
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个不用多解释了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker rm 容器名
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;永久删除当前容器，但是前提是先stop了这个容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker rmi 镜像名
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;永久删除本地仓库中的镜像&lt;/p&gt;
&lt;p&gt;有了这几条命令，简单运行一个Docker就基本逻辑可以走顺了，当然，完整的命令请参照官方手册。&lt;/p&gt;
&lt;p&gt;还有几个关键命令会在下一节适合它们的地方登场。&lt;/p&gt;
&lt;h2 id=&quot;0x03-DIY&quot;&gt;&lt;a href=&quot;#0x03-DIY&quot; class=&quot;headerlink&quot; title=&quot;0x03 DIY&quot;&gt;&lt;/a&gt;0x03 DIY&lt;/h2&gt;&lt;p&gt;官方仓库中经过认证和未认证的项目有上千例（未具体求证），基本满足我们的应用部署需要，但是，有时候我们的有一些特殊需求时，可能就需要我们自己去编译一个镜像。&lt;/p&gt;
&lt;p&gt;当然，在介绍这部分之前，不得不提一个Dockeric（不保证有这么个词）的观点，Docker实现的容器应该是模块化的，所以每一个单独的容器最好只运行一个单独的进程，复杂的逻辑关系应该通过容器间的连接（–link）实现。向我在之前作为例子实现的wordpress其实就是一个反例，因为我在一个容器中同时放入了wordpress进程和mysql进程。所以，在DIY编译镜像时，尽量不要想使用vmware那样放太多的东西进去，小心鸡蛋砸在一个Container里~~。&lt;/p&gt;
&lt;p&gt;先入门基本指令，我以我的wordpress为例：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;FROM ubuntu:14.04&lt;/p&gt;
&lt;p&gt;MAINTAINER xxxx &lt;a href=&quot;&amp;#x6d;&amp;#97;&amp;#105;&amp;#108;&amp;#116;&amp;#x6f;&amp;#58;&amp;#x78;&amp;#120;&amp;#x78;&amp;#x78;&amp;#x40;&amp;#120;&amp;#x78;&amp;#120;&amp;#x78;&quot;&gt;&amp;#x78;&amp;#120;&amp;#x78;&amp;#x78;&amp;#x40;&amp;#120;&amp;#x78;&amp;#120;&amp;#x78;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ENV DEBIAN_FRONTEND noninteractive&lt;/p&gt;
&lt;p&gt;RUN apt-get update&lt;/p&gt;
&lt;p&gt;RUN apt-get -y upgrade&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上手先W再E，FROM决定整个镜像的根基，你是打算用Ubuntu:14.04，Ubuntu:latset，CentOS还是什么其他的；MAINTAINER填写创建者信息；RUN是运行安装指令的基础；ENV设置环境变量&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RUN apt-get -y install mysql-server mysql-client nginx php5-fpm php5-mysql php-apc pwgen python-setuptools curl git unzip&lt;/p&gt;
&lt;p&gt;RUN sed -i -e”s/^bind-address\s&lt;em&gt;=\s&lt;/em&gt;127.0.0.1/bind-address = 0.0.0.0/“ /etc/mysql/my.cnf&lt;br&gt;……&lt;/p&gt;
&lt;p&gt;ADD ./nginx-site.conf /etc/nginx/sites-available/default&lt;/p&gt;
&lt;p&gt;EXPOSE 3306&lt;/p&gt;
&lt;p&gt;EXPOSE 80&lt;/p&gt;
&lt;p&gt;VOLUME [“/var/lib/mysql”, “/usr/share/nginx/www”]&lt;/p&gt;
&lt;p&gt;CMD [“/bin/bash”, “/start.sh”]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着Q后面接R，ADD可以拷贝编译文件夹下的文件到镜像生成后的容器的相应文件夹下，EXPOSE则设置容器内部开启的端口，VOLUME负责挂载容器的文件，CMD是容器启动时执行的命令。而有多条CMD命令时，只执行最后的一行的CMD命令。&lt;/p&gt;
&lt;p&gt;当然这个文件只是说明，并不完整，完整的Dockerfile官网上有很多，我就不把我写的蹩脚file放到这里了。&lt;/p&gt;
&lt;p&gt;写好写指令后，保存为Dockerfile文件名，存在一个文件夹下，把相应的外部文件也都移到一起。&lt;/p&gt;
&lt;p&gt;在当前目录下执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker build -t 自己起的镜像名 .（这里还有一点，别看掉了）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;程序就会按照你指定的安装流程进行相应的安装了。&lt;/p&gt;
&lt;h2 id=&quot;0x04-结语&quot;&gt;&lt;a href=&quot;#0x04-结语&quot; class=&quot;headerlink&quot; title=&quot;0x04 结语&quot;&gt;&lt;/a&gt;0x04 结语&lt;/h2&gt;&lt;p&gt;还是要说一下，这一篇是基于快速部署而写下的，内容肯定很浅薄，后面随着我对Docker学习的深入，应该还会有更进一步的经验总结和实际应用。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-开场白&quot;&gt;&lt;a href=&quot;#0x01-开场白&quot; class=&quot;headerlink&quot; title=&quot;0x01 开场白&quot;&gt;&lt;/a&gt;0x01 开场白&lt;/h2&gt;&lt;p&gt;套用介绍Docker的话，Docker是一个开源的引擎，可以创建一个轻量级的虚拟系统。由于它
    
    </summary>
    
      <category term="Docker" scheme="http://phantom0301.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://phantom0301.github.io/tags/Docker/"/>
    
      <category term="入门" scheme="http://phantom0301.github.io/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>碎碎念</title>
    <link href="http://phantom0301.github.io/2016/07/04/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <id>http://phantom0301.github.io/2016/07/04/碎碎念/</id>
    <published>2016-07-04T10:49:17.000Z</published>
    <updated>2016-07-04T10:50:13.454Z</updated>
    
    <content type="html">&lt;p&gt;离别的氛围仿佛嵌进了空气一般，凝结在每一次的呼吸中。作为留守者，送别一个个远去的身影也仿佛成为了一种义务。有时明知道结果是离别，便不愿投入太多在一件事，一个人上，可是在还未分别的时光消磨下，也不知不觉的将他们在心中的地位不断提升，等到真正的离别到来时，才发现，哦，原来再向他们说分别已是如此的困难了。&lt;/p&gt;
&lt;p&gt;我们的生命就这样被分割成了一段段的相遇和离别，无论如何好像也摆脱不掉这样的轮回。在一整段的时光里看起来是那样的光鲜亮丽，可若是逢着连接整段时光的那些间隙，就难免让人有些失落和孤寂。毕竟，和一群人一起拥有了那么多的回忆，可是转瞬，就只剩下了你自己。&lt;/p&gt;
&lt;p&gt;终究一切的碎碎念和不好的情绪都要被自己消化掉，也渐渐强迫着用麻木的心态去对待这些离别，有时这被称为成长或是强大。当然，运动和其他的什么爱好可以作为占据内心的那些人或事离开时暂时的寄托，于是制订一项项学习，锻炼的计划也是远离不安孤寂不错的方法。&lt;/p&gt;
&lt;p&gt;其实做出某些选择时，前方未知的道路便已经渐渐露出了它延伸的方向。而我们能够做的，是决定以什么样的姿态去走完它。我总是希望自己最终不会败给生活中的苟且，希望即便有可能充满艰难，但依然在不易中有自己去选择的权利和自由。离开了一群人，我希望再相遇一些能让我不舍得人。结束了一段还尚且满意的生涯，我希望能够依然在接下去的时光中昂首前进。&lt;/p&gt;
&lt;p&gt;山已成隍，花已成尘，就在这变迁中不忘初心，追逐梦想。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;离别的氛围仿佛嵌进了空气一般，凝结在每一次的呼吸中。作为留守者，送别一个个远去的身影也仿佛成为了一种义务。有时明知道结果是离别，便不愿投入太多在一件事，一个人上，可是在还未分别的时光消磨下，也不知不觉的将他们在心中的地位不断提升，等到真正的离别到来时，才发现，哦，原来再向他
    
    </summary>
    
      <category term="感悟" scheme="http://phantom0301.github.io/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="感悟" scheme="http://phantom0301.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>闲谈-隐匿于网络中的入侵者</title>
    <link href="http://phantom0301.github.io/2016/05/18/%E9%97%B2%E8%B0%88-%E9%9A%90%E5%8C%BF%E4%BA%8E%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%85%A5%E4%BE%B5%E8%80%85/"/>
    <id>http://phantom0301.github.io/2016/05/18/闲谈-隐匿于网络中的入侵者/</id>
    <published>2016-05-18T12:05:53.000Z</published>
    <updated>2016-05-18T13:12:18.241Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x00&quot;&gt;&lt;a href=&quot;#0x00&quot; class=&quot;headerlink&quot; title=&quot;0x00&quot;&gt;&lt;/a&gt;0x00&lt;/h2&gt;&lt;p&gt;最近一段时间都在赶毕业设计了，觉得这期间被挖出来的那些影响比较大的漏洞都没有细致的去了解。不过论文之余，晚上睡前都在看Gregory Fell和Mike Barlow的《Who are the bad guys and what do they want？》，其中的第一部分就是书名的前半段。&lt;/p&gt;
&lt;p&gt;查过一些作者们的资料，似乎两位都不是专门研究信息安全的学者，所以书中大量的内容其实应该是来自作者们对于相关专家话语的记录，不过书中提到的很多观点都很有意思。&lt;/p&gt;
&lt;h2 id=&quot;0x01-白帽子还是黑帽子&quot;&gt;&lt;a href=&quot;#0x01-白帽子还是黑帽子&quot; class=&quot;headerlink&quot; title=&quot;0x01 白帽子还是黑帽子&quot;&gt;&lt;/a&gt;0x01 白帽子还是黑帽子&lt;/h2&gt;&lt;p&gt;我们经常会给一些hacker或是cracker（这两者是很不一样的）贴上一些标签，这是个白帽子平台，那是个黑帽子社区等等。但在文章中提到，有时候这些表面上的标签往往会让我们忽视某一群体在发现漏洞时的意图。&lt;/p&gt;
&lt;p&gt;那么在这种情况下，单纯的用“好人”或者“坏人”这样二进制意味浓厚的划分原则将会掩盖复杂的入侵意图。&lt;/p&gt;
&lt;p&gt;使用意图来对攻击进行定义或许能够让我们看到事情的本质。有些是出于研究意图的测试，那么这种行为往往带有友好的提醒；有些是出于个人情感，对于个人或者企业的一种打击报复；有些纯粹是出于贪婪，企图获取金钱或者其他利益；还有的可能是更复杂的情况，包括各国之间的窥探行为，或者只是偶然的一个点击等等，这些意图彼此之间并非泾渭分明的，它们往往能够在一定条件下进行转化。&lt;/p&gt;
&lt;p&gt;实际情况将会比上述这样简单的理论层面的分类更趋于多样化，大家也可以结合自身的经历来分析身边的“意图”，而不是仅仅靠扣上几个颜色的帽子就定义出谁是正义的谁是邪恶的。&lt;/p&gt;
&lt;h2 id=&quot;0x02-隐匿在网络中的人&quot;&gt;&lt;a href=&quot;#0x02-隐匿在网络中的人&quot; class=&quot;headerlink&quot; title=&quot;0x02 隐匿在网络中的人&quot;&gt;&lt;/a&gt;0x02 隐匿在网络中的人&lt;/h2&gt;&lt;p&gt;很多时候，我们的视线都汇聚到一个0day是怎么实现的、泄露出的数据体量到底有多少、哪个著名的企业在圣诞前夕又被DDOS威胁了等等这些十分吸引眼球的问题上，当然关注这些问题也是十分有意义的。不过，对于漏洞背后人的探索似乎很多时候没有引起足够多的关注。&lt;/p&gt;
&lt;p&gt;之前说过我们不应该简单的通过扣帽子的方式来给网络中的人们下定义，而是应该确定出那些驱使他们挖掘漏洞的因素。&lt;/p&gt;
&lt;p&gt;这里用了书中的一张表来对网络中的活动者下定义，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160518204514.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这张表中划分出的类别算是补充了之前我的认知，他将网络中的活动者分成了五类，其实这些词不是太好准确的翻译，大概是内部人员、网络犯罪者、纯粹的黑客、恐怖分子和国家层面活动者，同样的，这些角色彼此之间也都是有关联的，那么按照我的想法，将图中几个角色的位置重新放置一下，我们其实可以做一个雷达图来对每一个信息安全事件背后的行动派进行角色判定，这样我们更能够清晰的认识到许多的网络活动的目的都不会那么的单一。&lt;/p&gt;
&lt;h2 id=&quot;0x03-是管理风险还是管理代码&quot;&gt;&lt;a href=&quot;#0x03-是管理风险还是管理代码&quot; class=&quot;headerlink&quot; title=&quot;0x03 是管理风险还是管理代码&quot;&gt;&lt;/a&gt;0x03 是管理风险还是管理代码&lt;/h2&gt;&lt;p&gt;另一个在书中提到的认知就是，信息安全的问题恐怕很难通过技术的进步去解决，无论你有多么先进的加密手段、无论你的机器学习能够模仿多么专业的安全研究人员，入侵者依然能够找到撕破防线的短板。当防线被攻破，最终，信息安全问题转化为了一个风险控制的问题。&lt;/p&gt;
&lt;p&gt;那么在这种情况下，采用更加合理的风险控制策略可能起到的作用会大于在代码中加入了一段安全的防护。当然，这两者并未站在对立的两个极端，我们显然可以通过彼此结合的手段来增强对资产的防护，当然，这里提到的是谁更应该放在主位的问题。&lt;/p&gt;
&lt;h2 id=&quot;0x04-结尾&quot;&gt;&lt;a href=&quot;#0x04-结尾&quot; class=&quot;headerlink&quot; title=&quot;0x04 结尾&quot;&gt;&lt;/a&gt;0x04 结尾&lt;/h2&gt;&lt;p&gt;就瞎扯到这里，好像后面和主题已经无关了，不管那么多了。&lt;/p&gt;
&lt;p&gt;有兴趣的可以阅读他们的原书。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00&quot;&gt;&lt;a href=&quot;#0x00&quot; class=&quot;headerlink&quot; title=&quot;0x00&quot;&gt;&lt;/a&gt;0x00&lt;/h2&gt;&lt;p&gt;最近一段时间都在赶毕业设计了，觉得这期间被挖出来的那些影响比较大的漏洞都没有细致的去了解。不过论文之余，晚上睡前都在看Gre
    
    </summary>
    
      <category term="读书笔记" scheme="http://phantom0301.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="信息安全" scheme="http://phantom0301.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="闲谈" scheme="http://phantom0301.github.io/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>略读《通鉴》-汉纪-那些打破我们常规认识的宦官形象</title>
    <link href="http://phantom0301.github.io/2016/04/14/%E7%95%A5%E8%AF%BB%E3%80%8A%E9%80%9A%E9%89%B4%E3%80%8B-%E6%B1%89%E7%BA%AA/"/>
    <id>http://phantom0301.github.io/2016/04/14/略读《通鉴》-汉纪/</id>
    <published>2016-04-14T09:53:27.000Z</published>
    <updated>2016-04-20T01:48:49.910Z</updated>
    
    <content type="html">&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;闲暇时候随手翻阅了kindle中存的《资治通鉴》，本来只是随便阅读些史料，但是偶然中读到了黄门吕强其人其事，突然有了一个想法。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;平时我们在电视剧电影中经常看到宦官这一形象，在影视作品中，宦官时而被描写为武艺高强的大反派，时而被描写为性格诡谲的小人，也有一些作品中，宦官被赋予了是非分明的形象。那么，在真实的史料中，是否有像我们在影视剧中定位的贤良的宦官形象呢？&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;主要阅读的是《通鉴》中汉纪光武以后到三国的部分，在此以前的西汉历史中，为了避免秦末赵高大权独揽情况的发生，内侍人员多使用士人，到了东汉，开始使用宦官。这一段史料中出现的第一个符合我们要求的形象是中常侍钩盾令郑众，钩盾令主要负责园苑游观之事。这时是汉和帝时期，由于外戚窦宪专政，朝臣莫不附之，但是郑众谨敏有心机，没有附和窦宪，最终与和帝一起定策诛宪。蔡伦大家都比较了解，这里就不赘述。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;接下来要说的就是中常侍孙程，这里背景简略说一下，当时的皇帝听信另一批宦官的谗言，废除皇太子为济阴王，后来皇后和外戚就立了北乡侯。没过多久，北乡侯就死了，这时之前的废太子还在，而皇后和进谗言的宦官希望立其他的外藩王为帝。这时孙程对废太子的侍从说到：“王以嫡统，本无失德。先帝用谗，遂至废黜。若北乡侯不起，相与共断江京、阎显，事无不成者。”最终，孙程和王康等十九人歃血为盟，斩除了外戚阎显以及同党，迎立了废太子登基。后来司隶校尉虞诩被宦官诬陷，要治死罪，孙程直接上殿，呵斥构陷者，被皇帝免官。后来，皇帝追念他的功勋，又把他召回了京师。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;第三个要说的是曹操名义上的祖父——曹腾。曹腾早年也是因为迎立汉桓帝有功，被封为费亭侯，升任大长秋，史书说他在宫中三十多年，没有显著地过失，并且能推荐贤人，陈留虞放、边韶、南阳延固、张温、弘农张奂、颍川堂谿典等都受到他的举荐。有一次，刺史种暠因为截获了外官打算贿赂曹腾的文书，于是弹劾曹腾，皇帝因为文书是从外地发来，便不予追究。后来曹腾还称赞种暠为能吏，种暠最后官至司徒，还说道他能做到这个职位，都是曹腾的功劳。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;最后要提到的就是中常侍吕强，这个人在《通鉴》里面描述颇多。说吕强从黄门升到中常侍，为人清忠奉公。汉灵帝时，封他为都乡侯，他辞让不肯接受，而且还上书劝说皇帝注意宦官为乱，后宫采女不应太多，河间不应该劳民伤财筑解渎馆，另外还上书说蔡邕对策切直，不应该治他的罪等等。后来黄巾之乱爆发，他又劝说皇帝赦免党人，诛杀贪官，考核地方官员。最终被同僚忌惮，吕强愤而自杀。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;在这一段所谓的宦官第一次当权的历史中，还有像良贺、丁肃、徐衍、赵祐等等和当时大批专权的宦官不同的形象，和影视剧中相比，让我们对于宦官形象有了不一样的认识。其实，从春秋战国到明末，不时的都能够在史料中看到这样一个群体打破大众对他们固有印象的事件，比如一些后来著名的治世能臣早年在宦官门下当食客，后经主人举荐得到君王赏识；一些人同时也是当时的书法家、匠人或者在经史学说上有所成就；还有一些人以忠于君王，同君王共赴危难而得到史家的青睐。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;闲暇时候随手翻阅了kindle中存的《资治通鉴》，本来只是随便阅读些史料，但是偶然中读到了黄门吕强其人其事，突然有了一个想法。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;平时我们在电视剧电影中经
    
    </summary>
    
      <category term="读书笔记" scheme="http://phantom0301.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="宦官" scheme="http://phantom0301.github.io/tags/%E5%AE%A6%E5%AE%98/"/>
    
      <category term="资治通鉴" scheme="http://phantom0301.github.io/tags/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/"/>
    
  </entry>
  
  <entry>
    <title>Js-Python实现socket通信</title>
    <link href="http://phantom0301.github.io/2016/04/12/Js-Python%E5%AE%9E%E7%8E%B0socket%E9%80%9A%E4%BF%A1/"/>
    <id>http://phantom0301.github.io/2016/04/12/Js-Python实现socket通信/</id>
    <published>2016-04-12T07:51:55.000Z</published>
    <updated>2016-04-12T08:38:25.979Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;Socket，一种开销很小的实现程序之间通信的方式。不同的编程语言几乎都有自己实现Socket的库和方法，建立在Socket基础上的许多通信协议也都广泛运用于各种框架中，之前在博客分享的Hpfeeds协议实际上就是建立在Socket的基础上。&lt;/p&gt;
&lt;p&gt;不同编程语言之间也经常使用Socket来传递消息，这样可以避免不同语言之间的嵌套调用。如题，这里我们需要在Python和Js之间实现一个消息传递。&lt;/p&gt;
&lt;h2 id=&quot;0x01-实现&quot;&gt;&lt;a href=&quot;#0x01-实现&quot; class=&quot;headerlink&quot; title=&quot;0x01 实现&quot;&gt;&lt;/a&gt;0x01 实现&lt;/h2&gt;&lt;p&gt;最初查找资料的时候，许多博客中都提到了说，Js本身是不能够实现Socket的，而常用的方法实际上是利用Flash的Socket来进行通信，然后通过Js获得Flash的响应事件来传递数据。为此有一个专门的Js库叫Aflax。&lt;/p&gt;
&lt;p&gt;同时，另一种更新的方法是使用Html5协议中的WebSocket来实现浏览器和服务器的通信。&lt;/p&gt;
&lt;p&gt;关于WebSocket的具体协议就不在这里详述了，毕竟我也没有认真去看。&lt;/p&gt;
&lt;p&gt;实现WebSocket通信的方法也有很多种，网上容易查到的是使用Node.js的实现方法&lt;br&gt;&lt;a href=&quot;https://github.com/SushisMakis/WebSocket&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/SushisMakis/WebSocket&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里，作者提供个一个Python实现的服务器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import struct
import SocketServer
from base64 import b64encode, b64decode
from hashlib import sha1
from mimetools import Message
from StringIO import StringIO

clients = [];
class WebSocketsHandler(SocketServer.StreamRequestHandler):
    magic = &amp;apos;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&amp;apos;

    def setup(self):
        SocketServer.StreamRequestHandler.setup(self)
        print &amp;quot;connection established&amp;quot;, self.client_address
        self.handshake_done = False

    def handle(self):
        while True:
            if not self.handshake_done:
                self.handshake()
                clients.append(self)
            else:
                try:
                    self.read_next_message()
                except:
                    self.request.close()
                    return

    def read_next_message(self):
        length = ord(self.rfile.read(2)[1]) &amp;amp; 127
        if length == 126:
            length = struct.unpack(&amp;quot;&amp;gt;H&amp;quot;, self.rfile.read(2))[0]
        elif length == 127:
            length = struct.unpack(&amp;quot;&amp;gt;Q&amp;quot;, self.rfile.read(8))[0]
        masks = [ord(byte) for byte in self.rfile.read(4)]
        decoded = &amp;quot;&amp;quot;
        for char in self.rfile.read(length):
            decoded += chr(ord(char) ^ masks[len(decoded) % 4])
        self.on_message(decoded)

    def send_message(self, data, fin=True, opcode=1, masking_key=False):
        header = struct.pack(&amp;apos;!B&amp;apos;, ((fin &amp;lt;&amp;lt; 7) | (0 &amp;lt;&amp;lt; 6)| (0 &amp;lt;&amp;lt; 5)| (0 &amp;lt;&amp;lt; 4)| opcode))
        if masking_key:
            mask_bit = 1 &amp;lt;&amp;lt; 7
        else:
            mask_bit = 0
        length = len(data)
        if length &amp;lt; 126:
            header += struct.pack(&amp;apos;!B&amp;apos;, (mask_bit | length))
        elif length &amp;lt; (1 &amp;lt;&amp;lt; 16):
            header += struct.pack(&amp;apos;!B&amp;apos;, (mask_bit | 126)) + struct.pack(&amp;apos;!H&amp;apos;, length)
        elif length &amp;lt; (1 &amp;lt;&amp;lt; 63):
            header += struct.pack(&amp;apos;!B&amp;apos;, (mask_bit | 127)) + struct.pack(&amp;apos;!Q&amp;apos;, length)
        body = data
        self.request.send(bytes(header + body))

    def handshake(self):
        data = self.request.recv(1024).strip()
        headers = Message(StringIO(data.split(&amp;apos;\r\n&amp;apos;, 1)[1]))
        if headers.get(&amp;quot;Upgrade&amp;quot;, None) != &amp;quot;websocket&amp;quot;:
            return
        print &amp;apos;Handshaking...&amp;apos;
        key = headers[&amp;apos;Sec-WebSocket-Key&amp;apos;]
        digest = b64encode(sha1(key + self.magic).hexdigest().decode(&amp;apos;hex&amp;apos;))
        response = &amp;apos;HTTP/1.1 101 Switching Protocols\r\n&amp;apos;+&amp;apos;Upgrade: websocket\r\n&amp;apos;+&amp;apos;Connection: Upgrade\r\n&amp;apos;
        response += &amp;apos;Sec-WebSocket-Accept: %s\r\n\r\n&amp;apos; % digest
        self.handshake_done = self.request.send(response)

    def on_message(self, message):
        text = b64decode(message)
        print text
        for client in clients:
            if client.client_address != self.client_address:
                client.send_message(b64encode(text))

class ThreadedTCPServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):
    pass

if __name__ == &amp;quot;__main__&amp;quot;:
    server = ThreadedTCPServer((&amp;quot;localhost&amp;quot;, 9999), WebSocketsHandler)
    server.serve_forever()   
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们使用其中的这段代码作为服务器。&lt;/p&gt;
&lt;p&gt;用这段Ps作为浏览器端的接收Pemo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// SmWebSocket(url,port,b64encode,fonMessage, ...)
var smWs = new SmWebSocket(&amp;quot;localhost&amp;quot;,9999,true,handle_recv);
smWs.open();
var myDictObjectProtocol = {&amp;quot;p1top2&amp;quot;: handle_transit}; // {id : function, ... }
var p = new Protocol(myDictObjectProtocol,&amp;quot;|&amp;quot;);

function handle_recv(event)
{
    var data = event.data;
    data = Base64.decode(data);
    alert(data);
    p.handleMessage(data);
}

function handle_transit(mess){
    document.getElementById(&amp;quot;data_in&amp;quot;).innerText = mess;
} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里作者只实现了浏览器发送到服务器以及浏览器之间的交互，所以现在我们还缺一个Python发送的程序，我最初希望直接使用Pyhton的Socket来实现一个端口发送，但是最后发现每次发送的程序都被服务器拒绝了，所以我又找到了一个Python实现的WebSocket库，当然这个和Pip下载的WebSocket库不同。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/liris/websocket-client&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/liris/websocket-client&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我修改了其中编码的部分，以和之前的程序适应&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from __future__ import print_function
import websocket
import base64

if __name__ == &amp;quot;__main__&amp;quot;:
    #websocket.enableTrace(True)
    ws = websocket.create_connection(&amp;quot;ws://localhost:9999&amp;quot;)
    data = &amp;quot;p1top2|Hello World&amp;quot;
    data = base64.b64encode(data)
    ws.send(data)
    ws.close()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要求的库直接Clone上面项目里的即可，这样，我们就实现了通过Python和Js进行Socket通信的程序。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;Socket，一种开销很小的实现程序之间通信的方式。不同的编程语言几乎都有自己实现Socket的库和
    
    </summary>
    
      <category term="python" scheme="http://phantom0301.github.io/categories/python/"/>
    
    
      <category term="JS" scheme="http://phantom0301.github.io/tags/JS/"/>
    
      <category term="Python" scheme="http://phantom0301.github.io/tags/Python/"/>
    
      <category term="Socket" scheme="http://phantom0301.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>效率利器-Synergy</title>
    <link href="http://phantom0301.github.io/2016/04/06/%E6%95%88%E7%8E%87%E5%88%A9%E5%99%A8-Synergy/"/>
    <id>http://phantom0301.github.io/2016/04/06/效率利器-Synergy/</id>
    <published>2016-04-06T06:52:16.000Z</published>
    <updated>2016-04-06T07:18:11.405Z</updated>
    
    <content type="html">&lt;p&gt;最近要同时操作两台机器，一台是win的，一台是linux的。无论是准备两套键鼠，还是用SSH远程都不够方便。&lt;/p&gt;
&lt;p&gt;在网上找到了这个软件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/sy1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;发现很好的解决了我的需求，而且它不仅可以让两个系统的主机共用一套键鼠，还可以实现两台主机上的简单分屏，虽然不能直接从一个屏幕拖到另一个屏幕，但是鼠标可以无缝连接滑动，而且共享剪贴板。&lt;/p&gt;
&lt;p&gt;设置也很简单&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/sy2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在两台电脑上分别安装Synergy，并且在同一个局域网中。一台作为server主机（键鼠物理连接的电脑），一台作为client从机。&lt;/p&gt;
&lt;p&gt;在主机上进行配置，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/sy3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在这里选择分屏的位置。&lt;/p&gt;
&lt;p&gt;再在 Advanced server settings设置主从机切换的快捷键&lt;/p&gt;
&lt;p&gt;分别启动，软件就会自动去检测主从机。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近要同时操作两台机器，一台是win的，一台是linux的。无论是准备两套键鼠，还是用SSH远程都不够方便。&lt;/p&gt;
&lt;p&gt;在网上找到了这个软件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/sy1.jpg&quot; 
    
    </summary>
    
    
      <category term="工具" scheme="http://phantom0301.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>爆破工具Bruter文档翻译</title>
    <link href="http://phantom0301.github.io/2016/03/25/%E7%88%86%E7%A0%B4%E5%B7%A5%E5%85%B7Bruter%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    <id>http://phantom0301.github.io/2016/03/25/爆破工具Bruter文档翻译/</id>
    <published>2016-03-25T01:54:43.000Z</published>
    <updated>2016-03-25T01:56:44.630Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;说到爆破神器，kali中的msf爆破插件、hydra、medusa都足够强大，这里推荐一款win环境使用的爆破测试工具，bruter。&lt;/p&gt;
&lt;p&gt;仅仅翻译一下官方文档，bruter的所有说明文件都在目录的doc中。&lt;/p&gt;
&lt;h2 id=&quot;0x01-介绍&quot;&gt;&lt;a href=&quot;#0x01-介绍&quot; class=&quot;headerlink&quot; title=&quot;0x01 介绍&quot;&gt;&lt;/a&gt;0x01 介绍&lt;/h2&gt;&lt;p&gt;Bruter是一个多线程暴力破解器，这款工具的诞生是为了证明选择强口令的重要性（反正我是信了~~），我们的目标是支持多种允许远程登录认证的服务。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;警告：请记住，这款工具只能用于合法的目的&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x02-使用方法&quot;&gt;&lt;a href=&quot;#0x02-使用方法&quot; class=&quot;headerlink&quot; title=&quot;0x02 使用方法&quot;&gt;&lt;/a&gt;0x02 使用方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;连接选项，输入目标和选择协议的地方&lt;ol&gt;
&lt;li&gt;目标：可以输入ipv4和host，不支持批量操作&lt;/li&gt;
&lt;li&gt;协议：不同的协议有不同的选项，更多协议内容查看协议相关文档&lt;/li&gt;
&lt;li&gt;端口：一般会有默认端口号，也可以手动修改&lt;/li&gt;
&lt;li&gt;SSL：是否使用SSL，选择时端口号也相应会改变&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代理选项&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用代理：选择是否使用代理&lt;/li&gt;
&lt;li&gt;类型：支持HTTP、socks4、socks5代理&lt;/li&gt;
&lt;li&gt;让代理解析host：选择本地解析还是让代理决定&lt;/li&gt;
&lt;li&gt;端口：代理端口&lt;/li&gt;
&lt;li&gt;&lt;p&gt;要求认证：查看代理是否需要验证&lt;/p&gt;
&lt;p&gt; 注意： http连接只支持基础认证；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;socks5只支持用户名/密码认证
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;账号和密码：输入账号和密码的地方&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;爆破用户名选项&lt;ol&gt;
&lt;li&gt;输入用户名或者用户名列表路径。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;密码模式选项&lt;ol&gt;
&lt;li&gt;联合模式：当你的密码或列表输入使用username:password形式时，会自动去提取“：”后的password&lt;br&gt; 注意：会忽视username的内容；可以在选项里选择分隔符&lt;/li&gt;
&lt;li&gt;字典模式：正常的模式，可以输入单个密码或者列表路径，不同之处在于它可以变量替换，类似（%username%）的输入可以将爆破用到的所有用户名添加到密码中来。&lt;br&gt; 注意：空密码就用空字符，而不是用空格；由于替换规则，你用不了“%username%”这个密码；使用时会先加载全部密码到内存，所以密码字典不要太大&lt;/li&gt;
&lt;li&gt;暴力模式：根据提供的字符进行遍历&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;字典选项，使用字典模式附带的选项&lt;ol&gt;
&lt;li&gt;小写，转化所有输入为小写&lt;/li&gt;
&lt;li&gt;大写，转化所有输入为大写&lt;/li&gt;
&lt;li&gt;大写首字母&lt;/li&gt;
&lt;li&gt;翻转&lt;/li&gt;
&lt;li&gt;重复两次，将输入的admin，变为adminadmin&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;杂项选项&lt;ol&gt;
&lt;li&gt;连接数：设置进程数，win限制最大为64&lt;/li&gt;
&lt;li&gt;最大重试数：同一个用户密码尝试次数&lt;/li&gt;
&lt;li&gt;超时：整个破解过程使用多长时间&lt;/li&gt;
&lt;li&gt;重试时间：同一个用户密码尝试间隔时间&lt;/li&gt;
&lt;li&gt;重试时间：不同的用户密码尝试间隔时间&lt;/li&gt;
&lt;li&gt;最大接受连接数：有两个值，-1表示自动检测；0表示直到服务断开&lt;/li&gt;
&lt;li&gt;当发现有成功结果时是否停止&lt;/li&gt;
&lt;li&gt;密码优先：这个选项会使程序优先以密码去遍历用户名&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;显示区&lt;ol&gt;
&lt;li&gt;结果&lt;/li&gt;
&lt;li&gt;正在测试情况&lt;/li&gt;
&lt;li&gt;返回信息&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;状态栏&lt;ol&gt;
&lt;li&gt;第一列：当前任务状态&lt;/li&gt;
&lt;li&gt;第二列：每秒爆破数&lt;/li&gt;
&lt;li&gt;第三列：总测试数&lt;/li&gt;
&lt;li&gt;第四列：总用时&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;菜单&lt;ol&gt;
&lt;li&gt;文件：保存和退出&lt;/li&gt;
&lt;li&gt;设置：可以加载默认设置、保存设置、加载设置&lt;/li&gt;
&lt;li&gt;日志：选择输出的日志级别&lt;/li&gt;
&lt;li&gt;帮助：不用说了&lt;h2 id=&quot;0x03-后记&quot;&gt;&lt;a href=&quot;#0x03-后记&quot; class=&quot;headerlink&quot; title=&quot;0x03 后记&quot;&gt;&lt;/a&gt;0x03 后记&lt;/h2&gt;话说，3389的爆破工具都有哪些？以前似乎听说过一些，但是现在好像都销声匿迹了，是因为MS这方面防护做的更好了，3389爆破测试工具难以绕过一些规则吗？&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原创文章，转载请注明： 转载自零の杂货铺&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;说到爆破神器，kali中的msf爆破插件、hydra、medusa都足够强大，这里推荐一款win环境
    
    </summary>
    
      <category term="安全工具" scheme="http://phantom0301.github.io/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="bruter" scheme="http://phantom0301.github.io/tags/bruter/"/>
    
      <category term="爆破" scheme="http://phantom0301.github.io/tags/%E7%88%86%E7%A0%B4/"/>
    
  </entry>
  
  <entry>
    <title>反蜜罐技术学习</title>
    <link href="http://phantom0301.github.io/2016/03/23/%E5%8F%8D%E8%9C%9C%E7%BD%90%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    <id>http://phantom0301.github.io/2016/03/23/反蜜罐技术学习/</id>
    <published>2016-03-23T04:08:28.000Z</published>
    <updated>2016-03-23T04:14:08.959Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x00-写在最先&quot;&gt;&lt;a href=&quot;#0x00-写在最先&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在最先&quot;&gt;&lt;/a&gt;0x00 写在最先&lt;/h2&gt;&lt;p&gt;之前都在卖盾了，这次讲讲卖矛的故事。&lt;/p&gt;
&lt;p&gt;翻译自别人的文章，Neal Krawetz，hackerfactor网站的创建者，主要从事反垃圾邮件、计算机取证和安全方面的研究。&lt;/p&gt;
&lt;p&gt;还是一样，有错直接留言 ：）&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160323113106.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;有意思的插图，图侵删&lt;/p&gt;
&lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;垃圾邮件发送者经常扫描一些网络中开放的代理中继，通过代理，他们可以隐藏自己的原始IP。然而，假如他们不走运的遇到了蜜罐服务，蜜罐会收集一些有价值的信息，而这些信息可以帮助我们判断垃圾邮件散播者的真实身份，揭去他们的面具。&lt;/p&gt;
&lt;p&gt;作为对蜜罐的回应，第一个商业化的反蜜罐技术已经出现，Send-Safe的蜜罐猎人们试图为垃圾邮件发送工具找到安全的代理。这种蜜罐检测系统和其他新兴的垃圾邮件工具，呈现出三个重要的特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;蜜罐正在影响发送者&lt;/li&gt;
&lt;li&gt;目前的蜜罐技术是可检测的&lt;/li&gt;
&lt;li&gt;大多数蜜罐识别系统很相似&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不只是垃圾邮件的发送者会掌握这一技术，其他的恶意组织也会从相似的技术中受益，所以我们需要去研究反蜜罐技术，来改善目前的蜜罐技术。&lt;/p&gt;
&lt;h2 id=&quot;0x02-基础蜜罐服务&quot;&gt;&lt;a href=&quot;#0x02-基础蜜罐服务&quot; class=&quot;headerlink&quot; title=&quot;0x02 基础蜜罐服务&quot;&gt;&lt;/a&gt;0x02 基础蜜罐服务&lt;/h2&gt;&lt;p&gt;蜜罐按照一个看似有效的系统来设计。前面也说了，它使用这个模拟系统的外壳来收集攻击者的信息和方法。&lt;/p&gt;
&lt;p&gt;为了让自己伪装的更到位，蜜罐提供多种多样看似脆弱的系统。尽管如此的多样，但是总的来说，可以具体分为以下四级：最低限度、有限制、仿照模拟、完全一样。复杂度自然从低到高。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最低限度的服务，只是提供一个开放的服务端口&lt;/li&gt;
&lt;li&gt;有限制的服务，提供一些基础的交互&lt;/li&gt;
&lt;li&gt;仿照模拟的服务，提供一些复杂的交互&lt;/li&gt;
&lt;li&gt;完全真实一样，自然是提供一个真实的服务完整的支持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一些最低限度的服务会返回基本的连接头，但通常不会有更多细节的内容。一个最典型的例子就是模拟SMTP服务的蜜罐BOF，对于攻击，它只会返回一个“&lt;em&gt;503 Service Unavailable&lt;/em&gt;”&lt;/p&gt;
&lt;p&gt;最低限度服务通过增加一些少量的交互，就成了有限制的服务。有限制的服务可以呈现出基础交互的功能，即时没有认证机制可用。BOF蜜罐模拟的telnet服务就是这样，它会提示输入账号和密码，但没有运行任何登录机制。Niels Provos和他的研究组有一个网页介绍他们的honeyd项目&lt;a href=&quot;http://www.citi.umich.edu/u/provos/honeyd/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;戳这里&lt;/a&gt;，这个项目提供一系列有限制服务的蜜罐脚本，包括SMTP和简单的WEB代理。&lt;/p&gt;
&lt;p&gt;仿照模拟的服务呈现出一个完整的工作过程，但不是真实的。它会记录下行为，但不执行外部的操作。模拟服务接收登录和登陆后的一系列请求，会返回那些通常已知的标准回复和错误信息。比如那些仿真完整SMTP和微软IIS网页服务的脚本程序。&lt;/p&gt;
&lt;p&gt;和以上提到的虚拟蜜罐相比，完全真实的蜜罐服务很少见。他们不仅只是回复请求，它们还可以和恶意程序充分互动，甚至接收被破坏。大多数的完全蜜罐也会限制一些连接，这样可以防止这些真实蜜罐被攻破后作为Dos攻击的一部分。&lt;/p&gt;
&lt;p&gt;尽管crackers或者black—hat在攻击时会使用多个代理，大多数的垃圾邮件工具只支持单一代理。如果蜜罐伪装成代理，那么垃圾邮件发送者的真实IP就会暴露给蜜罐。我们可以用这些信息进行取证。&lt;/p&gt;
&lt;h2 id=&quot;0x03-垃圾邮件发送者的反击&quot;&gt;&lt;a href=&quot;#0x03-垃圾邮件发送者的反击&quot; class=&quot;headerlink&quot; title=&quot;0x03 垃圾邮件发送者的反击&quot;&gt;&lt;/a&gt;0x03 垃圾邮件发送者的反击&lt;/h2&gt;&lt;p&gt;垃圾邮件发送者通常是被动的，当工具失效时，他们只能换其他工具。举个例子，最早的反垃圾邮件技术使用哈希散列表过滤的方法来将每一封邮件内容加到一个散列表中。重复的散列表示重复的内容，这就意味着，它是重复被邮寄出去的。为了应对散列系统，垃圾邮件技术研究者们创造了哈希克星，可以通过生成不同字符串来改变哈希值。同样，时至今天，批量邮件发送工具使用反贝叶斯编码的方法来对抗贝叶斯过滤器。&lt;/p&gt;
&lt;p&gt;Send-Safe套件是一款被广泛使用的商业邮件批量发送工具套件，它的很多功能在垃圾邮件发送者眼里都很实用。它的代理扫描器可以发现很多开放的代理服务来隐藏发送者的身份；它的其他工具包括邮件校验器和生成大量即时信息的工具。&lt;/p&gt;
&lt;p&gt;这一套件最新的工具——“蜜罐猎人”，帮助垃圾邮件发送者识别他们需要警惕的蜜罐。工具的开发人员在工具描述中暗示了收到蜜罐影响的群体。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Send-Safe Honeypot&lt;br&gt;Hunter is a tool designed for&lt;br&gt;checking lists of HTTPS and&lt;br&gt;SOCKS proxies for so called&lt;br&gt;“honey pots”. “Honey pots”&lt;br&gt;are fake proxies run by the&lt;br&gt;people who are attempting to&lt;br&gt;frame bulkers by using those&lt;br&gt;fake proxies for logging traffic&lt;br&gt;through them and then send&lt;br&gt;complaints to ones’ ISPs.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以充分认识到垃圾邮件发送者不是唯一的蜜罐“受害者”。&lt;/p&gt;
&lt;p&gt;有一点我们必须意识到的是，垃圾邮件发送工具并没有使用什么独特的技术。使用副本和加密副本来增加分布是一种古老的IRC Dos攻击。我们可以通过查询发送邮件服务中的“VRFY”查询邮件发送的地址，这是一种常用的信息收集手段。&lt;/p&gt;
&lt;p&gt;蜜罐猎人使用的是网络“地下社团”众所周知的蜜罐检测方法，这些方法有很多，当然其中的一些也很复杂。一些开源的蜜罐项目在安装过程中有默认的固定回复，而安装者往往不会去改变这些默认信息，这就提供给攻击者一个辨识蜜罐的独特方法。其他的方法还有，已知程序的错误处理、操作系统指纹识别、TCP序列分析和ARP地址。&lt;/p&gt;
&lt;h2 id=&quot;0x03-蜜罐猎人干了什么？&quot;&gt;&lt;a href=&quot;#0x03-蜜罐猎人干了什么？&quot; class=&quot;headerlink&quot; title=&quot;0x03 蜜罐猎人干了什么？&quot;&gt;&lt;/a&gt;0x03 蜜罐猎人干了什么？&lt;/h2&gt;&lt;p&gt;蜜罐猎人被设计成可以测试开放的代理连接，对于回应进行定位分级，它把代理的等级分割为安全（好的代理），失效（不能用的代理），陷阱（蜜罐）三种。蜜罐猎人目前测试端口1080的Socks4和Socks5代理以及其他的http代理。&lt;/p&gt;
&lt;p&gt;蜜罐猎人会执行一系列简单的测试。首先,它打开了一个错误的邮件服务器在　　本地系统(端口25)测试代理连接,然后连接到代理服务器的端口。连接后,蜜罐猎人尝试返回到自己错误的邮件服务器。这样的方法足够识别那些无效的代理和蜜罐。另外,如果远程服务器声称已经成功连接,但蜜罐猎人的虚假邮件服务器没有收到连接,那么这个代理可能是蜜罐。&lt;/p&gt;
&lt;h2 id=&quot;0x03-对于蜜罐的影响&quot;&gt;&lt;a href=&quot;#0x03-对于蜜罐的影响&quot; class=&quot;headerlink&quot; title=&quot;0x03 对于蜜罐的影响&quot;&gt;&lt;/a&gt;0x03 对于蜜罐的影响&lt;/h2&gt;&lt;p&gt;影响是显而易见的，如果恶意用户可以检测到蜜罐，那么他们就可以绕过蜜罐。&lt;/p&gt;
&lt;p&gt;对于低交互的蜜罐，影响可能仅仅是少收集一些攻击信息。&lt;/p&gt;
&lt;p&gt;但更重要的是，如果攻击者可以检测出蜜罐，他们既可以针对蜜罐进行攻击。三个最基本的攻击方法是：利用、投毒和学习研究。研究者通常会把蜜罐放在临近关键网络的一个孤立的局域网中。通过利用的方式，可以让蜜罐成为内部攻击的跳台。当然，也可以利用蜜罐作为跳板攻击整个互联网。&lt;/p&gt;
&lt;p&gt;取代利用的手段还有投毒，通过将大量无用信息投掷给蜜罐，可以利用噪声掩盖住蜜罐中有价值的信息，使得其他恶意攻击者不被发现。&lt;/p&gt;
&lt;p&gt;第三种方式就是去学习蜜罐，通过收集蜜罐的信息，可以提供给攻击者一个观察蜜罐使用者的视角，包括收集蜜罐使用者的个人信息、作息习惯和技能水平。甚至于可以收集蜜罐使用组织的情况，比如一个使用ORACLE蜜罐的公司很有可能运行着真正的oracle数据服务，或者他就是该服务的提供商。&lt;/p&gt;
&lt;h2 id=&quot;0x04-后记&quot;&gt;&lt;a href=&quot;#0x04-后记&quot; class=&quot;headerlink&quot; title=&quot;0x04 后记&quot;&gt;&lt;/a&gt;0x04 后记&lt;/h2&gt;&lt;p&gt;文章的后半段讲述了如何对抗反蜜罐技术，这个不是我这次翻译的重点，就不在这里贴出来了，有兴趣的可以阅读原文。&lt;/p&gt;
&lt;p&gt;最后，作者总结道，由于反蜜罐技术的出现，很多蜜罐服务提供商都面临一些困境，总的来就是，蜜罐技术侦查的蜜月期已经结束，接下来的很长一段时间都将是蜜罐技术与反蜜罐技术互相斗法的阶段，无论你是旁观者，还是参与者，这样的对决一定有许多值得我们学习的地方。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-写在最先&quot;&gt;&lt;a href=&quot;#0x00-写在最先&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在最先&quot;&gt;&lt;/a&gt;0x00 写在最先&lt;/h2&gt;&lt;p&gt;之前都在卖盾了，这次讲讲卖矛的故事。&lt;/p&gt;
&lt;p&gt;翻译自别人的文章，Neal Kr
    
    </summary>
    
      <category term="蜜罐" scheme="http://phantom0301.github.io/categories/%E8%9C%9C%E7%BD%90/"/>
    
    
      <category term="蜜罐" scheme="http://phantom0301.github.io/tags/%E8%9C%9C%E7%BD%90/"/>
    
  </entry>
  
  <entry>
    <title>MHN学习笔记（二）Dionaea蜜罐架构</title>
    <link href="http://phantom0301.github.io/2016/03/17/MHN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Dionaea%E8%9C%9C%E7%BD%90%E6%9E%B6%E6%9E%84/"/>
    <id>http://phantom0301.github.io/2016/03/17/MHN学习笔记（二）Dionaea蜜罐架构/</id>
    <published>2016-03-17T10:51:04.000Z</published>
    <updated>2016-03-22T06:32:31.076Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;上次记录了学习hpfeeds协议的一些收获，这次将介绍开源项目中的一款模拟功能丰富的蜜罐——dionaea。&lt;/p&gt;
&lt;p&gt;百度、google、github一下dionaea，就能看到很多关于这个蜜罐的简介、使用情况以及对蜜罐捕获数据的分析。&lt;/p&gt;
&lt;p&gt;其实dionaea项目现在可以分成两种，一种是原生的dioanea蜜罐，另一种是经过MHN改造后的dionaea，两者的服务模拟、捕获数据构成等略有不同。不过，这两种dionaea蜜罐我都尝试搭建并成功运行。所以，这次我打算从代码构成的角度讲讲dionaea蜜罐。&lt;/p&gt;
&lt;p&gt;按照你能成功的方式安装好dionaea蜜罐后，dionaea文件夹下会有如下的几个文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dioanea
|-bin
|-etc
|-include
|-lib
|-share
|-var
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;bin：运行的主要程序的可执行文件&lt;/li&gt;
&lt;li&gt;etc：dionaea的配置文件&lt;/li&gt;
&lt;li&gt;include：各种系统的环境需求&lt;/li&gt;
&lt;li&gt;lib：库文件以及服务模拟文件存储文件夹&lt;/li&gt;
&lt;li&gt;var：蜜罐系统日志以及捕获数据的存储文件夹&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里，我会详细介绍配置文件和捕获数据文件&lt;/p&gt;
&lt;h2 id=&quot;0x02-配置文件&quot;&gt;&lt;a href=&quot;#0x02-配置文件&quot; class=&quot;headerlink&quot; title=&quot;0x02 配置文件&quot;&gt;&lt;/a&gt;0x02 配置文件&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;etc
|-dionaea
    |-dionaea.conf
    |-dionaea.conf.dist
    |-dionaea.conf.org
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;作为蜜罐的配置文件，这里对于蜜罐运行时加载的协议、文件存储的位置、监听的端口等做了详细的描述。&lt;/p&gt;
&lt;p&gt;第一个参数是logging，负责存储蜜罐运行过程中的默认日志和出错日志的路径和日志等级设定&lt;/p&gt;
&lt;p&gt;第二个参数是processors，负责加载几个对于捕获数据进行过滤的程序，包括二进制流、会话等&lt;/p&gt;
&lt;p&gt;第三个参数是download，负责恶意程序的下载路径&lt;/p&gt;
&lt;p&gt;第四个参数是bistreams，负责二进制流下载路径&lt;/p&gt;
&lt;p&gt;第五个参数submit，负责第三方数据提交&lt;/p&gt;
&lt;p&gt;第六个参数是listen，负责蜜罐监听ip的设置，有三种模式。getifaddrs模式监听所有ip，包括自己的127.0.0.1。manual模式允许用户设置不进行监听的ip。nl模式加载一个列表监听。&lt;/p&gt;
&lt;p&gt;第七个参数是modules，加载用到的模块，lib中服务模拟的python程序就会在这里加载，捕获数据入库也在这里进行设置&lt;/p&gt;
&lt;p&gt;从配置文件中，可以看出dionaea的许多功能都处于开发阶段，还有一部分功能被注释掉了，喜欢探索的高级玩家可以解开注释的封印，去试试dionaea的洪荒之力~~ 中二ing~~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;上次记录了学习hpfeeds协议的一些收获，这次将介绍开源项目中的一款模拟功能丰富的蜜罐——dion
    
    </summary>
    
      <category term="蜜罐" scheme="http://phantom0301.github.io/categories/%E8%9C%9C%E7%BD%90/"/>
    
    
      <category term="蜜罐" scheme="http://phantom0301.github.io/tags/%E8%9C%9C%E7%BD%90/"/>
    
  </entry>
  
  <entry>
    <title>nmap7完全指南</title>
    <link href="http://phantom0301.github.io/2016/03/11/nmap7%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://phantom0301.github.io/2016/03/11/nmap7完全指南/</id>
    <published>2016-03-11T02:50:07.000Z</published>
    <updated>2016-03-11T02:52:36.949Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x00-基本介绍&quot;&gt;&lt;a href=&quot;#0x00-基本介绍&quot; class=&quot;headerlink&quot; title=&quot;0x00 基本介绍&quot;&gt;&lt;/a&gt;0x00 基本介绍&lt;/h2&gt;&lt;p&gt;整合了官网和网上的一些资料，本来是有配图的，但是一想到可能会暴露一些敏感信息，就不摆在这了，不足之处，欢迎交流。&lt;/p&gt;
&lt;p&gt;Nmap现在最新的版本是Nmap 7。主要是增加了IPV6和ssl方面的支持。&lt;/p&gt;
&lt;p&gt;Nmap，全称Network Mapper，开源网络探测与审计框架。使用构造异常IP包的方式来探测主机服务。&lt;/p&gt;
&lt;p&gt;完整的Namp套件包括界面图形化的Zenmap，数据传输、重定向与调试工具Ncat，扫描结果比较器Ndiff以及数据包生成与响应工具Nping。&lt;/p&gt;
&lt;p&gt;最常规的Nmap组成指令为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nmap [扫描类型] [选项] [目标]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;0x02-参数-【目标】&quot;&gt;&lt;a href=&quot;#0x02-参数-【目标】&quot; class=&quot;headerlink&quot; title=&quot;0x02 参数-【目标】&quot;&gt;&lt;/a&gt;0x02 参数-【目标】&lt;/h2&gt;&lt;p&gt;目标参数可以输入域名、IP、网络等&lt;br&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;www.baidu.com
microsoft.com/24
192.168.0.1
10.0.0-255.1-254
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外还有如下参数可选：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;-iL &amp;lt;文件名&amp;gt;，从表单中读取扫描目标。&lt;/li&gt;
&lt;li&gt;-iR &amp;lt;主机数量&amp;gt;，选取随机扫描目标，私有段ip、多播ip、未分配使用的ip会被自动跳过，&lt;0&gt;可以指定一个无休止的扫描，如果在一个雨天的午后，你十分无聊的时候，可以运行。&lt;br&gt;&lt;code&gt;nmap -Pn -sS -p 80 -iR 0 --open&lt;/code&gt;&lt;/0&gt;&lt;/li&gt;
&lt;li&gt;–exclude &amp;lt;主机1&amp;gt;，&amp;lt;主机2&amp;gt;，跳过部分目标。&lt;/li&gt;
&lt;li&gt;–exclude &amp;lt;文件名&amp;gt;，从表单中读取跳过目标。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;0x03-参数-【主机发现】&quot;&gt;&lt;a href=&quot;#0x03-参数-【主机发现】&quot; class=&quot;headerlink&quot; title=&quot;0x03 参数-【主机发现】&quot;&gt;&lt;/a&gt;0x03 参数-【主机发现】&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;-sL，列表扫描，通过访问DNS的方式得到目标主机的ip。&lt;/li&gt;
&lt;li&gt;-sn，不进行端口扫描，ping scan。&lt;/li&gt;
&lt;li&gt;-Pn，不进行ping，强行扫描。&lt;/li&gt;
&lt;li&gt;-PS &amp;lt;端口列表&amp;gt;，TCP SYN Ping扫描端口&lt;/li&gt;
&lt;li&gt;-PA &amp;lt;端口列表&amp;gt;，TCP ACK Ping扫描端口&lt;/li&gt;
&lt;li&gt;-PU &amp;lt;端口列表&amp;gt;，UDP Ping&lt;/li&gt;
&lt;li&gt;-PY &amp;lt;端口列表&amp;gt;，SCTP INIT Ping&lt;/li&gt;
&lt;li&gt;-PE;-PP;-PM，ICMP Ping Types&lt;/li&gt;
&lt;li&gt;-PO &amp;lt;协议号&amp;gt;，IP Protocol Ping&lt;/li&gt;
&lt;li&gt;-PR，ARP Ping&lt;/li&gt;
&lt;li&gt;–disable-arp-pin 不使用ARP ping&lt;/li&gt;
&lt;li&gt;–traceroute 探测到达主机的Trace路径&lt;/li&gt;
&lt;li&gt;-n 不使用DNS结果&lt;/li&gt;
&lt;li&gt;-R 始终使用DNS结果&lt;/li&gt;
&lt;li&gt;–system-dns 使用系统的DNS解析，不请求域名服务器&lt;/li&gt;
&lt;li&gt;–dns-servers &amp;lt;服务1&amp;gt;,&amp;lt;服务2&amp;gt; 查询的DNS服务器队列&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_IP_protocol_numbers&quot; title=&quot;protocol_list&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://en.wikipedia.org/wiki/List_of_IP_protocol_numbers&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x04-参数-【端口扫描】&quot;&gt;&lt;a href=&quot;#0x04-参数-【端口扫描】&quot; class=&quot;headerlink&quot; title=&quot;0x04 参数-【端口扫描】&quot;&gt;&lt;/a&gt;0x04 参数-【端口扫描】&lt;/h2&gt;&lt;p&gt;使用六种状态描述端口状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;open，端口积极接收数据&lt;/li&gt;
&lt;li&gt;closed，无应用程序监听此端口&lt;/li&gt;
&lt;li&gt;filtered，端口难以抵达，无法准确判断&lt;/li&gt;
&lt;li&gt;unfiltered，端口可以抵达，无法准确判断&lt;/li&gt;
&lt;li&gt;open|filtered，两种状态不确定&lt;/li&gt;
&lt;li&gt;closed|filtered，两种状态不确定&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;-sS，TCP SYN scan，默认状态下的扫描模式，半开扫描，扫描快速，动静小。&lt;/li&gt;
&lt;li&gt;-sT，TCP connect scan，当没有原始数据包特权时使用，容易被发现。&lt;/li&gt;
&lt;li&gt;-sU，UDP scans，扫描UDP服务端口，DNS/SNMP/DHCP&lt;/li&gt;
&lt;li&gt;-sY，SCTP INIT scan，SCTP是一种较新的用来替代TCP和UDP的协议，类似于1&lt;/li&gt;
&lt;li&gt;-sN;-sF;-sX，TCP NULL, FIN, and Xmas scans，利用RFC 793的一些漏洞来判断端口状态。改变一些特殊标志的比特值。更加隐蔽，可以逃过一些防火墙，但是系统协议必须严格遵守RFC 793。&lt;/li&gt;
&lt;li&gt;-sA，TCP ACK scan，不用来判断端口是否打开，用来探测防火墙过滤规则&lt;/li&gt;
&lt;li&gt;-sW，TCP Window scan，类似ACK scan，增加不同系统的细节，但是结果不一定可信，甚至有可能正好相反。&lt;/li&gt;
&lt;li&gt;-sM，TCP Maimon scan，Uriel Maimon发现的一些BSD的系统在端口打开时会简单的终止包&lt;/li&gt;
&lt;li&gt;–scanflags，Custom TCP scan，自己通过TCP标志的设置构造自己的扫描，可以使用：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;*URG，紧急指针有效*

*ACK，确认序号有效*

*PSH，接收方应该尽快将这个报文段交给应用层*

*RST，重建连接*

*SYN，同步序号用来发起一个连接*

*FIN，发送端完成发送任务*
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;-sZ，SCTP COOKIE ECHO scan&lt;/li&gt;
&lt;li&gt;-sI &lt;zombie host=&quot;&quot;&gt;:&lt;probeport&gt;，idle scan，实现真正的盲扫，不会从你的真实IP发送包。使用边信道攻击实现僵尸机攻击。隐蔽性很好。&lt;/probeport&gt;&lt;/zombie&gt;&lt;/li&gt;
&lt;li&gt;-sO，IP protocol scan，ip协议扫描。&lt;/li&gt;
&lt;li&gt;-b，&amp;lt;主机&amp;gt;，FTP bounce scan，使用FTP代理扫描。因为使用FTP更容易绕过防火墙。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;SCTP（Stream Control Transmission Protocol，流控制传输协议）&lt;/p&gt;
&lt;p&gt;BSD (Berkeley Software Distribution，伯克利软件套件)是Unix的衍生系统&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0x05-参数-【端口号】&quot;&gt;&lt;a href=&quot;#0x05-参数-【端口号】&quot; class=&quot;headerlink&quot; title=&quot;0x05 参数-【端口号】&quot;&gt;&lt;/a&gt;0x05 参数-【端口号】&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;-p &amp;lt;端口范围&amp;gt;&lt;/li&gt;
&lt;li&gt;–exclude-ports &amp;lt;端口范围&amp;gt;&lt;/li&gt;
&lt;li&gt;-F，快速扫描常用端口，比默认的端口更少&lt;/li&gt;
&lt;li&gt;-r，按顺序扫描，默认情况下Nmap是随机扫描所指定的端口号的&lt;/li&gt;
&lt;li&gt;–port-ratio &amp;lt;比例&amp;gt;0-1之间，大于给的比例扫描servuces文件中的端口。&lt;/li&gt;
&lt;li&gt;–top-ports &amp;lt;数量&amp;gt;扫描指定数量的熟知端口&lt;h2 id=&quot;0x06-参数-【服务和版本检测】&quot;&gt;&lt;a href=&quot;#0x06-参数-【服务和版本检测】&quot; class=&quot;headerlink&quot; title=&quot;0x06 参数-【服务和版本检测】&quot;&gt;&lt;/a&gt;0x06 参数-【服务和版本检测】&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;-sV，服务版本检测&lt;/li&gt;
&lt;li&gt;–allports，版本检测不跳过任何端口，默认情况下会跳过TCP端口9100，因为一些打印机会打印传送到该端口的任何信息。&lt;/li&gt;
&lt;li&gt;–version-intensity &amp;lt;强度&amp;gt; 0-9，修改版本扫描检测强度。&lt;/li&gt;
&lt;li&gt;–version-light，强度2&lt;/li&gt;
&lt;li&gt;–version-all，强度9&lt;/li&gt;
&lt;li&gt;–version-trace，显示Nmap的版本识别过程&lt;h2 id=&quot;0x07-参数-【系统检测】&quot;&gt;&lt;a href=&quot;#0x07-参数-【系统检测】&quot; class=&quot;headerlink&quot; title=&quot;0x07 参数-【系统检测】&quot;&gt;&lt;/a&gt;0x07 参数-【系统检测】&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;-O 开启系统检测&lt;/li&gt;
&lt;li&gt;–osscan-limit，只检查一定条件的系统，有一个检测到的端口&lt;/li&gt;
&lt;li&gt;–osscan-guess，百分比显示可能的系统选项&lt;/li&gt;
&lt;li&gt;–max-os-tries，在未能匹配系统时，Nmap会重复检测5次，这个次数可以设置&lt;h2 id=&quot;0x08-参数-【NSE】&quot;&gt;&lt;a href=&quot;#0x08-参数-【NSE】&quot; class=&quot;headerlink&quot; title=&quot;0x08 参数-【NSE】&quot;&gt;&lt;/a&gt;0x08 参数-【NSE】&lt;/h2&gt;NSE,Nmap脚本引擎，Nmap里最强大最灵活的特性，允许用户编写LUA语言脚本实现各种测试任务。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前的脚本类别目录有：&lt;/p&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;auth，认证-目标系统身份验证
broadcast，广播-广播发现目标
brute，爆破-爆破身份验证
default，缺省-默认调用
discovery，发现-积极发现更多公共注册服务
dos，拒绝服务-DOS攻击
exploit，利用-利用一些漏洞
external，外部-会将数据发送给第三方
fuzzer，模糊测试-随机字段发送包，可以发现一些未被发现的漏洞
intrusive，侵入-风险过高的脚本
malware，恶意程序-测试目标是否被恶意程序感染
safe，安全-风险很低的脚本
version，版本-扩展版本检测功能，不能显式调用
vuln，漏洞-检测特定的已知漏洞
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;-sC，缺省脚本执行&lt;/li&gt;
&lt;li&gt;&lt;p&gt;–script &amp;lt;文件名&amp;gt;|&amp;lt;类别&amp;gt;|&amp;lt;目录&amp;gt;|&amp;lt;表达式&amp;gt;…，可以使用+来强制脚本运行，也可以用 &lt;em&gt;all&lt;/em&gt; 来遍历所有脚本，这两个选项要慎重使用&lt;/p&gt;
&lt;p&gt; nmap –script “http-*” 加载所有http前缀的脚本&lt;/p&gt;
&lt;p&gt; nmap –script “not intrusive”&lt;/p&gt;
&lt;p&gt; nmap –script “default or safe”&lt;/p&gt;
&lt;p&gt; nmap –script “default and safe”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;–script-args &amp;lt;脚本&amp;gt;=&amp;lt;参数&amp;gt;,给脚本提供参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;–script-args-file &amp;lt;文件名&amp;gt;，从文件提供参数&lt;/li&gt;
&lt;li&gt;–script-help &amp;lt;脚本名&amp;gt;，帮助&lt;/li&gt;
&lt;li&gt;–script-trace 打印脚本执行过程&lt;/li&gt;
&lt;li&gt;&lt;p&gt;–script-updatedb，升级脚本库&lt;/p&gt;
&lt;h2 id=&quot;0x09-参数-【时间与性能】&quot;&gt;&lt;a href=&quot;#0x09-参数-【时间与性能】&quot; class=&quot;headerlink&quot; title=&quot;0x09 参数-【时间与性能】&quot;&gt;&lt;/a&gt;0x09 参数-【时间与性能】&lt;/h2&gt;&lt;p&gt;时间单位：ms s m h&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;–min(max)-hostgroup &amp;lt;主机数&amp;gt;，调整并行扫描组主机数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;–min(max)-parallelism &amp;lt;探针数&amp;gt;，调整并行探针数。&lt;/li&gt;
&lt;li&gt;–min(max，initial)-rtt-timeout &amp;lt;时间&amp;gt;，调整探针超时时间&lt;/li&gt;
&lt;li&gt;–max-retries &amp;lt;数量&amp;gt;，指定端口扫描探针最大值，最大重试次数&lt;/li&gt;
&lt;li&gt;–host-timeout &amp;lt;时间&amp;gt;，放弃超时主机目标&lt;/li&gt;
&lt;li&gt;–scan-delay &amp;lt;时间&amp;gt;，调整探针之间的延迟时间&lt;/li&gt;
&lt;li&gt;–min(max)-rate &amp;lt;数字&amp;gt;，调整扫描速率，每秒发送的包数&lt;/li&gt;
&lt;li&gt;-T &lt;0-5&gt;时间模板，越大越快&lt;h2 id=&quot;0x10-参数-【防火墙IDS逃逸】&quot;&gt;&lt;a href=&quot;#0x10-参数-【防火墙IDS逃逸】&quot; class=&quot;headerlink&quot; title=&quot;0x10 参数-【防火墙IDS逃逸】&quot;&gt;&lt;/a&gt;0x10 参数-【防火墙IDS逃逸】&lt;/h2&gt;&lt;/0-5&gt;&lt;/li&gt;
&lt;li&gt;-f，分隔包碎片&lt;/li&gt;
&lt;li&gt;-mtu，指定偏移量分隔包碎片&lt;/li&gt;
&lt;li&gt;-D &amp;lt;诱饵&amp;gt;&amp;lt;,ME&amp;gt;，使用诱饵掩盖IP&lt;/li&gt;
&lt;li&gt;-S &amp;lt; IP &amp;gt;，伪造源地址IP&lt;/li&gt;
&lt;li&gt;-e &amp;lt; interface &amp;gt;，使用特定接口发送接收包&lt;/li&gt;
&lt;li&gt;–source-port &amp;lt; portnum &amp;gt;，伪造源端口号&lt;/li&gt;
&lt;li&gt;–data &amp;lt; hex string &amp;gt;，添加自定义二进制数据到发送包&lt;/li&gt;
&lt;li&gt;–data &amp;lt; string &amp;gt;，添加自定义字符串到发送包&lt;/li&gt;
&lt;li&gt;–data-length &amp;lt; num &amp;gt;，添加随机数据到发送包&lt;/li&gt;
&lt;li&gt;–ip-option &amp;lt; hex string &amp;gt;，用指定的IP选项发送数据包&lt;/li&gt;
&lt;li&gt;–ttl &amp;lt; value &amp;gt;，设置存活时间&lt;/li&gt;
&lt;li&gt;–randomize-hosts，随机主机目标顺序&lt;/li&gt;
&lt;li&gt;–spoof-mac &amp;lt; MAC,prefix,… &amp;gt;伪造MAC地址&lt;/li&gt;
&lt;li&gt;–proxies &amp;lt; URL &amp;gt;，通过代理链中继TCP连接&lt;/li&gt;
&lt;li&gt;–badsum，发送虚假校验和&lt;/li&gt;
&lt;li&gt;–adler32，使用另一种校验和代替CRC32C&lt;h2 id=&quot;0x11-参数-【输出】&quot;&gt;&lt;a href=&quot;#0x11-参数-【输出】&quot; class=&quot;headerlink&quot; title=&quot;0x11 参数-【输出】&quot;&gt;&lt;/a&gt;0x11 参数-【输出】&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;-oN &amp;lt; file &amp;gt;，正常输出&lt;/li&gt;
&lt;li&gt;-oX，XML输出&lt;/li&gt;
&lt;li&gt;-oS，脚本输出&lt;/li&gt;
&lt;li&gt;-oG，已弃用&lt;/li&gt;
&lt;li&gt;-oA，全格式&lt;/li&gt;
&lt;li&gt;-v &amp;lt; level &amp;gt;，增加Nmap输出普通信息水平&lt;/li&gt;
&lt;li&gt;-d &amp;lt; level &amp;gt;，增加调试信息输出水平&lt;/li&gt;
&lt;li&gt;–reason，给出原因&lt;/li&gt;
&lt;li&gt;–stats-every &amp;lt; time &amp;gt;，每过固定时间打印一次数据&lt;/li&gt;
&lt;li&gt;–packet-trace，数据包路径&lt;/li&gt;
&lt;li&gt;–open，显示打开的端口&lt;/li&gt;
&lt;li&gt;–iflist，列表接口和路径&lt;/li&gt;
&lt;li&gt;–append-output，结果添加到输出&lt;/li&gt;
&lt;li&gt;–resume &lt;filename&gt;，恢复终止的扫描&lt;h2 id=&quot;0x12-参数-【混合选项】&quot;&gt;&lt;a href=&quot;#0x12-参数-【混合选项】&quot; class=&quot;headerlink&quot; title=&quot;0x12 参数-【混合选项】&quot;&gt;&lt;/a&gt;0x12 参数-【混合选项】&lt;/h2&gt;&lt;/filename&gt;&lt;/li&gt;
&lt;li&gt;-6，开启IPv6扫描&lt;/li&gt;
&lt;li&gt;-A，积极扫描策略（-O，-sV，-sC，–traceroute）&lt;/li&gt;
&lt;li&gt;–datadir &amp;lt; directoryname &amp;gt; 指定Nmap数据文件&lt;/li&gt;
&lt;li&gt;–servicedb &amp;lt; services file &amp;gt;，指定Nmap服务库&lt;/li&gt;
&lt;li&gt;–versiondb &amp;lt; service probes file &amp;gt;，指定版本库&lt;/li&gt;
&lt;li&gt;–release-memory，推出前释放内存&lt;/li&gt;
&lt;li&gt;-V，显示版本号&lt;br&gt;参考：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;http://nmap.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://nmap.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.91ri.org/4105.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实战高级用法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.91ri.org/3870.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;绕过防火墙与脚本使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原创文章，转载请注明： 转载自零の杂货铺&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-基本介绍&quot;&gt;&lt;a href=&quot;#0x00-基本介绍&quot; class=&quot;headerlink&quot; title=&quot;0x00 基本介绍&quot;&gt;&lt;/a&gt;0x00 基本介绍&lt;/h2&gt;&lt;p&gt;整合了官网和网上的一些资料，本来是有配图的，但是一想到可能会暴露一些敏感信息，就不摆
    
    </summary>
    
      <category term="安全工具" scheme="http://phantom0301.github.io/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="namp" scheme="http://phantom0301.github.io/tags/namp/"/>
    
  </entry>
  
  <entry>
    <title>博客搬家</title>
    <link href="http://phantom0301.github.io/2016/03/02/%E5%8D%9A%E5%AE%A2%E6%90%AC%E5%AE%B6/"/>
    <id>http://phantom0301.github.io/2016/03/02/博客搬家/</id>
    <published>2016-03-02T02:46:27.000Z</published>
    <updated>2016-03-11T02:47:30.515Z</updated>
    
    <content type="html">&lt;p&gt;gitcafe博客&lt;strong&gt;搬家&lt;/strong&gt;了~~&lt;/p&gt;
&lt;p&gt;之前把博客部署在gitcafe和github上，不过最近得到了通知，gitcafe和coding合作了，原来在gitcafe上的服务到今年的5月份就停了。&lt;/p&gt;
&lt;p&gt;所以只能把原来部署在cafe上的博客移交到coding了&lt;/p&gt;
&lt;p&gt;现在有两个稳定可访问的域名：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://phantom0301.github.io&quot; title=&quot;phantom0301.github.io&quot;&gt;phantom0301.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://phantom0301.coding.io&quot; title=&quot;phantom0301.coding.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;phantom0301.coding.io&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;gitcafe博客&lt;strong&gt;搬家&lt;/strong&gt;了~~&lt;/p&gt;
&lt;p&gt;之前把博客部署在gitcafe和github上，不过最近得到了通知，gitcafe和coding合作了，原来在gitcafe上的服务到今年的5月份就停了。&lt;/p&gt;
&lt;p&gt;所以只能把原来部署在caf
    
    </summary>
    
      <category term="感悟" scheme="http://phantom0301.github.io/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="感悟" scheme="http://phantom0301.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>HEXO+github搭建博客总结</title>
    <link href="http://phantom0301.github.io/2016/02/20/HEXO+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93/"/>
    <id>http://phantom0301.github.io/2016/02/20/HEXO+github搭建博客总结/</id>
    <published>2016-02-20T08:21:27.000Z</published>
    <updated>2016-02-21T04:45:32.306Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;用hexo+github搭建个人博客，有许多坑值得去填，这里就把从各个博客学到的填坑方式在这里说一下。&lt;/p&gt;
&lt;p&gt;另外，有许多资料都是针对hexo2.x版本的，我现在的版本是3.1.1。查找资料的时候一定要注意。这里只是列出问题查找的方向，根据这个方向更便于在网上找到解决的方法。&lt;/p&gt;
&lt;h2 id=&quot;0x01-准备&quot;&gt;&lt;a href=&quot;#0x01-准备&quot; class=&quot;headerlink&quot; title=&quot;0x01 准备&quot;&gt;&lt;/a&gt;0x01 准备&lt;/h2&gt;&lt;p&gt;1.github账号：安装git，申请github账号，设置好ssh。再新建一个项目，然后在项目的setting中设置为个人页面。&lt;/p&gt;
&lt;p&gt;2.安装node.js，使用npm命令安装hexo，后面还会大量的用到npm来安装。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g hexo
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;0x02-搭建基本框架&quot;&gt;&lt;a href=&quot;#0x02-搭建基本框架&quot; class=&quot;headerlink&quot; title=&quot;0x02 搭建基本框架&quot;&gt;&lt;/a&gt;0x02 搭建基本框架&lt;/h2&gt;&lt;p&gt;在本地电脑新建一个文件夹a，在a里使用git bash初始化一个hexo项目。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo init
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时会生成许多文件夹，在输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装一些必要包。&lt;/p&gt;
&lt;p&gt;执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo generate
hexo server -p 8080
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时候应该可以在本地用&lt;a href=&quot;http://localhost:8080打开原始框架页面了&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:8080打开原始框架页面了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;-p后面的端口要根据自己的情况来写，网上大多使用默认的4000，可是我的4000端口已经用了，这样就会导致网页打不开。&lt;/p&gt;
&lt;p&gt;在本地打开成功后，就可以开始上传到github上了。&lt;/p&gt;
&lt;p&gt;打开a里的_config.yml,推荐使用sublime，如果使用其他工具，请注意要保存时格式应为&lt;strong&gt;utf-8&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找到deploy一栏，修改如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;deploy:
  type: git
  repository: https://github.com/你的github名/你的github名.github.io.git
  branch: master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意，这里作为个人页面的github项目一定要和用户名相同。&lt;/p&gt;
&lt;p&gt;然后在git bash中输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo deploy
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里注意有两种deploy的方式，&lt;a href=&quot;https://的方式会要求你输入github的账号密码；ssh的方式只要事先设置好密钥就不再需要多余的操作了。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://的方式会要求你输入github的账号密码；ssh的方式只要事先设置好密钥就不再需要多余的操作了。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这时，就可以用&lt;strong&gt;你的github名.github.io&lt;/strong&gt;来访问&lt;/p&gt;
&lt;h2 id=&quot;0x03-打磨博客&quot;&gt;&lt;a href=&quot;#0x03-打磨博客&quot; class=&quot;headerlink&quot; title=&quot;0x03 打磨博客&quot;&gt;&lt;/a&gt;0x03 打磨博客&lt;/h2&gt;&lt;p&gt;1.发表博文&lt;br&gt;使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo new “文章名”
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;新建博文，这时会在a/source/_post下生成相应的.md文件，打开编辑。&lt;br&gt;在——下面就可以使用markdown语法写博文。&lt;/p&gt;
&lt;p&gt;写好后，保存，执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo generate
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就可以在a/public中相应的位置生成博文。&lt;/p&gt;
&lt;p&gt;那么以后的程式化操作就是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo new “  ” 写博文
hexo clean 清除public
hexo generate 编译
hexo server -p 8080 本地测试
hexo deploy 部署到远程服务器
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.装饰博客&lt;br&gt;基本框架布置好，装饰的事大家就各显神通了。&lt;/p&gt;
&lt;p&gt;通常会在以下几个点进行修改&lt;/p&gt;
&lt;p&gt;a/_config.yml&lt;/p&gt;
&lt;p&gt;这里修改博客主页的名字，源信息，子页面url格式等&lt;/p&gt;
&lt;p&gt;最重要的是主题的选用，插件的使用都在这里编辑完成。&lt;br&gt;如果你要使用rss、sitemap、更改deploy的对象就需要在这里修改&lt;/p&gt;
&lt;p&gt;a/themes/&lt;br&gt;存放你找来的各种主题b、c、d……&lt;/p&gt;
&lt;p&gt;a/themes/b/_config.yml&lt;br&gt;负责单个主题的框架修改，&lt;br&gt;包括网页的logo图片选择、框架中主菜单显示的文本及连接&lt;/p&gt;
&lt;p&gt;a/public&lt;br&gt;静态生成的网页，也就是会上传到github上的文件。&lt;/p&gt;
&lt;p&gt;网上有很多教程，而且如果前面都部署成功了，后面就可以自己慢慢geek了&lt;/p&gt;
&lt;h2 id=&quot;0x04-其他的一些坑&quot;&gt;&lt;a href=&quot;#0x04-其他的一些坑&quot; class=&quot;headerlink&quot; title=&quot;0x04 其他的一些坑&quot;&gt;&lt;/a&gt;0x04 其他的一些坑&lt;/h2&gt;&lt;p&gt;github的博客可以被google站长收录，但是baidu被禁止爬去github，所以，如果想让baidu也能搜得到你，就部署在gitcafe上。&lt;/p&gt;
&lt;p&gt;如果hexo generate报错，多半是两个地方的_config.yml更改的有问题，所以一是要备份yml文件或者从git上拉取之前部署成功的文件，二是要边改边generate在本地查看，一点点琢磨不同位置的属性。&lt;/p&gt;
&lt;p&gt;a/_config.yml中的url设置如果没有购买域名的话，看似没有作用，但会影响生成的sitemap中的路径，所以在多个平台（github、gitcafe）部署的时候，不仅要修改deploy，还要根据需要修改url。&lt;/p&gt;
&lt;p&gt;否则，即便sitemap能被百度站长工具访问到，也会提示说 &lt;strong&gt;主域验证错误&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为是事后总结，暂时想到的就这么多，其他还有什么安装过程中的问题可以直接博客留言，&lt;strong&gt;见即回 &lt;/strong&gt;  ：）&lt;/p&gt;
&lt;p&gt;原创文章，转载请注明： 转载自零の杂货铺&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;用hexo+github搭建个人博客，有许多坑值得去填，这里就把从各个博客学到的填坑方式在这里说一下
    
    </summary>
    
      <category term="HEXO" scheme="http://phantom0301.github.io/categories/HEXO/"/>
    
    
      <category term="HEXO" scheme="http://phantom0301.github.io/tags/HEXO/"/>
    
      <category term="个人博客" scheme="http://phantom0301.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>MHN开源蜜罐项目学习笔记（一）HPFEEDS协议</title>
    <link href="http://phantom0301.github.io/2016/02/19/MHN%E5%BC%80%E6%BA%90%E8%9C%9C%E7%BD%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89HPFEEDS%E5%8D%8F%E8%AE%AE/"/>
    <id>http://phantom0301.github.io/2016/02/19/MHN开源蜜罐项目学习笔记（一）HPFEEDS协议/</id>
    <published>2016-02-19T09:13:55.000Z</published>
    <updated>2016-04-20T01:48:22.422Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x00-hpfeeds协议是什么？&quot;&gt;&lt;a href=&quot;#0x00-hpfeeds协议是什么？&quot; class=&quot;headerlink&quot; title=&quot;0x00 hpfeeds协议是什么？&quot;&gt;&lt;/a&gt;0x00 hpfeeds协议是什么？&lt;/h2&gt;&lt;p&gt;feeds，供稿，原始数据。&lt;/p&gt;
&lt;p&gt;hpfeeds是一个轻量级的验证发布-订阅协议(authenticated publish-subscribe protocol)。&lt;/p&gt;
&lt;p&gt;轻量级好理解，就是代码量相对较少，功能相对不复杂。那什么是发布-订阅协议呢？订阅发布协议定义了一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。它是为了解决这样一种情况的发生，一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象需要改变。我的理解，这就类似于发传单，目标发送通知，没有指定特定的对象，通知会自动传播，观察者自己决定是否需要看传单，发送者对于传单是否被看一无所知。&lt;/p&gt;
&lt;p&gt;详细的发布订阅者介绍可以戳这里：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ff649664.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://msdn.microsoft.com/en-us/library/ff649664.aspx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;线路协议组成如下：&lt;/p&gt;
&lt;p&gt;首先是消息头：有两个参数，消息总长和消息类型&lt;/p&gt;
&lt;p&gt;消息类型有以下几种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error (0): errormessage
info (1): server name, nonce
auth (2): client id, sha1(nonce+authkey)
publish (3): client id, channelname, payload
subscribe (4): client id, channelname
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;数字代表消息类型，而冒号后面的内容则代表后续的消息字段&lt;/p&gt;
&lt;p&gt;比如说当消息类型为3，publish时，后面的字段就会有四个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;client id的长度
client id
channelname的长度
channelname
payload
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个完整的消息如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;length | opcode | next | identifier | next | channelname|payload
----------------------------------------------------------------
85       3        9       b4aa2@hp1   9      mwcapture      137941a3d8589f6728924c08561070bceb5d72b8,http://1.2.3.4/calc.exe
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;消息有了，整个消息的认证过程就是以下的几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;服务器为每一个连接生成一个标志&lt;/li&gt;
&lt;li&gt;客户端发送id 和 标志+authkey组成的sha1&lt;/li&gt;
&lt;li&gt;服务器检查id和sha1&lt;/li&gt;
&lt;li&gt;服务器检查数据类型，是要发布还是要订阅&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最终实现服务器、发布者、订阅者之间的解耦，彼此之间完全独立，互不干扰。&lt;/p&gt;
&lt;h2 id=&quot;0x01-为什么要用hpfeeds协议&quot;&gt;&lt;a href=&quot;#0x01-为什么要用hpfeeds协议&quot; class=&quot;headerlink&quot; title=&quot;0x01 为什么要用hpfeeds协议&quot;&gt;&lt;/a&gt;0x01 为什么要用hpfeeds协议&lt;/h2&gt;&lt;p&gt;首先，正如以上所说的，整个协议实现了三方的功能独立。使用这种方式降低了应用与业务逻辑之间的耦合，统一一个对外的发布接口，只需要关心监听的类型，不关心监听的具体处理人。只管发，不管到不到。很方便的建立一种一对多的依赖关系。&lt;/p&gt;
&lt;p&gt;在当一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象需要改变时，就可以使用订阅发布模式。&lt;/p&gt;
&lt;p&gt;hpfeeds协议希望能够实现一个单一的连线形式，使得每一个人都可以在任何时间以任何语言去订阅发布数据，不同的数据以通道来划分，由通道的使用者来决定数据结构形式。而通道的验证通过authkey来完成，它由两部分组成，ident和secret，相当于身份和密码。密码在hash后和每一个临时连接标志一起发送给服务器，这样保证不会被窃听，所以它可以运行在SSL、TLS下。&lt;/p&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.降低耦合。发布者对于接收者的数量，身份，接收的数据类型一无所知。&lt;/li&gt;
&lt;li&gt;2.安全性高。只有消息订阅者之间的单线信息交互，不存在其他程序的信息交换。&lt;/li&gt;
&lt;li&gt;3.测试方便。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;p&gt;性能降低，订阅要进行管理&lt;/p&gt;
&lt;h2 id=&quot;0x02-如何操作&quot;&gt;&lt;a href=&quot;#0x02-如何操作&quot; class=&quot;headerlink&quot; title=&quot;0x02 如何操作&quot;&gt;&lt;/a&gt;0x02 如何操作&lt;/h2&gt;&lt;p&gt;正常安装使用hpfeeds的步骤如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/rep/hpfeeds/
cd hpfeeds
python setup.py build
python setup.py install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装成功后，会出现下面几个文件夹。&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;appsuport：hpfeeds支持的一些蜜罐的应用程序&lt;/li&gt;
&lt;li&gt;broker：服务器功能程序集，包括增加用户，服务器运行，查看所有用户信息等&lt;/li&gt;
&lt;li&gt;build：一些编译环境&lt;/li&gt;
&lt;li&gt;cli：用户程序&lt;/li&gt;
&lt;li&gt;example：例程&lt;/li&gt;
&lt;li&gt;lib：支持库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用时先打开broker，运行其中的add_user.py添加用户信息：&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;根据提示信息，我们添加用户test，密码123456，拥有发布频道1，2，无订阅频道&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;再添加用户custom，密码123456，拥有订阅频道1，2，无发布频道&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;现在使用dump_users.py查看刚才创建的用户&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图所示，这里应经可以查看到刚才我们新建的用户了。&lt;/p&gt;
&lt;p&gt;接下来，我们打开服务器feedbroker.py&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;再开启一个新的进程运行cli文件夹里的用户程序hpfeeds-client&lt;/p&gt;
&lt;p&gt;先开启订阅者custom，使用1频道&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/7.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;此时，服务器端显示用户登录成功&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/8.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们再打开一个新的进程，以发布者test，使用1频道发布“helloworld”&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到发布者一旦发布完消息后，立即退出进程，并不确认消息是否收到&lt;/p&gt;
&lt;p&gt;这时，服务器显示test登录成功&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/10.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;于此同时，订阅者custom成功接收到消息&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/11.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;到此，一次完整的发送、接收消息的流程就走完了。&lt;/p&gt;
&lt;p&gt;通过这一过程，我们发现，频道与用户分离，发送和订阅者身份平等，只需订阅者实时监听，发送者可以即时发送即时撤出。&lt;/p&gt;
&lt;p&gt;这里是对于hpfeeds协议的简单介绍，下一部分我会从代码的角度进一步分析该协议，并适当对于协议功能进行添加。&lt;/p&gt;
&lt;p&gt;原创文章，转载请注明： 转载自零の杂货铺&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-hpfeeds协议是什么？&quot;&gt;&lt;a href=&quot;#0x00-hpfeeds协议是什么？&quot; class=&quot;headerlink&quot; title=&quot;0x00 hpfeeds协议是什么？&quot;&gt;&lt;/a&gt;0x00 hpfeeds协议是什么？&lt;/h2&gt;&lt;p&gt;feeds，
    
    </summary>
    
      <category term="蜜罐" scheme="http://phantom0301.github.io/categories/%E8%9C%9C%E7%BD%90/"/>
    
    
      <category term="MHN" scheme="http://phantom0301.github.io/tags/MHN/"/>
    
      <category term="hpfeeds" scheme="http://phantom0301.github.io/tags/hpfeeds/"/>
    
      <category term="蜜罐" scheme="http://phantom0301.github.io/tags/%E8%9C%9C%E7%BD%90/"/>
    
  </entry>
  
  <entry>
    <title>PyMongo官方文档翻译</title>
    <link href="http://phantom0301.github.io/2016/02/19/PyMongo%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    <id>http://phantom0301.github.io/2016/02/19/PyMongo官方文档翻译/</id>
    <published>2016-02-19T09:00:36.000Z</published>
    <updated>2016-02-21T04:45:56.579Z</updated>
    
    <content type="html">&lt;p&gt;最近做的几个项目都用到了Python+MongoDB，好像更新一版的Mongo刚刚发布。既然是使用python，肯定是绕不过Pymongo库了，先从官方文档看起。&lt;/p&gt;
&lt;p&gt;想练习英语的戳这里~&lt;a href=&quot;http://api.mongodb.org/python/current/tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://api.mongodb.org/python/current/tutorial.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;教程&quot;&gt;&lt;a href=&quot;#教程&quot; class=&quot;headerlink&quot; title=&quot;教程&quot;&gt;&lt;/a&gt;教程&lt;/h2&gt;&lt;p&gt;本教程旨在介绍使用MongoDB和PyMongo&lt;/p&gt;
&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;安装&lt;strong&gt;PyMongo&lt;/strong&gt;模块，&lt;strong&gt;MongoDB&lt;/strong&gt;数据库。&lt;br&gt;恩，在python的shell里，下面这句话没报错就算安装成功了（废话~）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;import pymongo
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;本教程还假设MongoDB实例运行在默认的主机（127.0.0.1）和端口（27017）。假设您已经下载并安装MongoDB,您可以启动它就像这样:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mongod
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;使用MongoClient完成数据库连接&quot;&gt;&lt;a href=&quot;#使用MongoClient完成数据库连接&quot; class=&quot;headerlink&quot; title=&quot;使用MongoClient完成数据库连接&quot;&gt;&lt;/a&gt;使用MongoClient完成数据库连接&lt;/h2&gt;&lt;p&gt;第一步就是使用PyMongo中的MongoClient来完成程序和数据库之间的连接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from pymongo import MongoClient
&amp;gt;&amp;gt;&amp;gt; client = MongoClient()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码将在默认的主机和端口连接。我们也可以显式地指定主机和端口,如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; client = MongoClient(&amp;apos;localhost&amp;apos;, 27017)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以使用另一种形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; client = MongoClient(&amp;apos;mongodb://localhost:27017/&amp;apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;获得数据库&quot;&gt;&lt;a href=&quot;#获得数据库&quot; class=&quot;headerlink&quot; title=&quot;获得数据库&quot;&gt;&lt;/a&gt;获得数据库&lt;/h2&gt;&lt;p&gt;MongoDB的单个实例可以支持多个独立的数据库。PyMongo支持使用属性的形式来获得数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; db = client.test_database
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果上面的形式无法访问到数据库，可以采用另一种字典的形式来访问：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; db = client[&amp;apos;test-database&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;获得集合&quot;&gt;&lt;a href=&quot;#获得集合&quot; class=&quot;headerlink&quot; title=&quot;获得集合&quot;&gt;&lt;/a&gt;获得集合&lt;/h2&gt;&lt;p&gt;集合是MongoDB中存储的一组文档，可以类比为关系型数据库中的表，获得集合的方式与获得数据库方式相同&lt;/p&gt;
&lt;p&gt;拥有两种方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; collection = db.test_collection
&amp;gt;&amp;gt;&amp;gt; collection = db[&amp;apos;test-collection&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;值得注意的是，集合和库在MongoDB中的创建是松散的，以上命令实际上并没有在服务器端做任何操作。&lt;/p&gt;
&lt;p&gt;当有文档（数据）插入到里面的时候，集合和库才被创建。&lt;/p&gt;
&lt;h2 id=&quot;文档（数据）&quot;&gt;&lt;a href=&quot;#文档（数据）&quot; class=&quot;headerlink&quot; title=&quot;文档（数据）&quot;&gt;&lt;/a&gt;文档（数据）&lt;/h2&gt;&lt;p&gt;MongoDB中的数据使用（存储为）JSON格式文件。在PyMongo中使用字典来表示这种结构。&lt;/p&gt;
&lt;p&gt;举个栗子,下面的字典可以用来代表一篇博文:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import datetime
&amp;gt;&amp;gt;&amp;gt; post = {&amp;quot;author&amp;quot;: &amp;quot;Mike&amp;quot;,
... &amp;quot;text&amp;quot;: &amp;quot;My first blog post!&amp;quot;,
... &amp;quot;tags&amp;quot;: [&amp;quot;mongodb&amp;quot;, &amp;quot;python&amp;quot;, &amp;quot;pymongo&amp;quot;],
... &amp;quot;date&amp;quot;: datetime.datetime.utcnow()}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意,文档可以包含本地Python类型(如datetime.datetime实例),这些会自动转换为合适的BSON类型。&lt;/p&gt;
&lt;h2 id=&quot;插入文件&quot;&gt;&lt;a href=&quot;#插入文件&quot; class=&quot;headerlink&quot; title=&quot;插入文件&quot;&gt;&lt;/a&gt;插入文件&lt;/h2&gt;&lt;p&gt;要插入一个文件到集合中，我们可以使用insert_one( )方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; posts = db.posts
&amp;gt;&amp;gt;&amp;gt; post_id = posts.insert_one(post).inserted_id
&amp;gt;&amp;gt;&amp;gt; post_id
ObjectId(&amp;apos;...&amp;apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果插入的文档没有“_id”这个键的话，系统会自动给它加上。“_id”键的值在整个集合中是唯一的（有点主键的意思）。insert _one( )返回一个InsertOneResult的实例。更多关于”_id“的信息，参阅 _id。&lt;/p&gt;
&lt;p&gt;在插入第一个文档后，集合就真正在服务器上创建。通过列出库中所有的集合，我们可以验证这一点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; db.collection_names(include_system_collections=False)
[u&amp;apos;posts&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;通过find-one-获取单个文档&quot;&gt;&lt;a href=&quot;#通过find-one-获取单个文档&quot; class=&quot;headerlink&quot; title=&quot;通过find_one( )获取单个文档&quot;&gt;&lt;/a&gt;通过find_one( )获取单个文档&lt;/h2&gt;&lt;p&gt;最基本的可以执行的查询类型有find_one( )。这个方法根据查询返回一个匹配的文档。如果没有匹配就返回None。&lt;/p&gt;
&lt;p&gt;对于只有单一匹配或者只对第一个匹配感兴趣的情况下，可以选用这种方法。下面是一个获取第一个文档的栗子~&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; posts.find_one()
{u&amp;apos;date&amp;apos;: datetime.datetime(...), u&amp;apos;text&amp;apos;: u&amp;apos;My first blog post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;mongodb&amp;apos;, u&amp;apos;python&amp;apos;, u&amp;apos;pymongo&amp;apos;]}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果是我们之前插入的那个注意到返回结果中”_id”这个键是自动加入的。&lt;br&gt;find_one()也支持特定的结果匹配。比如我们用作者”Mike”来限制返回的查找结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; posts.find_one({&amp;quot;author&amp;quot;: &amp;quot;Mike&amp;quot;})
{u&amp;apos;date&amp;apos;: datetime.datetime(...), u&amp;apos;text&amp;apos;: u&amp;apos;My first blog post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;mongodb&amp;apos;, u&amp;apos;python&amp;apos;, u&amp;apos;pymongo&amp;apos;]}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果我们用另一个文档中不存在的字典“Eliot”来查找，将得不到结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; posts.find_one({&amp;quot;author&amp;quot;: &amp;quot;Eliot&amp;quot;})
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;通过对象ID查询&quot;&gt;&lt;a href=&quot;#通过对象ID查询&quot; class=&quot;headerlink&quot; title=&quot;通过对象ID查询&quot;&gt;&lt;/a&gt;通过对象ID查询&lt;/h2&gt;&lt;p&gt;我们也可以通过“_id”来查找&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; post_id
ObjectId(...)
&amp;gt;&amp;gt;&amp;gt; posts.find_one({&amp;quot;_id&amp;quot;: post_id})
{u&amp;apos;date&amp;apos;: datetime.datetime(...), u&amp;apos;text&amp;apos;: u&amp;apos;My first blog post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;mongodb&amp;apos;, u&amp;apos;python&amp;apos;, u&amp;apos;pymongo&amp;apos;]}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意，对象ID不是一个字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; post_id_as_str = str(post_id)
&amp;gt;&amp;gt;&amp;gt; posts.find_one({&amp;quot;_id&amp;quot;: post_id_as_str}) # No result
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;web应用程序中的一个常见任务是从URL得到对象ID,找到匹配的文档。&lt;br&gt;这种情况下，需要将对象ID从字符串类型转换到ObjectId(符合find_one格式的类型):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from bson.objectid import ObjectId
# The web framework gets post_id from the URL and passes it as a string
def get(post_id):
# Convert from string to ObjectId:
document = client.db.collection.find_one({&amp;apos;_id&amp;apos;: ObjectId(post_id)})
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;UNICODE字符串注意&quot;&gt;&lt;a href=&quot;#UNICODE字符串注意&quot; class=&quot;headerlink&quot; title=&quot;UNICODE字符串注意&quot;&gt;&lt;/a&gt;UNICODE字符串注意&lt;/h2&gt;&lt;p&gt;你可能注意到，服务器中得到的数据和常规的Python字符串不太一样（例如用u’Mike’来代替’Mike’）&lt;/p&gt;
&lt;p&gt;这是因为我们的数据库以BSON的格式存储数据。这种格式采用UTF-8编码，所以PyMongo需要确保所有&lt;/p&gt;
&lt;p&gt;存储的字符串包含唯一可用的UTF-8数据。基于此，PyMongo解码每一个BSON字符为Python的unicode字符，而不是常见的字符串。&lt;/p&gt;
&lt;h2 id=&quot;批量插入&quot;&gt;&lt;a href=&quot;#批量插入&quot; class=&quot;headerlink&quot; title=&quot;批量插入&quot;&gt;&lt;/a&gt;批量插入&lt;/h2&gt;&lt;p&gt;为了使查询更加有趣,让我们插入更多的文档。&lt;/p&gt;
&lt;p&gt;除了插入一个文档,我们也可以执行批量插入操作,&lt;br&gt;通过insert_many插入列表的方式，可以插入列表中的每一个文档，而只向服务器发送一次指令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; new_posts = [{&amp;quot;author&amp;quot;: &amp;quot;Mike&amp;quot;,
...   &amp;quot;text&amp;quot;: &amp;quot;Another post!&amp;quot;,
...   &amp;quot;tags&amp;quot;: [&amp;quot;bulk&amp;quot;, &amp;quot;insert&amp;quot;],
...   &amp;quot;date&amp;quot;: datetime.datetime(2009, 11, 12, 11, 14)},
...  {&amp;quot;author&amp;quot;: &amp;quot;Eliot&amp;quot;,
...   &amp;quot;title&amp;quot;: &amp;quot;MongoDB is fun&amp;quot;,
...   &amp;quot;text&amp;quot;: &amp;quot;and pretty easy too!&amp;quot;,
...   &amp;quot;date&amp;quot;: datetime.datetime(2009, 11, 10, 10, 45)}]
&amp;gt;&amp;gt;&amp;gt; result = posts.insert_many(new_posts)
&amp;gt;&amp;gt;&amp;gt; result.inserted_ids
[ObjectId(&amp;apos;...&amp;apos;), ObjectId(&amp;apos;...&amp;apos;)]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于这个栗子，需要多去咀嚼的地方：&lt;/p&gt;
&lt;p&gt;结果返回了两个对象ID实例，就是我们批量插入地文档；&lt;/p&gt;
&lt;p&gt;两个文档的键并不一样哦，一个是“tags”，另一个是“title”，这就是我们之前所说的MongoDB是模式自由的。&lt;/p&gt;
&lt;h2 id=&quot;查询多个文档&quot;&gt;&lt;a href=&quot;#查询多个文档&quot; class=&quot;headerlink&quot; title=&quot;查询多个文档&quot;&gt;&lt;/a&gt;查询多个文档&lt;/h2&gt;&lt;p&gt;为了能够返回多个文档，我们可以使用find( )方法，返回一个游标实例，它允许我们遍历所有匹配的文档。&lt;/p&gt;
&lt;p&gt;又一个栗子，我们可以遍历集合中所有的文档：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; for post in posts.find():
...   post
...
{u&amp;apos;date&amp;apos;: datetime.datetime(...), u&amp;apos;text&amp;apos;: u&amp;apos;My first blog post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;mongodb&amp;apos;, u&amp;apos;python&amp;apos;, u&amp;apos;pymongo&amp;apos;]}
{u&amp;apos;date&amp;apos;: datetime.datetime(2009, 11, 12, 11, 14), u&amp;apos;text&amp;apos;: u&amp;apos;Another post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;bulk&amp;apos;, u&amp;apos;insert&amp;apos;]}
{u&amp;apos;date&amp;apos;: datetime.datetime(2009, 11, 10, 10, 45), u&amp;apos;text&amp;apos;: u&amp;apos;and pretty easy too!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Eliot&amp;apos;, u&amp;apos;title&amp;apos;: u&amp;apos;MongoDB is fun&amp;apos;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它也可以支持限制查找，我们可以限制作者为”Mike”：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; for post in posts.find({&amp;quot;author&amp;quot;: &amp;quot;Mike&amp;quot;}):
...   post
...
{u&amp;apos;date&amp;apos;: datetime.datetime(...), u&amp;apos;text&amp;apos;: u&amp;apos;My first blog post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;mongodb&amp;apos;, u&amp;apos;python&amp;apos;, u&amp;apos;pymongo&amp;apos;]}
{u&amp;apos;date&amp;apos;: datetime.datetime(2009, 11, 12, 11, 14), u&amp;apos;text&amp;apos;: u&amp;apos;Another post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;bulk&amp;apos;, u&amp;apos;insert&amp;apos;]}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;计数&quot;&gt;&lt;a href=&quot;#计数&quot; class=&quot;headerlink&quot; title=&quot;计数&quot;&gt;&lt;/a&gt;计数&lt;/h2&gt;&lt;p&gt;如果我们只想知道文档数，可以用count()来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; posts.count()
3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你们懂得，这里也可以做限制查找&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; posts.find({&amp;quot;author&amp;quot;: &amp;quot;Mike&amp;quot;}).count()
2
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;范围查询&quot;&gt;&lt;a href=&quot;#范围查询&quot; class=&quot;headerlink&quot; title=&quot;范围查询&quot;&gt;&lt;/a&gt;范围查询&lt;/h2&gt;&lt;p&gt;MongoDB支持许多不同类型的高级查询。&lt;/p&gt;
&lt;p&gt;栗子~栗子~,可以执行一个查询,我们限制结果为一个特定日期,同时按照作者排序:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d=datetime.datetime(2009,11,12,12)&amp;gt;&amp;gt;&amp;gt; forpostinposts.find({&amp;quot;date&amp;quot;:{&amp;quot;$lt&amp;quot;:d}}).sort(&amp;quot;author&amp;quot;):... printpost...{u&amp;apos;date&amp;apos;: datetime.datetime(2009, 11, 10, 10, 45), u&amp;apos;text&amp;apos;: u&amp;apos;and pretty easy too!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Eliot&amp;apos;, u&amp;apos;title&amp;apos;: u&amp;apos;MongoDB is fun&amp;apos;}{u&amp;apos;date&amp;apos;: datetime.datetime(2009, 11, 12, 11, 14), u&amp;apos;text&amp;apos;: u&amp;apos;Another post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;bulk&amp;apos;, u&amp;apos;insert&amp;apos;]}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里我们用特殊的操作符”$lt”来做范围查询，同时用sort()做作者排序。&lt;/p&gt;
&lt;h2 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h2&gt;&lt;p&gt;添加索引可以加快某些查询，也可以增加一些额外的查询和存储文档功能。&lt;/p&gt;
&lt;p&gt;在这个例子中,我们将演示如何创建一个惟一的键索引来拒绝那些已经在索引中存在的键对应的值的文档。&lt;br&gt;首先，创建一个索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; result=db.profiles.create_index([(&amp;apos;user_id&amp;apos;,pymongo.ASCENDING)],... unique=True)&amp;gt;&amp;gt;&amp;gt; list(db.profiles.index_information())[u&amp;apos;user_id_1&amp;apos;, u&amp;apos;_id_&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意，我们现在有两个索引，一个是数据库自动创建的“_id”，另一个是我们刚创建的“user_id”。&lt;br&gt;现在让我们设置一些用户配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; user_profiles = [
... {&amp;apos;user_id&amp;apos;: 211, &amp;apos;name&amp;apos;: &amp;apos;Luke&amp;apos;},
... {&amp;apos;user_id&amp;apos;: 212, &amp;apos;name&amp;apos;: &amp;apos;Ziltoid&amp;apos;}]
&amp;gt;&amp;gt;&amp;gt; result = db.profiles.insert_many(user_profiles)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;索引可以防止插入时user_id重复：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; new_profile={&amp;apos;user_id&amp;apos;:213,&amp;apos;name&amp;apos;:&amp;apos;Drew&amp;apos;}&amp;gt;&amp;gt;&amp;gt; duplicate_profile={&amp;apos;user_id&amp;apos;:212,&amp;apos;name&amp;apos;:&amp;apos;Tommy&amp;apos;}&amp;gt;&amp;gt;&amp;gt; result=db.profiles.insert_one(new_profile)# This is fine.&amp;gt;&amp;gt;&amp;gt; result=db.profiles.insert_one(duplicate_profile)Traceback (most recent call last):pymongo.errors.DuplicateKeyError:E11000 duplicate key error index: test_database.profiles.$user_id_1 dup key: { : 212 }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原创文章，转载请注明： 转载自零の杂货铺&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近做的几个项目都用到了Python+MongoDB，好像更新一版的Mongo刚刚发布。既然是使用python，肯定是绕不过Pymongo库了，先从官方文档看起。&lt;/p&gt;
&lt;p&gt;想练习英语的戳这里~&lt;a href=&quot;http://api.mongodb.org/python
    
    </summary>
    
      <category term="python" scheme="http://phantom0301.github.io/categories/python/"/>
    
    
      <category term="pymongo" scheme="http://phantom0301.github.io/tags/pymongo/"/>
    
      <category term="python" scheme="http://phantom0301.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>博客纪元，写在前面</title>
    <link href="http://phantom0301.github.io/2016/02/19/%E5%8D%9A%E5%AE%A2%E7%BA%AA%E5%85%83%EF%BC%8C%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
    <id>http://phantom0301.github.io/2016/02/19/博客纪元，写在前面/</id>
    <published>2016-02-19T08:51:02.000Z</published>
    <updated>2016-02-21T04:46:10.754Z</updated>
    
    <content type="html">&lt;p&gt;其实很早之前就希望能够开通一个个人博客，在这里分享所见、所学，将头脑里零碎的知识和感悟整理成系统的结构。&lt;/p&gt;
&lt;p&gt;最初，是打算用wp搭建博客，然后再买个阿里云的服务器和独立域名。wp的博客年前就已经搭好了，但是谁知买服务器的时候，提示说大四不能享受学生优惠~啊摔&lt;/p&gt;
&lt;p&gt;没办法，又折腾起github的个人页面来了，用的是hexo+github，折腾了一天，解决了各种奇葩的问题，终于能够勉强运行了。&lt;/p&gt;
&lt;p&gt;先简单的从之前wp的博客上搬几篇文章过来填白，话说如果有前端牛想要帮我美化一下，尽管来联系我：）&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;其实很早之前就希望能够开通一个个人博客，在这里分享所见、所学，将头脑里零碎的知识和感悟整理成系统的结构。&lt;/p&gt;
&lt;p&gt;最初，是打算用wp搭建博客，然后再买个阿里云的服务器和独立域名。wp的博客年前就已经搭好了，但是谁知买服务器的时候，提示说大四不能享受学生优惠~啊摔&lt;/p
    
    </summary>
    
      <category term="感悟" scheme="http://phantom0301.github.io/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="感悟" scheme="http://phantom0301.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
</feed>
