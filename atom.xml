<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>零の杂货铺</title>
  <subtitle>Free and Share</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://phantom0301.github.io/"/>
  <updated>2016-04-20T01:48:49.910Z</updated>
  <id>http://phantom0301.github.io/</id>
  
  <author>
    <name>Phantom</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>略读《通鉴》-汉纪-那些打破我们常规认识的宦官形象</title>
    <link href="http://phantom0301.github.io/2016/04/14/%E7%95%A5%E8%AF%BB%E3%80%8A%E9%80%9A%E9%89%B4%E3%80%8B-%E6%B1%89%E7%BA%AA/"/>
    <id>http://phantom0301.github.io/2016/04/14/略读《通鉴》-汉纪/</id>
    <published>2016-04-14T09:53:27.000Z</published>
    <updated>2016-04-20T01:48:49.910Z</updated>
    
    <content type="html">&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;闲暇时候随手翻阅了kindle中存的《资治通鉴》，本来只是随便阅读些史料，但是偶然中读到了黄门吕强其人其事，突然有了一个想法。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;平时我们在电视剧电影中经常看到宦官这一形象，在影视作品中，宦官时而被描写为武艺高强的大反派，时而被描写为性格诡谲的小人，也有一些作品中，宦官被赋予了是非分明的形象。那么，在真实的史料中，是否有像我们在影视剧中定位的贤良的宦官形象呢？&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;主要阅读的是《通鉴》中汉纪光武以后到三国的部分，在此以前的西汉历史中，为了避免秦末赵高大权独揽情况的发生，内侍人员多使用士人，到了东汉，开始使用宦官。这一段史料中出现的第一个符合我们要求的形象是中常侍钩盾令郑众，钩盾令主要负责园苑游观之事。这时是汉和帝时期，由于外戚窦宪专政，朝臣莫不附之，但是郑众谨敏有心机，没有附和窦宪，最终与和帝一起定策诛宪。蔡伦大家都比较了解，这里就不赘述。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;接下来要说的就是中常侍孙程，这里背景简略说一下，当时的皇帝听信另一批宦官的谗言，废除皇太子为济阴王，后来皇后和外戚就立了北乡侯。没过多久，北乡侯就死了，这时之前的废太子还在，而皇后和进谗言的宦官希望立其他的外藩王为帝。这时孙程对废太子的侍从说到：“王以嫡统，本无失德。先帝用谗，遂至废黜。若北乡侯不起，相与共断江京、阎显，事无不成者。”最终，孙程和王康等十九人歃血为盟，斩除了外戚阎显以及同党，迎立了废太子登基。后来司隶校尉虞诩被宦官诬陷，要治死罪，孙程直接上殿，呵斥构陷者，被皇帝免官。后来，皇帝追念他的功勋，又把他召回了京师。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;第三个要说的是曹操名义上的祖父——曹腾。曹腾早年也是因为迎立汉桓帝有功，被封为费亭侯，升任大长秋，史书说他在宫中三十多年，没有显著地过失，并且能推荐贤人，陈留虞放、边韶、南阳延固、张温、弘农张奂、颍川堂谿典等都受到他的举荐。有一次，刺史种暠因为截获了外官打算贿赂曹腾的文书，于是弹劾曹腾，皇帝因为文书是从外地发来，便不予追究。后来曹腾还称赞种暠为能吏，种暠最后官至司徒，还说道他能做到这个职位，都是曹腾的功劳。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;最后要提到的就是中常侍吕强，这个人在《通鉴》里面描述颇多。说吕强从黄门升到中常侍，为人清忠奉公。汉灵帝时，封他为都乡侯，他辞让不肯接受，而且还上书劝说皇帝注意宦官为乱，后宫采女不应太多，河间不应该劳民伤财筑解渎馆，另外还上书说蔡邕对策切直，不应该治他的罪等等。后来黄巾之乱爆发，他又劝说皇帝赦免党人，诛杀贪官，考核地方官员。最终被同僚忌惮，吕强愤而自杀。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;在这一段所谓的宦官第一次当权的历史中，还有像良贺、丁肃、徐衍、赵祐等等和当时大批专权的宦官不同的形象，和影视剧中相比，让我们对于宦官形象有了不一样的认识。其实，从春秋战国到明末，不时的都能够在史料中看到这样一个群体打破大众对他们固有印象的事件，比如一些后来著名的治世能臣早年在宦官门下当食客，后经主人举荐得到君王赏识；一些人同时也是当时的书法家、匠人或者在经史学说上有所成就；还有一些人以忠于君王，同君王共赴危难而得到史家的青睐。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;闲暇时候随手翻阅了kindle中存的《资治通鉴》，本来只是随便阅读些史料，但是偶然中读到了黄门吕强其人其事，突然有了一个想法。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;平时我们在电视剧电影中经
    
    </summary>
    
      <category term="读书笔记" scheme="http://phantom0301.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="宦官" scheme="http://phantom0301.github.io/tags/%E5%AE%A6%E5%AE%98/"/>
    
      <category term="资治通鉴" scheme="http://phantom0301.github.io/tags/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/"/>
    
  </entry>
  
  <entry>
    <title>Js-Python实现socket通信</title>
    <link href="http://phantom0301.github.io/2016/04/12/Js-Python%E5%AE%9E%E7%8E%B0socket%E9%80%9A%E4%BF%A1/"/>
    <id>http://phantom0301.github.io/2016/04/12/Js-Python实现socket通信/</id>
    <published>2016-04-12T07:51:55.000Z</published>
    <updated>2016-04-12T08:38:25.979Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;Socket，一种开销很小的实现程序之间通信的方式。不同的编程语言几乎都有自己实现Socket的库和方法，建立在Socket基础上的许多通信协议也都广泛运用于各种框架中，之前在博客分享的Hpfeeds协议实际上就是建立在Socket的基础上。&lt;/p&gt;
&lt;p&gt;不同编程语言之间也经常使用Socket来传递消息，这样可以避免不同语言之间的嵌套调用。如题，这里我们需要在Python和Js之间实现一个消息传递。&lt;/p&gt;
&lt;h2 id=&quot;0x01-实现&quot;&gt;&lt;a href=&quot;#0x01-实现&quot; class=&quot;headerlink&quot; title=&quot;0x01 实现&quot;&gt;&lt;/a&gt;0x01 实现&lt;/h2&gt;&lt;p&gt;最初查找资料的时候，许多博客中都提到了说，Js本身是不能够实现Socket的，而常用的方法实际上是利用Flash的Socket来进行通信，然后通过Js获得Flash的响应事件来传递数据。为此有一个专门的Js库叫Aflax。&lt;/p&gt;
&lt;p&gt;同时，另一种更新的方法是使用Html5协议中的WebSocket来实现浏览器和服务器的通信。&lt;/p&gt;
&lt;p&gt;关于WebSocket的具体协议就不在这里详述了，毕竟我也没有认真去看。&lt;/p&gt;
&lt;p&gt;实现WebSocket通信的方法也有很多种，网上容易查到的是使用Node.js的实现方法&lt;br&gt;&lt;a href=&quot;https://github.com/SushisMakis/WebSocket&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/SushisMakis/WebSocket&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里，作者提供个一个Python实现的服务器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import struct
import SocketServer
from base64 import b64encode, b64decode
from hashlib import sha1
from mimetools import Message
from StringIO import StringIO

clients = [];
class WebSocketsHandler(SocketServer.StreamRequestHandler):
    magic = &amp;apos;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&amp;apos;

    def setup(self):
        SocketServer.StreamRequestHandler.setup(self)
        print &amp;quot;connection established&amp;quot;, self.client_address
        self.handshake_done = False

    def handle(self):
        while True:
            if not self.handshake_done:
                self.handshake()
                clients.append(self)
            else:
                try:
                    self.read_next_message()
                except:
                    self.request.close()
                    return

    def read_next_message(self):
        length = ord(self.rfile.read(2)[1]) &amp;amp; 127
        if length == 126:
            length = struct.unpack(&amp;quot;&amp;gt;H&amp;quot;, self.rfile.read(2))[0]
        elif length == 127:
            length = struct.unpack(&amp;quot;&amp;gt;Q&amp;quot;, self.rfile.read(8))[0]
        masks = [ord(byte) for byte in self.rfile.read(4)]
        decoded = &amp;quot;&amp;quot;
        for char in self.rfile.read(length):
            decoded += chr(ord(char) ^ masks[len(decoded) % 4])
        self.on_message(decoded)

    def send_message(self, data, fin=True, opcode=1, masking_key=False):
        header = struct.pack(&amp;apos;!B&amp;apos;, ((fin &amp;lt;&amp;lt; 7) | (0 &amp;lt;&amp;lt; 6)| (0 &amp;lt;&amp;lt; 5)| (0 &amp;lt;&amp;lt; 4)| opcode))
        if masking_key:
            mask_bit = 1 &amp;lt;&amp;lt; 7
        else:
            mask_bit = 0
        length = len(data)
        if length &amp;lt; 126:
            header += struct.pack(&amp;apos;!B&amp;apos;, (mask_bit | length))
        elif length &amp;lt; (1 &amp;lt;&amp;lt; 16):
            header += struct.pack(&amp;apos;!B&amp;apos;, (mask_bit | 126)) + struct.pack(&amp;apos;!H&amp;apos;, length)
        elif length &amp;lt; (1 &amp;lt;&amp;lt; 63):
            header += struct.pack(&amp;apos;!B&amp;apos;, (mask_bit | 127)) + struct.pack(&amp;apos;!Q&amp;apos;, length)
        body = data
        self.request.send(bytes(header + body))

    def handshake(self):
        data = self.request.recv(1024).strip()
        headers = Message(StringIO(data.split(&amp;apos;\r\n&amp;apos;, 1)[1]))
        if headers.get(&amp;quot;Upgrade&amp;quot;, None) != &amp;quot;websocket&amp;quot;:
            return
        print &amp;apos;Handshaking...&amp;apos;
        key = headers[&amp;apos;Sec-WebSocket-Key&amp;apos;]
        digest = b64encode(sha1(key + self.magic).hexdigest().decode(&amp;apos;hex&amp;apos;))
        response = &amp;apos;HTTP/1.1 101 Switching Protocols\r\n&amp;apos;+&amp;apos;Upgrade: websocket\r\n&amp;apos;+&amp;apos;Connection: Upgrade\r\n&amp;apos;
        response += &amp;apos;Sec-WebSocket-Accept: %s\r\n\r\n&amp;apos; % digest
        self.handshake_done = self.request.send(response)

    def on_message(self, message):
        text = b64decode(message)
        print text
        for client in clients:
            if client.client_address != self.client_address:
                client.send_message(b64encode(text))

class ThreadedTCPServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):
    pass

if __name__ == &amp;quot;__main__&amp;quot;:
    server = ThreadedTCPServer((&amp;quot;localhost&amp;quot;, 9999), WebSocketsHandler)
    server.serve_forever()   
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们使用其中的这段代码作为服务器。&lt;/p&gt;
&lt;p&gt;用这段Ps作为浏览器端的接收Pemo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// SmWebSocket(url,port,b64encode,fonMessage, ...)
var smWs = new SmWebSocket(&amp;quot;localhost&amp;quot;,9999,true,handle_recv);
smWs.open();
var myDictObjectProtocol = {&amp;quot;p1top2&amp;quot;: handle_transit}; // {id : function, ... }
var p = new Protocol(myDictObjectProtocol,&amp;quot;|&amp;quot;);

function handle_recv(event)
{
    var data = event.data;
    data = Base64.decode(data);
    alert(data);
    p.handleMessage(data);
}

function handle_transit(mess){
    document.getElementById(&amp;quot;data_in&amp;quot;).innerText = mess;
} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里作者只实现了浏览器发送到服务器以及浏览器之间的交互，所以现在我们还缺一个Python发送的程序，我最初希望直接使用Pyhton的Socket来实现一个端口发送，但是最后发现每次发送的程序都被服务器拒绝了，所以我又找到了一个Python实现的WebSocket库，当然这个和Pip下载的WebSocket库不同。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/liris/websocket-client&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/liris/websocket-client&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我修改了其中编码的部分，以和之前的程序适应&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from __future__ import print_function
import websocket
import base64

if __name__ == &amp;quot;__main__&amp;quot;:
    #websocket.enableTrace(True)
    ws = websocket.create_connection(&amp;quot;ws://localhost:9999&amp;quot;)
    data = &amp;quot;p1top2|Hello World&amp;quot;
    data = base64.b64encode(data)
    ws.send(data)
    ws.close()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要求的库直接Clone上面项目里的即可，这样，我们就实现了通过Python和Js进行Socket通信的程序。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;Socket，一种开销很小的实现程序之间通信的方式。不同的编程语言几乎都有自己实现Socket的库和
    
    </summary>
    
      <category term="python" scheme="http://phantom0301.github.io/categories/python/"/>
    
    
      <category term="JS" scheme="http://phantom0301.github.io/tags/JS/"/>
    
      <category term="Python" scheme="http://phantom0301.github.io/tags/Python/"/>
    
      <category term="Socket" scheme="http://phantom0301.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>效率利器-Synergy</title>
    <link href="http://phantom0301.github.io/2016/04/06/%E6%95%88%E7%8E%87%E5%88%A9%E5%99%A8-Synergy/"/>
    <id>http://phantom0301.github.io/2016/04/06/效率利器-Synergy/</id>
    <published>2016-04-06T06:52:16.000Z</published>
    <updated>2016-04-06T07:18:11.405Z</updated>
    
    <content type="html">&lt;p&gt;最近要同时操作两台机器，一台是win的，一台是linux的。无论是准备两套键鼠，还是用SSH远程都不够方便。&lt;/p&gt;
&lt;p&gt;在网上找到了这个软件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/sy1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;发现很好的解决了我的需求，而且它不仅可以让两个系统的主机共用一套键鼠，还可以实现两台主机上的简单分屏，虽然不能直接从一个屏幕拖到另一个屏幕，但是鼠标可以无缝连接滑动，而且共享剪贴板。&lt;/p&gt;
&lt;p&gt;设置也很简单&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/sy2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在两台电脑上分别安装Synergy，并且在同一个局域网中。一台作为server主机（键鼠物理连接的电脑），一台作为client从机。&lt;/p&gt;
&lt;p&gt;在主机上进行配置，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/sy3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在这里选择分屏的位置。&lt;/p&gt;
&lt;p&gt;再在 Advanced server settings设置主从机切换的快捷键&lt;/p&gt;
&lt;p&gt;分别启动，软件就会自动去检测主从机。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近要同时操作两台机器，一台是win的，一台是linux的。无论是准备两套键鼠，还是用SSH远程都不够方便。&lt;/p&gt;
&lt;p&gt;在网上找到了这个软件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/sy1.jpg&quot; 
    
    </summary>
    
    
      <category term="工具" scheme="http://phantom0301.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>爆破工具Bruter文档翻译</title>
    <link href="http://phantom0301.github.io/2016/03/25/%E7%88%86%E7%A0%B4%E5%B7%A5%E5%85%B7Bruter%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    <id>http://phantom0301.github.io/2016/03/25/爆破工具Bruter文档翻译/</id>
    <published>2016-03-25T01:54:43.000Z</published>
    <updated>2016-03-25T01:56:44.630Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;说到爆破神器，kali中的msf爆破插件、hydra、medusa都足够强大，这里推荐一款win环境使用的爆破测试工具，bruter。&lt;/p&gt;
&lt;p&gt;仅仅翻译一下官方文档，bruter的所有说明文件都在目录的doc中。&lt;/p&gt;
&lt;h2 id=&quot;0x01-介绍&quot;&gt;&lt;a href=&quot;#0x01-介绍&quot; class=&quot;headerlink&quot; title=&quot;0x01 介绍&quot;&gt;&lt;/a&gt;0x01 介绍&lt;/h2&gt;&lt;p&gt;Bruter是一个多线程暴力破解器，这款工具的诞生是为了证明选择强口令的重要性（反正我是信了~~），我们的目标是支持多种允许远程登录认证的服务。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;警告：请记住，这款工具只能用于合法的目的&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x02-使用方法&quot;&gt;&lt;a href=&quot;#0x02-使用方法&quot; class=&quot;headerlink&quot; title=&quot;0x02 使用方法&quot;&gt;&lt;/a&gt;0x02 使用方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;连接选项，输入目标和选择协议的地方&lt;ol&gt;
&lt;li&gt;目标：可以输入ipv4和host，不支持批量操作&lt;/li&gt;
&lt;li&gt;协议：不同的协议有不同的选项，更多协议内容查看协议相关文档&lt;/li&gt;
&lt;li&gt;端口：一般会有默认端口号，也可以手动修改&lt;/li&gt;
&lt;li&gt;SSL：是否使用SSL，选择时端口号也相应会改变&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代理选项&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用代理：选择是否使用代理&lt;/li&gt;
&lt;li&gt;类型：支持HTTP、socks4、socks5代理&lt;/li&gt;
&lt;li&gt;让代理解析host：选择本地解析还是让代理决定&lt;/li&gt;
&lt;li&gt;端口：代理端口&lt;/li&gt;
&lt;li&gt;&lt;p&gt;要求认证：查看代理是否需要验证&lt;/p&gt;
&lt;p&gt; 注意： http连接只支持基础认证；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;socks5只支持用户名/密码认证
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;账号和密码：输入账号和密码的地方&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;爆破用户名选项&lt;ol&gt;
&lt;li&gt;输入用户名或者用户名列表路径。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;密码模式选项&lt;ol&gt;
&lt;li&gt;联合模式：当你的密码或列表输入使用username:password形式时，会自动去提取“：”后的password&lt;br&gt; 注意：会忽视username的内容；可以在选项里选择分隔符&lt;/li&gt;
&lt;li&gt;字典模式：正常的模式，可以输入单个密码或者列表路径，不同之处在于它可以变量替换，类似（%username%）的输入可以将爆破用到的所有用户名添加到密码中来。&lt;br&gt; 注意：空密码就用空字符，而不是用空格；由于替换规则，你用不了“%username%”这个密码；使用时会先加载全部密码到内存，所以密码字典不要太大&lt;/li&gt;
&lt;li&gt;暴力模式：根据提供的字符进行遍历&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;字典选项，使用字典模式附带的选项&lt;ol&gt;
&lt;li&gt;小写，转化所有输入为小写&lt;/li&gt;
&lt;li&gt;大写，转化所有输入为大写&lt;/li&gt;
&lt;li&gt;大写首字母&lt;/li&gt;
&lt;li&gt;翻转&lt;/li&gt;
&lt;li&gt;重复两次，将输入的admin，变为adminadmin&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;杂项选项&lt;ol&gt;
&lt;li&gt;连接数：设置进程数，win限制最大为64&lt;/li&gt;
&lt;li&gt;最大重试数：同一个用户密码尝试次数&lt;/li&gt;
&lt;li&gt;超时：整个破解过程使用多长时间&lt;/li&gt;
&lt;li&gt;重试时间：同一个用户密码尝试间隔时间&lt;/li&gt;
&lt;li&gt;重试时间：不同的用户密码尝试间隔时间&lt;/li&gt;
&lt;li&gt;最大接受连接数：有两个值，-1表示自动检测；0表示直到服务断开&lt;/li&gt;
&lt;li&gt;当发现有成功结果时是否停止&lt;/li&gt;
&lt;li&gt;密码优先：这个选项会使程序优先以密码去遍历用户名&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;显示区&lt;ol&gt;
&lt;li&gt;结果&lt;/li&gt;
&lt;li&gt;正在测试情况&lt;/li&gt;
&lt;li&gt;返回信息&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;状态栏&lt;ol&gt;
&lt;li&gt;第一列：当前任务状态&lt;/li&gt;
&lt;li&gt;第二列：每秒爆破数&lt;/li&gt;
&lt;li&gt;第三列：总测试数&lt;/li&gt;
&lt;li&gt;第四列：总用时&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;菜单&lt;ol&gt;
&lt;li&gt;文件：保存和退出&lt;/li&gt;
&lt;li&gt;设置：可以加载默认设置、保存设置、加载设置&lt;/li&gt;
&lt;li&gt;日志：选择输出的日志级别&lt;/li&gt;
&lt;li&gt;帮助：不用说了&lt;h2 id=&quot;0x03-后记&quot;&gt;&lt;a href=&quot;#0x03-后记&quot; class=&quot;headerlink&quot; title=&quot;0x03 后记&quot;&gt;&lt;/a&gt;0x03 后记&lt;/h2&gt;话说，3389的爆破工具都有哪些？以前似乎听说过一些，但是现在好像都销声匿迹了，是因为MS这方面防护做的更好了，3389爆破测试工具难以绕过一些规则吗？&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原创文章，转载请注明： 转载自零の杂货铺&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;说到爆破神器，kali中的msf爆破插件、hydra、medusa都足够强大，这里推荐一款win环境
    
    </summary>
    
      <category term="安全工具" scheme="http://phantom0301.github.io/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="bruter" scheme="http://phantom0301.github.io/tags/bruter/"/>
    
      <category term="爆破" scheme="http://phantom0301.github.io/tags/%E7%88%86%E7%A0%B4/"/>
    
  </entry>
  
  <entry>
    <title>反蜜罐技术学习</title>
    <link href="http://phantom0301.github.io/2016/03/23/%E5%8F%8D%E8%9C%9C%E7%BD%90%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    <id>http://phantom0301.github.io/2016/03/23/反蜜罐技术学习/</id>
    <published>2016-03-23T04:08:28.000Z</published>
    <updated>2016-03-23T04:14:08.959Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x00-写在最先&quot;&gt;&lt;a href=&quot;#0x00-写在最先&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在最先&quot;&gt;&lt;/a&gt;0x00 写在最先&lt;/h2&gt;&lt;p&gt;之前都在卖盾了，这次讲讲卖矛的故事。&lt;/p&gt;
&lt;p&gt;翻译自别人的文章，Neal Krawetz，hackerfactor网站的创建者，主要从事反垃圾邮件、计算机取证和安全方面的研究。&lt;/p&gt;
&lt;p&gt;还是一样，有错直接留言 ：）&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160323113106.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;有意思的插图，图侵删&lt;/p&gt;
&lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;垃圾邮件发送者经常扫描一些网络中开放的代理中继，通过代理，他们可以隐藏自己的原始IP。然而，假如他们不走运的遇到了蜜罐服务，蜜罐会收集一些有价值的信息，而这些信息可以帮助我们判断垃圾邮件散播者的真实身份，揭去他们的面具。&lt;/p&gt;
&lt;p&gt;作为对蜜罐的回应，第一个商业化的反蜜罐技术已经出现，Send-Safe的蜜罐猎人们试图为垃圾邮件发送工具找到安全的代理。这种蜜罐检测系统和其他新兴的垃圾邮件工具，呈现出三个重要的特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;蜜罐正在影响发送者&lt;/li&gt;
&lt;li&gt;目前的蜜罐技术是可检测的&lt;/li&gt;
&lt;li&gt;大多数蜜罐识别系统很相似&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不只是垃圾邮件的发送者会掌握这一技术，其他的恶意组织也会从相似的技术中受益，所以我们需要去研究反蜜罐技术，来改善目前的蜜罐技术。&lt;/p&gt;
&lt;h2 id=&quot;0x02-基础蜜罐服务&quot;&gt;&lt;a href=&quot;#0x02-基础蜜罐服务&quot; class=&quot;headerlink&quot; title=&quot;0x02 基础蜜罐服务&quot;&gt;&lt;/a&gt;0x02 基础蜜罐服务&lt;/h2&gt;&lt;p&gt;蜜罐按照一个看似有效的系统来设计。前面也说了，它使用这个模拟系统的外壳来收集攻击者的信息和方法。&lt;/p&gt;
&lt;p&gt;为了让自己伪装的更到位，蜜罐提供多种多样看似脆弱的系统。尽管如此的多样，但是总的来说，可以具体分为以下四级：最低限度、有限制、仿照模拟、完全一样。复杂度自然从低到高。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最低限度的服务，只是提供一个开放的服务端口&lt;/li&gt;
&lt;li&gt;有限制的服务，提供一些基础的交互&lt;/li&gt;
&lt;li&gt;仿照模拟的服务，提供一些复杂的交互&lt;/li&gt;
&lt;li&gt;完全真实一样，自然是提供一个真实的服务完整的支持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一些最低限度的服务会返回基本的连接头，但通常不会有更多细节的内容。一个最典型的例子就是模拟SMTP服务的蜜罐BOF，对于攻击，它只会返回一个“&lt;em&gt;503 Service Unavailable&lt;/em&gt;”&lt;/p&gt;
&lt;p&gt;最低限度服务通过增加一些少量的交互，就成了有限制的服务。有限制的服务可以呈现出基础交互的功能，即时没有认证机制可用。BOF蜜罐模拟的telnet服务就是这样，它会提示输入账号和密码，但没有运行任何登录机制。Niels Provos和他的研究组有一个网页介绍他们的honeyd项目&lt;a href=&quot;http://www.citi.umich.edu/u/provos/honeyd/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;戳这里&lt;/a&gt;，这个项目提供一系列有限制服务的蜜罐脚本，包括SMTP和简单的WEB代理。&lt;/p&gt;
&lt;p&gt;仿照模拟的服务呈现出一个完整的工作过程，但不是真实的。它会记录下行为，但不执行外部的操作。模拟服务接收登录和登陆后的一系列请求，会返回那些通常已知的标准回复和错误信息。比如那些仿真完整SMTP和微软IIS网页服务的脚本程序。&lt;/p&gt;
&lt;p&gt;和以上提到的虚拟蜜罐相比，完全真实的蜜罐服务很少见。他们不仅只是回复请求，它们还可以和恶意程序充分互动，甚至接收被破坏。大多数的完全蜜罐也会限制一些连接，这样可以防止这些真实蜜罐被攻破后作为Dos攻击的一部分。&lt;/p&gt;
&lt;p&gt;尽管crackers或者black—hat在攻击时会使用多个代理，大多数的垃圾邮件工具只支持单一代理。如果蜜罐伪装成代理，那么垃圾邮件发送者的真实IP就会暴露给蜜罐。我们可以用这些信息进行取证。&lt;/p&gt;
&lt;h2 id=&quot;0x03-垃圾邮件发送者的反击&quot;&gt;&lt;a href=&quot;#0x03-垃圾邮件发送者的反击&quot; class=&quot;headerlink&quot; title=&quot;0x03 垃圾邮件发送者的反击&quot;&gt;&lt;/a&gt;0x03 垃圾邮件发送者的反击&lt;/h2&gt;&lt;p&gt;垃圾邮件发送者通常是被动的，当工具失效时，他们只能换其他工具。举个例子，最早的反垃圾邮件技术使用哈希散列表过滤的方法来将每一封邮件内容加到一个散列表中。重复的散列表示重复的内容，这就意味着，它是重复被邮寄出去的。为了应对散列系统，垃圾邮件技术研究者们创造了哈希克星，可以通过生成不同字符串来改变哈希值。同样，时至今天，批量邮件发送工具使用反贝叶斯编码的方法来对抗贝叶斯过滤器。&lt;/p&gt;
&lt;p&gt;Send-Safe套件是一款被广泛使用的商业邮件批量发送工具套件，它的很多功能在垃圾邮件发送者眼里都很实用。它的代理扫描器可以发现很多开放的代理服务来隐藏发送者的身份；它的其他工具包括邮件校验器和生成大量即时信息的工具。&lt;/p&gt;
&lt;p&gt;这一套件最新的工具——“蜜罐猎人”，帮助垃圾邮件发送者识别他们需要警惕的蜜罐。工具的开发人员在工具描述中暗示了收到蜜罐影响的群体。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Send-Safe Honeypot&lt;br&gt;Hunter is a tool designed for&lt;br&gt;checking lists of HTTPS and&lt;br&gt;SOCKS proxies for so called&lt;br&gt;“honey pots”. “Honey pots”&lt;br&gt;are fake proxies run by the&lt;br&gt;people who are attempting to&lt;br&gt;frame bulkers by using those&lt;br&gt;fake proxies for logging traffic&lt;br&gt;through them and then send&lt;br&gt;complaints to ones’ ISPs.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以充分认识到垃圾邮件发送者不是唯一的蜜罐“受害者”。&lt;/p&gt;
&lt;p&gt;有一点我们必须意识到的是，垃圾邮件发送工具并没有使用什么独特的技术。使用副本和加密副本来增加分布是一种古老的IRC Dos攻击。我们可以通过查询发送邮件服务中的“VRFY”查询邮件发送的地址，这是一种常用的信息收集手段。&lt;/p&gt;
&lt;p&gt;蜜罐猎人使用的是网络“地下社团”众所周知的蜜罐检测方法，这些方法有很多，当然其中的一些也很复杂。一些开源的蜜罐项目在安装过程中有默认的固定回复，而安装者往往不会去改变这些默认信息，这就提供给攻击者一个辨识蜜罐的独特方法。其他的方法还有，已知程序的错误处理、操作系统指纹识别、TCP序列分析和ARP地址。&lt;/p&gt;
&lt;h2 id=&quot;0x03-蜜罐猎人干了什么？&quot;&gt;&lt;a href=&quot;#0x03-蜜罐猎人干了什么？&quot; class=&quot;headerlink&quot; title=&quot;0x03 蜜罐猎人干了什么？&quot;&gt;&lt;/a&gt;0x03 蜜罐猎人干了什么？&lt;/h2&gt;&lt;p&gt;蜜罐猎人被设计成可以测试开放的代理连接，对于回应进行定位分级，它把代理的等级分割为安全（好的代理），失效（不能用的代理），陷阱（蜜罐）三种。蜜罐猎人目前测试端口1080的Socks4和Socks5代理以及其他的http代理。&lt;/p&gt;
&lt;p&gt;蜜罐猎人会执行一系列简单的测试。首先,它打开了一个错误的邮件服务器在　　本地系统(端口25)测试代理连接,然后连接到代理服务器的端口。连接后,蜜罐猎人尝试返回到自己错误的邮件服务器。这样的方法足够识别那些无效的代理和蜜罐。另外,如果远程服务器声称已经成功连接,但蜜罐猎人的虚假邮件服务器没有收到连接,那么这个代理可能是蜜罐。&lt;/p&gt;
&lt;h2 id=&quot;0x03-对于蜜罐的影响&quot;&gt;&lt;a href=&quot;#0x03-对于蜜罐的影响&quot; class=&quot;headerlink&quot; title=&quot;0x03 对于蜜罐的影响&quot;&gt;&lt;/a&gt;0x03 对于蜜罐的影响&lt;/h2&gt;&lt;p&gt;影响是显而易见的，如果恶意用户可以检测到蜜罐，那么他们就可以绕过蜜罐。&lt;/p&gt;
&lt;p&gt;对于低交互的蜜罐，影响可能仅仅是少收集一些攻击信息。&lt;/p&gt;
&lt;p&gt;但更重要的是，如果攻击者可以检测出蜜罐，他们既可以针对蜜罐进行攻击。三个最基本的攻击方法是：利用、投毒和学习研究。研究者通常会把蜜罐放在临近关键网络的一个孤立的局域网中。通过利用的方式，可以让蜜罐成为内部攻击的跳台。当然，也可以利用蜜罐作为跳板攻击整个互联网。&lt;/p&gt;
&lt;p&gt;取代利用的手段还有投毒，通过将大量无用信息投掷给蜜罐，可以利用噪声掩盖住蜜罐中有价值的信息，使得其他恶意攻击者不被发现。&lt;/p&gt;
&lt;p&gt;第三种方式就是去学习蜜罐，通过收集蜜罐的信息，可以提供给攻击者一个观察蜜罐使用者的视角，包括收集蜜罐使用者的个人信息、作息习惯和技能水平。甚至于可以收集蜜罐使用组织的情况，比如一个使用ORACLE蜜罐的公司很有可能运行着真正的oracle数据服务，或者他就是该服务的提供商。&lt;/p&gt;
&lt;h2 id=&quot;0x04-后记&quot;&gt;&lt;a href=&quot;#0x04-后记&quot; class=&quot;headerlink&quot; title=&quot;0x04 后记&quot;&gt;&lt;/a&gt;0x04 后记&lt;/h2&gt;&lt;p&gt;文章的后半段讲述了如何对抗反蜜罐技术，这个不是我这次翻译的重点，就不在这里贴出来了，有兴趣的可以阅读原文。&lt;/p&gt;
&lt;p&gt;最后，作者总结道，由于反蜜罐技术的出现，很多蜜罐服务提供商都面临一些困境，总的来就是，蜜罐技术侦查的蜜月期已经结束，接下来的很长一段时间都将是蜜罐技术与反蜜罐技术互相斗法的阶段，无论你是旁观者，还是参与者，这样的对决一定有许多值得我们学习的地方。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-写在最先&quot;&gt;&lt;a href=&quot;#0x00-写在最先&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在最先&quot;&gt;&lt;/a&gt;0x00 写在最先&lt;/h2&gt;&lt;p&gt;之前都在卖盾了，这次讲讲卖矛的故事。&lt;/p&gt;
&lt;p&gt;翻译自别人的文章，Neal Kr
    
    </summary>
    
      <category term="蜜罐" scheme="http://phantom0301.github.io/categories/%E8%9C%9C%E7%BD%90/"/>
    
    
      <category term="蜜罐" scheme="http://phantom0301.github.io/tags/%E8%9C%9C%E7%BD%90/"/>
    
  </entry>
  
  <entry>
    <title>MHN学习笔记（二）Dionaea蜜罐架构</title>
    <link href="http://phantom0301.github.io/2016/03/17/MHN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Dionaea%E8%9C%9C%E7%BD%90%E6%9E%B6%E6%9E%84/"/>
    <id>http://phantom0301.github.io/2016/03/17/MHN学习笔记（二）Dionaea蜜罐架构/</id>
    <published>2016-03-17T10:51:04.000Z</published>
    <updated>2016-03-22T06:32:31.076Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;上次记录了学习hpfeeds协议的一些收获，这次将介绍开源项目中的一款模拟功能丰富的蜜罐——dionaea。&lt;/p&gt;
&lt;p&gt;百度、google、github一下dionaea，就能看到很多关于这个蜜罐的简介、使用情况以及对蜜罐捕获数据的分析。&lt;/p&gt;
&lt;p&gt;其实dionaea项目现在可以分成两种，一种是原生的dioanea蜜罐，另一种是经过MHN改造后的dionaea，两者的服务模拟、捕获数据构成等略有不同。不过，这两种dionaea蜜罐我都尝试搭建并成功运行。所以，这次我打算从代码构成的角度讲讲dionaea蜜罐。&lt;/p&gt;
&lt;p&gt;按照你能成功的方式安装好dionaea蜜罐后，dionaea文件夹下会有如下的几个文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dioanea
|-bin
|-etc
|-include
|-lib
|-share
|-var
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;bin：运行的主要程序的可执行文件&lt;/li&gt;
&lt;li&gt;etc：dionaea的配置文件&lt;/li&gt;
&lt;li&gt;include：各种系统的环境需求&lt;/li&gt;
&lt;li&gt;lib：库文件以及服务模拟文件存储文件夹&lt;/li&gt;
&lt;li&gt;var：蜜罐系统日志以及捕获数据的存储文件夹&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里，我会详细介绍配置文件和捕获数据文件&lt;/p&gt;
&lt;h2 id=&quot;0x02-配置文件&quot;&gt;&lt;a href=&quot;#0x02-配置文件&quot; class=&quot;headerlink&quot; title=&quot;0x02 配置文件&quot;&gt;&lt;/a&gt;0x02 配置文件&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;etc
|-dionaea
    |-dionaea.conf
    |-dionaea.conf.dist
    |-dionaea.conf.org
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;作为蜜罐的配置文件，这里对于蜜罐运行时加载的协议、文件存储的位置、监听的端口等做了详细的描述。&lt;/p&gt;
&lt;p&gt;第一个参数是logging，负责存储蜜罐运行过程中的默认日志和出错日志的路径和日志等级设定&lt;/p&gt;
&lt;p&gt;第二个参数是processors，负责加载几个对于捕获数据进行过滤的程序，包括二进制流、会话等&lt;/p&gt;
&lt;p&gt;第三个参数是download，负责恶意程序的下载路径&lt;/p&gt;
&lt;p&gt;第四个参数是bistreams，负责二进制流下载路径&lt;/p&gt;
&lt;p&gt;第五个参数submit，负责第三方数据提交&lt;/p&gt;
&lt;p&gt;第六个参数是listen，负责蜜罐监听ip的设置，有三种模式。getifaddrs模式监听所有ip，包括自己的127.0.0.1。manual模式允许用户设置不进行监听的ip。nl模式加载一个列表监听。&lt;/p&gt;
&lt;p&gt;第七个参数是modules，加载用到的模块，lib中服务模拟的python程序就会在这里加载，捕获数据入库也在这里进行设置&lt;/p&gt;
&lt;p&gt;从配置文件中，可以看出dionaea的许多功能都处于开发阶段，还有一部分功能被注释掉了，喜欢探索的高级玩家可以解开注释的封印，去试试dionaea的洪荒之力~~ 中二ing~~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;上次记录了学习hpfeeds协议的一些收获，这次将介绍开源项目中的一款模拟功能丰富的蜜罐——dion
    
    </summary>
    
      <category term="蜜罐" scheme="http://phantom0301.github.io/categories/%E8%9C%9C%E7%BD%90/"/>
    
    
      <category term="蜜罐" scheme="http://phantom0301.github.io/tags/%E8%9C%9C%E7%BD%90/"/>
    
  </entry>
  
  <entry>
    <title>nmap7完全指南</title>
    <link href="http://phantom0301.github.io/2016/03/11/nmap7%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://phantom0301.github.io/2016/03/11/nmap7完全指南/</id>
    <published>2016-03-11T02:50:07.000Z</published>
    <updated>2016-03-11T02:52:36.949Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x00-基本介绍&quot;&gt;&lt;a href=&quot;#0x00-基本介绍&quot; class=&quot;headerlink&quot; title=&quot;0x00 基本介绍&quot;&gt;&lt;/a&gt;0x00 基本介绍&lt;/h2&gt;&lt;p&gt;整合了官网和网上的一些资料，本来是有配图的，但是一想到可能会暴露一些敏感信息，就不摆在这了，不足之处，欢迎交流。&lt;/p&gt;
&lt;p&gt;Nmap现在最新的版本是Nmap 7。主要是增加了IPV6和ssl方面的支持。&lt;/p&gt;
&lt;p&gt;Nmap，全称Network Mapper，开源网络探测与审计框架。使用构造异常IP包的方式来探测主机服务。&lt;/p&gt;
&lt;p&gt;完整的Namp套件包括界面图形化的Zenmap，数据传输、重定向与调试工具Ncat，扫描结果比较器Ndiff以及数据包生成与响应工具Nping。&lt;/p&gt;
&lt;p&gt;最常规的Nmap组成指令为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nmap [扫描类型] [选项] [目标]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;0x02-参数-【目标】&quot;&gt;&lt;a href=&quot;#0x02-参数-【目标】&quot; class=&quot;headerlink&quot; title=&quot;0x02 参数-【目标】&quot;&gt;&lt;/a&gt;0x02 参数-【目标】&lt;/h2&gt;&lt;p&gt;目标参数可以输入域名、IP、网络等&lt;br&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;www.baidu.com
microsoft.com/24
192.168.0.1
10.0.0-255.1-254
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外还有如下参数可选：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;-iL &amp;lt;文件名&amp;gt;，从表单中读取扫描目标。&lt;/li&gt;
&lt;li&gt;-iR &amp;lt;主机数量&amp;gt;，选取随机扫描目标，私有段ip、多播ip、未分配使用的ip会被自动跳过，&lt;0&gt;可以指定一个无休止的扫描，如果在一个雨天的午后，你十分无聊的时候，可以运行。&lt;br&gt;&lt;code&gt;nmap -Pn -sS -p 80 -iR 0 --open&lt;/code&gt;&lt;/0&gt;&lt;/li&gt;
&lt;li&gt;–exclude &amp;lt;主机1&amp;gt;，&amp;lt;主机2&amp;gt;，跳过部分目标。&lt;/li&gt;
&lt;li&gt;–exclude &amp;lt;文件名&amp;gt;，从表单中读取跳过目标。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;0x03-参数-【主机发现】&quot;&gt;&lt;a href=&quot;#0x03-参数-【主机发现】&quot; class=&quot;headerlink&quot; title=&quot;0x03 参数-【主机发现】&quot;&gt;&lt;/a&gt;0x03 参数-【主机发现】&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;-sL，列表扫描，通过访问DNS的方式得到目标主机的ip。&lt;/li&gt;
&lt;li&gt;-sn，不进行端口扫描，ping scan。&lt;/li&gt;
&lt;li&gt;-Pn，不进行ping，强行扫描。&lt;/li&gt;
&lt;li&gt;-PS &amp;lt;端口列表&amp;gt;，TCP SYN Ping扫描端口&lt;/li&gt;
&lt;li&gt;-PA &amp;lt;端口列表&amp;gt;，TCP ACK Ping扫描端口&lt;/li&gt;
&lt;li&gt;-PU &amp;lt;端口列表&amp;gt;，UDP Ping&lt;/li&gt;
&lt;li&gt;-PY &amp;lt;端口列表&amp;gt;，SCTP INIT Ping&lt;/li&gt;
&lt;li&gt;-PE;-PP;-PM，ICMP Ping Types&lt;/li&gt;
&lt;li&gt;-PO &amp;lt;协议号&amp;gt;，IP Protocol Ping&lt;/li&gt;
&lt;li&gt;-PR，ARP Ping&lt;/li&gt;
&lt;li&gt;–disable-arp-pin 不使用ARP ping&lt;/li&gt;
&lt;li&gt;–traceroute 探测到达主机的Trace路径&lt;/li&gt;
&lt;li&gt;-n 不使用DNS结果&lt;/li&gt;
&lt;li&gt;-R 始终使用DNS结果&lt;/li&gt;
&lt;li&gt;–system-dns 使用系统的DNS解析，不请求域名服务器&lt;/li&gt;
&lt;li&gt;–dns-servers &amp;lt;服务1&amp;gt;,&amp;lt;服务2&amp;gt; 查询的DNS服务器队列&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_IP_protocol_numbers&quot; title=&quot;protocol_list&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://en.wikipedia.org/wiki/List_of_IP_protocol_numbers&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x04-参数-【端口扫描】&quot;&gt;&lt;a href=&quot;#0x04-参数-【端口扫描】&quot; class=&quot;headerlink&quot; title=&quot;0x04 参数-【端口扫描】&quot;&gt;&lt;/a&gt;0x04 参数-【端口扫描】&lt;/h2&gt;&lt;p&gt;使用六种状态描述端口状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;open，端口积极接收数据&lt;/li&gt;
&lt;li&gt;closed，无应用程序监听此端口&lt;/li&gt;
&lt;li&gt;filtered，端口难以抵达，无法准确判断&lt;/li&gt;
&lt;li&gt;unfiltered，端口可以抵达，无法准确判断&lt;/li&gt;
&lt;li&gt;open|filtered，两种状态不确定&lt;/li&gt;
&lt;li&gt;closed|filtered，两种状态不确定&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;-sS，TCP SYN scan，默认状态下的扫描模式，半开扫描，扫描快速，动静小。&lt;/li&gt;
&lt;li&gt;-sT，TCP connect scan，当没有原始数据包特权时使用，容易被发现。&lt;/li&gt;
&lt;li&gt;-sU，UDP scans，扫描UDP服务端口，DNS/SNMP/DHCP&lt;/li&gt;
&lt;li&gt;-sY，SCTP INIT scan，SCTP是一种较新的用来替代TCP和UDP的协议，类似于1&lt;/li&gt;
&lt;li&gt;-sN;-sF;-sX，TCP NULL, FIN, and Xmas scans，利用RFC 793的一些漏洞来判断端口状态。改变一些特殊标志的比特值。更加隐蔽，可以逃过一些防火墙，但是系统协议必须严格遵守RFC 793。&lt;/li&gt;
&lt;li&gt;-sA，TCP ACK scan，不用来判断端口是否打开，用来探测防火墙过滤规则&lt;/li&gt;
&lt;li&gt;-sW，TCP Window scan，类似ACK scan，增加不同系统的细节，但是结果不一定可信，甚至有可能正好相反。&lt;/li&gt;
&lt;li&gt;-sM，TCP Maimon scan，Uriel Maimon发现的一些BSD的系统在端口打开时会简单的终止包&lt;/li&gt;
&lt;li&gt;–scanflags，Custom TCP scan，自己通过TCP标志的设置构造自己的扫描，可以使用：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;*URG，紧急指针有效*

*ACK，确认序号有效*

*PSH，接收方应该尽快将这个报文段交给应用层*

*RST，重建连接*

*SYN，同步序号用来发起一个连接*

*FIN，发送端完成发送任务*
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;-sZ，SCTP COOKIE ECHO scan&lt;/li&gt;
&lt;li&gt;-sI &lt;zombie host=&quot;&quot;&gt;:&lt;probeport&gt;，idle scan，实现真正的盲扫，不会从你的真实IP发送包。使用边信道攻击实现僵尸机攻击。隐蔽性很好。&lt;/probeport&gt;&lt;/zombie&gt;&lt;/li&gt;
&lt;li&gt;-sO，IP protocol scan，ip协议扫描。&lt;/li&gt;
&lt;li&gt;-b，&amp;lt;主机&amp;gt;，FTP bounce scan，使用FTP代理扫描。因为使用FTP更容易绕过防火墙。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;SCTP（Stream Control Transmission Protocol，流控制传输协议）&lt;/p&gt;
&lt;p&gt;BSD (Berkeley Software Distribution，伯克利软件套件)是Unix的衍生系统&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0x05-参数-【端口号】&quot;&gt;&lt;a href=&quot;#0x05-参数-【端口号】&quot; class=&quot;headerlink&quot; title=&quot;0x05 参数-【端口号】&quot;&gt;&lt;/a&gt;0x05 参数-【端口号】&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;-p &amp;lt;端口范围&amp;gt;&lt;/li&gt;
&lt;li&gt;–exclude-ports &amp;lt;端口范围&amp;gt;&lt;/li&gt;
&lt;li&gt;-F，快速扫描常用端口，比默认的端口更少&lt;/li&gt;
&lt;li&gt;-r，按顺序扫描，默认情况下Nmap是随机扫描所指定的端口号的&lt;/li&gt;
&lt;li&gt;–port-ratio &amp;lt;比例&amp;gt;0-1之间，大于给的比例扫描servuces文件中的端口。&lt;/li&gt;
&lt;li&gt;–top-ports &amp;lt;数量&amp;gt;扫描指定数量的熟知端口&lt;h2 id=&quot;0x06-参数-【服务和版本检测】&quot;&gt;&lt;a href=&quot;#0x06-参数-【服务和版本检测】&quot; class=&quot;headerlink&quot; title=&quot;0x06 参数-【服务和版本检测】&quot;&gt;&lt;/a&gt;0x06 参数-【服务和版本检测】&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;-sV，服务版本检测&lt;/li&gt;
&lt;li&gt;–allports，版本检测不跳过任何端口，默认情况下会跳过TCP端口9100，因为一些打印机会打印传送到该端口的任何信息。&lt;/li&gt;
&lt;li&gt;–version-intensity &amp;lt;强度&amp;gt; 0-9，修改版本扫描检测强度。&lt;/li&gt;
&lt;li&gt;–version-light，强度2&lt;/li&gt;
&lt;li&gt;–version-all，强度9&lt;/li&gt;
&lt;li&gt;–version-trace，显示Nmap的版本识别过程&lt;h2 id=&quot;0x07-参数-【系统检测】&quot;&gt;&lt;a href=&quot;#0x07-参数-【系统检测】&quot; class=&quot;headerlink&quot; title=&quot;0x07 参数-【系统检测】&quot;&gt;&lt;/a&gt;0x07 参数-【系统检测】&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;-O 开启系统检测&lt;/li&gt;
&lt;li&gt;–osscan-limit，只检查一定条件的系统，有一个检测到的端口&lt;/li&gt;
&lt;li&gt;–osscan-guess，百分比显示可能的系统选项&lt;/li&gt;
&lt;li&gt;–max-os-tries，在未能匹配系统时，Nmap会重复检测5次，这个次数可以设置&lt;h2 id=&quot;0x08-参数-【NSE】&quot;&gt;&lt;a href=&quot;#0x08-参数-【NSE】&quot; class=&quot;headerlink&quot; title=&quot;0x08 参数-【NSE】&quot;&gt;&lt;/a&gt;0x08 参数-【NSE】&lt;/h2&gt;NSE,Nmap脚本引擎，Nmap里最强大最灵活的特性，允许用户编写LUA语言脚本实现各种测试任务。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前的脚本类别目录有：&lt;/p&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;auth，认证-目标系统身份验证
broadcast，广播-广播发现目标
brute，爆破-爆破身份验证
default，缺省-默认调用
discovery，发现-积极发现更多公共注册服务
dos，拒绝服务-DOS攻击
exploit，利用-利用一些漏洞
external，外部-会将数据发送给第三方
fuzzer，模糊测试-随机字段发送包，可以发现一些未被发现的漏洞
intrusive，侵入-风险过高的脚本
malware，恶意程序-测试目标是否被恶意程序感染
safe，安全-风险很低的脚本
version，版本-扩展版本检测功能，不能显式调用
vuln，漏洞-检测特定的已知漏洞
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;-sC，缺省脚本执行&lt;/li&gt;
&lt;li&gt;&lt;p&gt;–script &amp;lt;文件名&amp;gt;|&amp;lt;类别&amp;gt;|&amp;lt;目录&amp;gt;|&amp;lt;表达式&amp;gt;…，可以使用+来强制脚本运行，也可以用 &lt;em&gt;all&lt;/em&gt; 来遍历所有脚本，这两个选项要慎重使用&lt;/p&gt;
&lt;p&gt; nmap –script “http-*” 加载所有http前缀的脚本&lt;/p&gt;
&lt;p&gt; nmap –script “not intrusive”&lt;/p&gt;
&lt;p&gt; nmap –script “default or safe”&lt;/p&gt;
&lt;p&gt; nmap –script “default and safe”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;–script-args &amp;lt;脚本&amp;gt;=&amp;lt;参数&amp;gt;,给脚本提供参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;–script-args-file &amp;lt;文件名&amp;gt;，从文件提供参数&lt;/li&gt;
&lt;li&gt;–script-help &amp;lt;脚本名&amp;gt;，帮助&lt;/li&gt;
&lt;li&gt;–script-trace 打印脚本执行过程&lt;/li&gt;
&lt;li&gt;&lt;p&gt;–script-updatedb，升级脚本库&lt;/p&gt;
&lt;h2 id=&quot;0x09-参数-【时间与性能】&quot;&gt;&lt;a href=&quot;#0x09-参数-【时间与性能】&quot; class=&quot;headerlink&quot; title=&quot;0x09 参数-【时间与性能】&quot;&gt;&lt;/a&gt;0x09 参数-【时间与性能】&lt;/h2&gt;&lt;p&gt;时间单位：ms s m h&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;–min(max)-hostgroup &amp;lt;主机数&amp;gt;，调整并行扫描组主机数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;–min(max)-parallelism &amp;lt;探针数&amp;gt;，调整并行探针数。&lt;/li&gt;
&lt;li&gt;–min(max，initial)-rtt-timeout &amp;lt;时间&amp;gt;，调整探针超时时间&lt;/li&gt;
&lt;li&gt;–max-retries &amp;lt;数量&amp;gt;，指定端口扫描探针最大值，最大重试次数&lt;/li&gt;
&lt;li&gt;–host-timeout &amp;lt;时间&amp;gt;，放弃超时主机目标&lt;/li&gt;
&lt;li&gt;–scan-delay &amp;lt;时间&amp;gt;，调整探针之间的延迟时间&lt;/li&gt;
&lt;li&gt;–min(max)-rate &amp;lt;数字&amp;gt;，调整扫描速率，每秒发送的包数&lt;/li&gt;
&lt;li&gt;-T &lt;0-5&gt;时间模板，越大越快&lt;h2 id=&quot;0x10-参数-【防火墙IDS逃逸】&quot;&gt;&lt;a href=&quot;#0x10-参数-【防火墙IDS逃逸】&quot; class=&quot;headerlink&quot; title=&quot;0x10 参数-【防火墙IDS逃逸】&quot;&gt;&lt;/a&gt;0x10 参数-【防火墙IDS逃逸】&lt;/h2&gt;&lt;/0-5&gt;&lt;/li&gt;
&lt;li&gt;-f，分隔包碎片&lt;/li&gt;
&lt;li&gt;-mtu，指定偏移量分隔包碎片&lt;/li&gt;
&lt;li&gt;-D &amp;lt;诱饵&amp;gt;&amp;lt;,ME&amp;gt;，使用诱饵掩盖IP&lt;/li&gt;
&lt;li&gt;-S &amp;lt; IP &amp;gt;，伪造源地址IP&lt;/li&gt;
&lt;li&gt;-e &amp;lt; interface &amp;gt;，使用特定接口发送接收包&lt;/li&gt;
&lt;li&gt;–source-port &amp;lt; portnum &amp;gt;，伪造源端口号&lt;/li&gt;
&lt;li&gt;–data &amp;lt; hex string &amp;gt;，添加自定义二进制数据到发送包&lt;/li&gt;
&lt;li&gt;–data &amp;lt; string &amp;gt;，添加自定义字符串到发送包&lt;/li&gt;
&lt;li&gt;–data-length &amp;lt; num &amp;gt;，添加随机数据到发送包&lt;/li&gt;
&lt;li&gt;–ip-option &amp;lt; hex string &amp;gt;，用指定的IP选项发送数据包&lt;/li&gt;
&lt;li&gt;–ttl &amp;lt; value &amp;gt;，设置存活时间&lt;/li&gt;
&lt;li&gt;–randomize-hosts，随机主机目标顺序&lt;/li&gt;
&lt;li&gt;–spoof-mac &amp;lt; MAC,prefix,… &amp;gt;伪造MAC地址&lt;/li&gt;
&lt;li&gt;–proxies &amp;lt; URL &amp;gt;，通过代理链中继TCP连接&lt;/li&gt;
&lt;li&gt;–badsum，发送虚假校验和&lt;/li&gt;
&lt;li&gt;–adler32，使用另一种校验和代替CRC32C&lt;h2 id=&quot;0x11-参数-【输出】&quot;&gt;&lt;a href=&quot;#0x11-参数-【输出】&quot; class=&quot;headerlink&quot; title=&quot;0x11 参数-【输出】&quot;&gt;&lt;/a&gt;0x11 参数-【输出】&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;-oN &amp;lt; file &amp;gt;，正常输出&lt;/li&gt;
&lt;li&gt;-oX，XML输出&lt;/li&gt;
&lt;li&gt;-oS，脚本输出&lt;/li&gt;
&lt;li&gt;-oG，已弃用&lt;/li&gt;
&lt;li&gt;-oA，全格式&lt;/li&gt;
&lt;li&gt;-v &amp;lt; level &amp;gt;，增加Nmap输出普通信息水平&lt;/li&gt;
&lt;li&gt;-d &amp;lt; level &amp;gt;，增加调试信息输出水平&lt;/li&gt;
&lt;li&gt;–reason，给出原因&lt;/li&gt;
&lt;li&gt;–stats-every &amp;lt; time &amp;gt;，每过固定时间打印一次数据&lt;/li&gt;
&lt;li&gt;–packet-trace，数据包路径&lt;/li&gt;
&lt;li&gt;–open，显示打开的端口&lt;/li&gt;
&lt;li&gt;–iflist，列表接口和路径&lt;/li&gt;
&lt;li&gt;–append-output，结果添加到输出&lt;/li&gt;
&lt;li&gt;–resume &lt;filename&gt;，恢复终止的扫描&lt;h2 id=&quot;0x12-参数-【混合选项】&quot;&gt;&lt;a href=&quot;#0x12-参数-【混合选项】&quot; class=&quot;headerlink&quot; title=&quot;0x12 参数-【混合选项】&quot;&gt;&lt;/a&gt;0x12 参数-【混合选项】&lt;/h2&gt;&lt;/filename&gt;&lt;/li&gt;
&lt;li&gt;-6，开启IPv6扫描&lt;/li&gt;
&lt;li&gt;-A，积极扫描策略（-O，-sV，-sC，–traceroute）&lt;/li&gt;
&lt;li&gt;–datadir &amp;lt; directoryname &amp;gt; 指定Nmap数据文件&lt;/li&gt;
&lt;li&gt;–servicedb &amp;lt; services file &amp;gt;，指定Nmap服务库&lt;/li&gt;
&lt;li&gt;–versiondb &amp;lt; service probes file &amp;gt;，指定版本库&lt;/li&gt;
&lt;li&gt;–release-memory，推出前释放内存&lt;/li&gt;
&lt;li&gt;-V，显示版本号&lt;br&gt;参考：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;http://nmap.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://nmap.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.91ri.org/4105.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实战高级用法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.91ri.org/3870.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;绕过防火墙与脚本使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原创文章，转载请注明： 转载自零の杂货铺&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-基本介绍&quot;&gt;&lt;a href=&quot;#0x00-基本介绍&quot; class=&quot;headerlink&quot; title=&quot;0x00 基本介绍&quot;&gt;&lt;/a&gt;0x00 基本介绍&lt;/h2&gt;&lt;p&gt;整合了官网和网上的一些资料，本来是有配图的，但是一想到可能会暴露一些敏感信息，就不摆
    
    </summary>
    
      <category term="安全工具" scheme="http://phantom0301.github.io/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="namp" scheme="http://phantom0301.github.io/tags/namp/"/>
    
  </entry>
  
  <entry>
    <title>博客搬家</title>
    <link href="http://phantom0301.github.io/2016/03/02/%E5%8D%9A%E5%AE%A2%E6%90%AC%E5%AE%B6/"/>
    <id>http://phantom0301.github.io/2016/03/02/博客搬家/</id>
    <published>2016-03-02T02:46:27.000Z</published>
    <updated>2016-03-11T02:47:30.515Z</updated>
    
    <content type="html">&lt;p&gt;gitcafe博客&lt;strong&gt;搬家&lt;/strong&gt;了~~&lt;/p&gt;
&lt;p&gt;之前把博客部署在gitcafe和github上，不过最近得到了通知，gitcafe和coding合作了，原来在gitcafe上的服务到今年的5月份就停了。&lt;/p&gt;
&lt;p&gt;所以只能把原来部署在cafe上的博客移交到coding了&lt;/p&gt;
&lt;p&gt;现在有两个稳定可访问的域名：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://phantom0301.github.io&quot; title=&quot;phantom0301.github.io&quot;&gt;phantom0301.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://phantom0301.coding.io&quot; title=&quot;phantom0301.coding.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;phantom0301.coding.io&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;gitcafe博客&lt;strong&gt;搬家&lt;/strong&gt;了~~&lt;/p&gt;
&lt;p&gt;之前把博客部署在gitcafe和github上，不过最近得到了通知，gitcafe和coding合作了，原来在gitcafe上的服务到今年的5月份就停了。&lt;/p&gt;
&lt;p&gt;所以只能把原来部署在caf
    
    </summary>
    
      <category term="感悟" scheme="http://phantom0301.github.io/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="感悟" scheme="http://phantom0301.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>HEXO+github搭建博客总结</title>
    <link href="http://phantom0301.github.io/2016/02/20/HEXO+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93/"/>
    <id>http://phantom0301.github.io/2016/02/20/HEXO+github搭建博客总结/</id>
    <published>2016-02-20T08:21:27.000Z</published>
    <updated>2016-02-21T04:45:32.306Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;用hexo+github搭建个人博客，有许多坑值得去填，这里就把从各个博客学到的填坑方式在这里说一下。&lt;/p&gt;
&lt;p&gt;另外，有许多资料都是针对hexo2.x版本的，我现在的版本是3.1.1。查找资料的时候一定要注意。这里只是列出问题查找的方向，根据这个方向更便于在网上找到解决的方法。&lt;/p&gt;
&lt;h2 id=&quot;0x01-准备&quot;&gt;&lt;a href=&quot;#0x01-准备&quot; class=&quot;headerlink&quot; title=&quot;0x01 准备&quot;&gt;&lt;/a&gt;0x01 准备&lt;/h2&gt;&lt;p&gt;1.github账号：安装git，申请github账号，设置好ssh。再新建一个项目，然后在项目的setting中设置为个人页面。&lt;/p&gt;
&lt;p&gt;2.安装node.js，使用npm命令安装hexo，后面还会大量的用到npm来安装。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g hexo
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;0x02-搭建基本框架&quot;&gt;&lt;a href=&quot;#0x02-搭建基本框架&quot; class=&quot;headerlink&quot; title=&quot;0x02 搭建基本框架&quot;&gt;&lt;/a&gt;0x02 搭建基本框架&lt;/h2&gt;&lt;p&gt;在本地电脑新建一个文件夹a，在a里使用git bash初始化一个hexo项目。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo init
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时会生成许多文件夹，在输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装一些必要包。&lt;/p&gt;
&lt;p&gt;执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo generate
hexo server -p 8080
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时候应该可以在本地用&lt;a href=&quot;http://localhost:8080打开原始框架页面了&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:8080打开原始框架页面了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;-p后面的端口要根据自己的情况来写，网上大多使用默认的4000，可是我的4000端口已经用了，这样就会导致网页打不开。&lt;/p&gt;
&lt;p&gt;在本地打开成功后，就可以开始上传到github上了。&lt;/p&gt;
&lt;p&gt;打开a里的_config.yml,推荐使用sublime，如果使用其他工具，请注意要保存时格式应为&lt;strong&gt;utf-8&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找到deploy一栏，修改如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;deploy:
  type: git
  repository: https://github.com/你的github名/你的github名.github.io.git
  branch: master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意，这里作为个人页面的github项目一定要和用户名相同。&lt;/p&gt;
&lt;p&gt;然后在git bash中输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo deploy
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里注意有两种deploy的方式，&lt;a href=&quot;https://的方式会要求你输入github的账号密码；ssh的方式只要事先设置好密钥就不再需要多余的操作了。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://的方式会要求你输入github的账号密码；ssh的方式只要事先设置好密钥就不再需要多余的操作了。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这时，就可以用&lt;strong&gt;你的github名.github.io&lt;/strong&gt;来访问&lt;/p&gt;
&lt;h2 id=&quot;0x03-打磨博客&quot;&gt;&lt;a href=&quot;#0x03-打磨博客&quot; class=&quot;headerlink&quot; title=&quot;0x03 打磨博客&quot;&gt;&lt;/a&gt;0x03 打磨博客&lt;/h2&gt;&lt;p&gt;1.发表博文&lt;br&gt;使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo new “文章名”
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;新建博文，这时会在a/source/_post下生成相应的.md文件，打开编辑。&lt;br&gt;在——下面就可以使用markdown语法写博文。&lt;/p&gt;
&lt;p&gt;写好后，保存，执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo generate
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就可以在a/public中相应的位置生成博文。&lt;/p&gt;
&lt;p&gt;那么以后的程式化操作就是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo new “  ” 写博文
hexo clean 清除public
hexo generate 编译
hexo server -p 8080 本地测试
hexo deploy 部署到远程服务器
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.装饰博客&lt;br&gt;基本框架布置好，装饰的事大家就各显神通了。&lt;/p&gt;
&lt;p&gt;通常会在以下几个点进行修改&lt;/p&gt;
&lt;p&gt;a/_config.yml&lt;/p&gt;
&lt;p&gt;这里修改博客主页的名字，源信息，子页面url格式等&lt;/p&gt;
&lt;p&gt;最重要的是主题的选用，插件的使用都在这里编辑完成。&lt;br&gt;如果你要使用rss、sitemap、更改deploy的对象就需要在这里修改&lt;/p&gt;
&lt;p&gt;a/themes/&lt;br&gt;存放你找来的各种主题b、c、d……&lt;/p&gt;
&lt;p&gt;a/themes/b/_config.yml&lt;br&gt;负责单个主题的框架修改，&lt;br&gt;包括网页的logo图片选择、框架中主菜单显示的文本及连接&lt;/p&gt;
&lt;p&gt;a/public&lt;br&gt;静态生成的网页，也就是会上传到github上的文件。&lt;/p&gt;
&lt;p&gt;网上有很多教程，而且如果前面都部署成功了，后面就可以自己慢慢geek了&lt;/p&gt;
&lt;h2 id=&quot;0x04-其他的一些坑&quot;&gt;&lt;a href=&quot;#0x04-其他的一些坑&quot; class=&quot;headerlink&quot; title=&quot;0x04 其他的一些坑&quot;&gt;&lt;/a&gt;0x04 其他的一些坑&lt;/h2&gt;&lt;p&gt;github的博客可以被google站长收录，但是baidu被禁止爬去github，所以，如果想让baidu也能搜得到你，就部署在gitcafe上。&lt;/p&gt;
&lt;p&gt;如果hexo generate报错，多半是两个地方的_config.yml更改的有问题，所以一是要备份yml文件或者从git上拉取之前部署成功的文件，二是要边改边generate在本地查看，一点点琢磨不同位置的属性。&lt;/p&gt;
&lt;p&gt;a/_config.yml中的url设置如果没有购买域名的话，看似没有作用，但会影响生成的sitemap中的路径，所以在多个平台（github、gitcafe）部署的时候，不仅要修改deploy，还要根据需要修改url。&lt;/p&gt;
&lt;p&gt;否则，即便sitemap能被百度站长工具访问到，也会提示说 &lt;strong&gt;主域验证错误&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为是事后总结，暂时想到的就这么多，其他还有什么安装过程中的问题可以直接博客留言，&lt;strong&gt;见即回 &lt;/strong&gt;  ：）&lt;/p&gt;
&lt;p&gt;原创文章，转载请注明： 转载自零の杂货铺&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;用hexo+github搭建个人博客，有许多坑值得去填，这里就把从各个博客学到的填坑方式在这里说一下
    
    </summary>
    
      <category term="HEXO" scheme="http://phantom0301.github.io/categories/HEXO/"/>
    
    
      <category term="HEXO" scheme="http://phantom0301.github.io/tags/HEXO/"/>
    
      <category term="个人博客" scheme="http://phantom0301.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>MHN开源蜜罐项目学习笔记（一）HPFEEDS协议</title>
    <link href="http://phantom0301.github.io/2016/02/19/MHN%E5%BC%80%E6%BA%90%E8%9C%9C%E7%BD%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89HPFEEDS%E5%8D%8F%E8%AE%AE/"/>
    <id>http://phantom0301.github.io/2016/02/19/MHN开源蜜罐项目学习笔记（一）HPFEEDS协议/</id>
    <published>2016-02-19T09:13:55.000Z</published>
    <updated>2016-04-20T01:48:22.422Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x00-hpfeeds协议是什么？&quot;&gt;&lt;a href=&quot;#0x00-hpfeeds协议是什么？&quot; class=&quot;headerlink&quot; title=&quot;0x00 hpfeeds协议是什么？&quot;&gt;&lt;/a&gt;0x00 hpfeeds协议是什么？&lt;/h2&gt;&lt;p&gt;feeds，供稿，原始数据。&lt;/p&gt;
&lt;p&gt;hpfeeds是一个轻量级的验证发布-订阅协议(authenticated publish-subscribe protocol)。&lt;/p&gt;
&lt;p&gt;轻量级好理解，就是代码量相对较少，功能相对不复杂。那什么是发布-订阅协议呢？订阅发布协议定义了一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。它是为了解决这样一种情况的发生，一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象需要改变。我的理解，这就类似于发传单，目标发送通知，没有指定特定的对象，通知会自动传播，观察者自己决定是否需要看传单，发送者对于传单是否被看一无所知。&lt;/p&gt;
&lt;p&gt;详细的发布订阅者介绍可以戳这里：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ff649664.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://msdn.microsoft.com/en-us/library/ff649664.aspx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;线路协议组成如下：&lt;/p&gt;
&lt;p&gt;首先是消息头：有两个参数，消息总长和消息类型&lt;/p&gt;
&lt;p&gt;消息类型有以下几种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error (0): errormessage
info (1): server name, nonce
auth (2): client id, sha1(nonce+authkey)
publish (3): client id, channelname, payload
subscribe (4): client id, channelname
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;数字代表消息类型，而冒号后面的内容则代表后续的消息字段&lt;/p&gt;
&lt;p&gt;比如说当消息类型为3，publish时，后面的字段就会有四个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;client id的长度
client id
channelname的长度
channelname
payload
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个完整的消息如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;length | opcode | next | identifier | next | channelname|payload
----------------------------------------------------------------
85       3        9       b4aa2@hp1   9      mwcapture      137941a3d8589f6728924c08561070bceb5d72b8,http://1.2.3.4/calc.exe
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;消息有了，整个消息的认证过程就是以下的几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;服务器为每一个连接生成一个标志&lt;/li&gt;
&lt;li&gt;客户端发送id 和 标志+authkey组成的sha1&lt;/li&gt;
&lt;li&gt;服务器检查id和sha1&lt;/li&gt;
&lt;li&gt;服务器检查数据类型，是要发布还是要订阅&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最终实现服务器、发布者、订阅者之间的解耦，彼此之间完全独立，互不干扰。&lt;/p&gt;
&lt;h2 id=&quot;0x01-为什么要用hpfeeds协议&quot;&gt;&lt;a href=&quot;#0x01-为什么要用hpfeeds协议&quot; class=&quot;headerlink&quot; title=&quot;0x01 为什么要用hpfeeds协议&quot;&gt;&lt;/a&gt;0x01 为什么要用hpfeeds协议&lt;/h2&gt;&lt;p&gt;首先，正如以上所说的，整个协议实现了三方的功能独立。使用这种方式降低了应用与业务逻辑之间的耦合，统一一个对外的发布接口，只需要关心监听的类型，不关心监听的具体处理人。只管发，不管到不到。很方便的建立一种一对多的依赖关系。&lt;/p&gt;
&lt;p&gt;在当一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象需要改变时，就可以使用订阅发布模式。&lt;/p&gt;
&lt;p&gt;hpfeeds协议希望能够实现一个单一的连线形式，使得每一个人都可以在任何时间以任何语言去订阅发布数据，不同的数据以通道来划分，由通道的使用者来决定数据结构形式。而通道的验证通过authkey来完成，它由两部分组成，ident和secret，相当于身份和密码。密码在hash后和每一个临时连接标志一起发送给服务器，这样保证不会被窃听，所以它可以运行在SSL、TLS下。&lt;/p&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.降低耦合。发布者对于接收者的数量，身份，接收的数据类型一无所知。&lt;/li&gt;
&lt;li&gt;2.安全性高。只有消息订阅者之间的单线信息交互，不存在其他程序的信息交换。&lt;/li&gt;
&lt;li&gt;3.测试方便。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;p&gt;性能降低，订阅要进行管理&lt;/p&gt;
&lt;h2 id=&quot;0x02-如何操作&quot;&gt;&lt;a href=&quot;#0x02-如何操作&quot; class=&quot;headerlink&quot; title=&quot;0x02 如何操作&quot;&gt;&lt;/a&gt;0x02 如何操作&lt;/h2&gt;&lt;p&gt;正常安装使用hpfeeds的步骤如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/rep/hpfeeds/
cd hpfeeds
python setup.py build
python setup.py install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装成功后，会出现下面几个文件夹。&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;appsuport：hpfeeds支持的一些蜜罐的应用程序&lt;/li&gt;
&lt;li&gt;broker：服务器功能程序集，包括增加用户，服务器运行，查看所有用户信息等&lt;/li&gt;
&lt;li&gt;build：一些编译环境&lt;/li&gt;
&lt;li&gt;cli：用户程序&lt;/li&gt;
&lt;li&gt;example：例程&lt;/li&gt;
&lt;li&gt;lib：支持库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用时先打开broker，运行其中的add_user.py添加用户信息：&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;根据提示信息，我们添加用户test，密码123456，拥有发布频道1，2，无订阅频道&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;再添加用户custom，密码123456，拥有订阅频道1，2，无发布频道&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;现在使用dump_users.py查看刚才创建的用户&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图所示，这里应经可以查看到刚才我们新建的用户了。&lt;/p&gt;
&lt;p&gt;接下来，我们打开服务器feedbroker.py&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;再开启一个新的进程运行cli文件夹里的用户程序hpfeeds-client&lt;/p&gt;
&lt;p&gt;先开启订阅者custom，使用1频道&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/7.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;此时，服务器端显示用户登录成功&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/8.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们再打开一个新的进程，以发布者test，使用1频道发布“helloworld”&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到发布者一旦发布完消息后，立即退出进程，并不确认消息是否收到&lt;/p&gt;
&lt;p&gt;这时，服务器显示test登录成功&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/10.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;于此同时，订阅者custom成功接收到消息&lt;br&gt;&lt;img src=&quot;http://7xr3oj.com1.z0.glb.clouddn.com/11.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;到此，一次完整的发送、接收消息的流程就走完了。&lt;/p&gt;
&lt;p&gt;通过这一过程，我们发现，频道与用户分离，发送和订阅者身份平等，只需订阅者实时监听，发送者可以即时发送即时撤出。&lt;/p&gt;
&lt;p&gt;这里是对于hpfeeds协议的简单介绍，下一部分我会从代码的角度进一步分析该协议，并适当对于协议功能进行添加。&lt;/p&gt;
&lt;p&gt;原创文章，转载请注明： 转载自零の杂货铺&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-hpfeeds协议是什么？&quot;&gt;&lt;a href=&quot;#0x00-hpfeeds协议是什么？&quot; class=&quot;headerlink&quot; title=&quot;0x00 hpfeeds协议是什么？&quot;&gt;&lt;/a&gt;0x00 hpfeeds协议是什么？&lt;/h2&gt;&lt;p&gt;feeds，
    
    </summary>
    
      <category term="蜜罐" scheme="http://phantom0301.github.io/categories/%E8%9C%9C%E7%BD%90/"/>
    
    
      <category term="MHN" scheme="http://phantom0301.github.io/tags/MHN/"/>
    
      <category term="hpfeeds" scheme="http://phantom0301.github.io/tags/hpfeeds/"/>
    
      <category term="蜜罐" scheme="http://phantom0301.github.io/tags/%E8%9C%9C%E7%BD%90/"/>
    
  </entry>
  
  <entry>
    <title>PyMongo官方文档翻译</title>
    <link href="http://phantom0301.github.io/2016/02/19/PyMongo%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    <id>http://phantom0301.github.io/2016/02/19/PyMongo官方文档翻译/</id>
    <published>2016-02-19T09:00:36.000Z</published>
    <updated>2016-02-21T04:45:56.579Z</updated>
    
    <content type="html">&lt;p&gt;最近做的几个项目都用到了Python+MongoDB，好像更新一版的Mongo刚刚发布。既然是使用python，肯定是绕不过Pymongo库了，先从官方文档看起。&lt;/p&gt;
&lt;p&gt;想练习英语的戳这里~&lt;a href=&quot;http://api.mongodb.org/python/current/tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://api.mongodb.org/python/current/tutorial.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;教程&quot;&gt;&lt;a href=&quot;#教程&quot; class=&quot;headerlink&quot; title=&quot;教程&quot;&gt;&lt;/a&gt;教程&lt;/h2&gt;&lt;p&gt;本教程旨在介绍使用MongoDB和PyMongo&lt;/p&gt;
&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;安装&lt;strong&gt;PyMongo&lt;/strong&gt;模块，&lt;strong&gt;MongoDB&lt;/strong&gt;数据库。&lt;br&gt;恩，在python的shell里，下面这句话没报错就算安装成功了（废话~）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;import pymongo
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;本教程还假设MongoDB实例运行在默认的主机（127.0.0.1）和端口（27017）。假设您已经下载并安装MongoDB,您可以启动它就像这样:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mongod
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;使用MongoClient完成数据库连接&quot;&gt;&lt;a href=&quot;#使用MongoClient完成数据库连接&quot; class=&quot;headerlink&quot; title=&quot;使用MongoClient完成数据库连接&quot;&gt;&lt;/a&gt;使用MongoClient完成数据库连接&lt;/h2&gt;&lt;p&gt;第一步就是使用PyMongo中的MongoClient来完成程序和数据库之间的连接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from pymongo import MongoClient
&amp;gt;&amp;gt;&amp;gt; client = MongoClient()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码将在默认的主机和端口连接。我们也可以显式地指定主机和端口,如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; client = MongoClient(&amp;apos;localhost&amp;apos;, 27017)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以使用另一种形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; client = MongoClient(&amp;apos;mongodb://localhost:27017/&amp;apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;获得数据库&quot;&gt;&lt;a href=&quot;#获得数据库&quot; class=&quot;headerlink&quot; title=&quot;获得数据库&quot;&gt;&lt;/a&gt;获得数据库&lt;/h2&gt;&lt;p&gt;MongoDB的单个实例可以支持多个独立的数据库。PyMongo支持使用属性的形式来获得数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; db = client.test_database
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果上面的形式无法访问到数据库，可以采用另一种字典的形式来访问：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; db = client[&amp;apos;test-database&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;获得集合&quot;&gt;&lt;a href=&quot;#获得集合&quot; class=&quot;headerlink&quot; title=&quot;获得集合&quot;&gt;&lt;/a&gt;获得集合&lt;/h2&gt;&lt;p&gt;集合是MongoDB中存储的一组文档，可以类比为关系型数据库中的表，获得集合的方式与获得数据库方式相同&lt;/p&gt;
&lt;p&gt;拥有两种方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; collection = db.test_collection
&amp;gt;&amp;gt;&amp;gt; collection = db[&amp;apos;test-collection&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;值得注意的是，集合和库在MongoDB中的创建是松散的，以上命令实际上并没有在服务器端做任何操作。&lt;/p&gt;
&lt;p&gt;当有文档（数据）插入到里面的时候，集合和库才被创建。&lt;/p&gt;
&lt;h2 id=&quot;文档（数据）&quot;&gt;&lt;a href=&quot;#文档（数据）&quot; class=&quot;headerlink&quot; title=&quot;文档（数据）&quot;&gt;&lt;/a&gt;文档（数据）&lt;/h2&gt;&lt;p&gt;MongoDB中的数据使用（存储为）JSON格式文件。在PyMongo中使用字典来表示这种结构。&lt;/p&gt;
&lt;p&gt;举个栗子,下面的字典可以用来代表一篇博文:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import datetime
&amp;gt;&amp;gt;&amp;gt; post = {&amp;quot;author&amp;quot;: &amp;quot;Mike&amp;quot;,
... &amp;quot;text&amp;quot;: &amp;quot;My first blog post!&amp;quot;,
... &amp;quot;tags&amp;quot;: [&amp;quot;mongodb&amp;quot;, &amp;quot;python&amp;quot;, &amp;quot;pymongo&amp;quot;],
... &amp;quot;date&amp;quot;: datetime.datetime.utcnow()}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意,文档可以包含本地Python类型(如datetime.datetime实例),这些会自动转换为合适的BSON类型。&lt;/p&gt;
&lt;h2 id=&quot;插入文件&quot;&gt;&lt;a href=&quot;#插入文件&quot; class=&quot;headerlink&quot; title=&quot;插入文件&quot;&gt;&lt;/a&gt;插入文件&lt;/h2&gt;&lt;p&gt;要插入一个文件到集合中，我们可以使用insert_one( )方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; posts = db.posts
&amp;gt;&amp;gt;&amp;gt; post_id = posts.insert_one(post).inserted_id
&amp;gt;&amp;gt;&amp;gt; post_id
ObjectId(&amp;apos;...&amp;apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果插入的文档没有“_id”这个键的话，系统会自动给它加上。“_id”键的值在整个集合中是唯一的（有点主键的意思）。insert _one( )返回一个InsertOneResult的实例。更多关于”_id“的信息，参阅 _id。&lt;/p&gt;
&lt;p&gt;在插入第一个文档后，集合就真正在服务器上创建。通过列出库中所有的集合，我们可以验证这一点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; db.collection_names(include_system_collections=False)
[u&amp;apos;posts&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;通过find-one-获取单个文档&quot;&gt;&lt;a href=&quot;#通过find-one-获取单个文档&quot; class=&quot;headerlink&quot; title=&quot;通过find_one( )获取单个文档&quot;&gt;&lt;/a&gt;通过find_one( )获取单个文档&lt;/h2&gt;&lt;p&gt;最基本的可以执行的查询类型有find_one( )。这个方法根据查询返回一个匹配的文档。如果没有匹配就返回None。&lt;/p&gt;
&lt;p&gt;对于只有单一匹配或者只对第一个匹配感兴趣的情况下，可以选用这种方法。下面是一个获取第一个文档的栗子~&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; posts.find_one()
{u&amp;apos;date&amp;apos;: datetime.datetime(...), u&amp;apos;text&amp;apos;: u&amp;apos;My first blog post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;mongodb&amp;apos;, u&amp;apos;python&amp;apos;, u&amp;apos;pymongo&amp;apos;]}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果是我们之前插入的那个注意到返回结果中”_id”这个键是自动加入的。&lt;br&gt;find_one()也支持特定的结果匹配。比如我们用作者”Mike”来限制返回的查找结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; posts.find_one({&amp;quot;author&amp;quot;: &amp;quot;Mike&amp;quot;})
{u&amp;apos;date&amp;apos;: datetime.datetime(...), u&amp;apos;text&amp;apos;: u&amp;apos;My first blog post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;mongodb&amp;apos;, u&amp;apos;python&amp;apos;, u&amp;apos;pymongo&amp;apos;]}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果我们用另一个文档中不存在的字典“Eliot”来查找，将得不到结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; posts.find_one({&amp;quot;author&amp;quot;: &amp;quot;Eliot&amp;quot;})
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;通过对象ID查询&quot;&gt;&lt;a href=&quot;#通过对象ID查询&quot; class=&quot;headerlink&quot; title=&quot;通过对象ID查询&quot;&gt;&lt;/a&gt;通过对象ID查询&lt;/h2&gt;&lt;p&gt;我们也可以通过“_id”来查找&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; post_id
ObjectId(...)
&amp;gt;&amp;gt;&amp;gt; posts.find_one({&amp;quot;_id&amp;quot;: post_id})
{u&amp;apos;date&amp;apos;: datetime.datetime(...), u&amp;apos;text&amp;apos;: u&amp;apos;My first blog post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;mongodb&amp;apos;, u&amp;apos;python&amp;apos;, u&amp;apos;pymongo&amp;apos;]}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意，对象ID不是一个字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; post_id_as_str = str(post_id)
&amp;gt;&amp;gt;&amp;gt; posts.find_one({&amp;quot;_id&amp;quot;: post_id_as_str}) # No result
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;web应用程序中的一个常见任务是从URL得到对象ID,找到匹配的文档。&lt;br&gt;这种情况下，需要将对象ID从字符串类型转换到ObjectId(符合find_one格式的类型):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from bson.objectid import ObjectId
# The web framework gets post_id from the URL and passes it as a string
def get(post_id):
# Convert from string to ObjectId:
document = client.db.collection.find_one({&amp;apos;_id&amp;apos;: ObjectId(post_id)})
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;UNICODE字符串注意&quot;&gt;&lt;a href=&quot;#UNICODE字符串注意&quot; class=&quot;headerlink&quot; title=&quot;UNICODE字符串注意&quot;&gt;&lt;/a&gt;UNICODE字符串注意&lt;/h2&gt;&lt;p&gt;你可能注意到，服务器中得到的数据和常规的Python字符串不太一样（例如用u’Mike’来代替’Mike’）&lt;/p&gt;
&lt;p&gt;这是因为我们的数据库以BSON的格式存储数据。这种格式采用UTF-8编码，所以PyMongo需要确保所有&lt;/p&gt;
&lt;p&gt;存储的字符串包含唯一可用的UTF-8数据。基于此，PyMongo解码每一个BSON字符为Python的unicode字符，而不是常见的字符串。&lt;/p&gt;
&lt;h2 id=&quot;批量插入&quot;&gt;&lt;a href=&quot;#批量插入&quot; class=&quot;headerlink&quot; title=&quot;批量插入&quot;&gt;&lt;/a&gt;批量插入&lt;/h2&gt;&lt;p&gt;为了使查询更加有趣,让我们插入更多的文档。&lt;/p&gt;
&lt;p&gt;除了插入一个文档,我们也可以执行批量插入操作,&lt;br&gt;通过insert_many插入列表的方式，可以插入列表中的每一个文档，而只向服务器发送一次指令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; new_posts = [{&amp;quot;author&amp;quot;: &amp;quot;Mike&amp;quot;,
...   &amp;quot;text&amp;quot;: &amp;quot;Another post!&amp;quot;,
...   &amp;quot;tags&amp;quot;: [&amp;quot;bulk&amp;quot;, &amp;quot;insert&amp;quot;],
...   &amp;quot;date&amp;quot;: datetime.datetime(2009, 11, 12, 11, 14)},
...  {&amp;quot;author&amp;quot;: &amp;quot;Eliot&amp;quot;,
...   &amp;quot;title&amp;quot;: &amp;quot;MongoDB is fun&amp;quot;,
...   &amp;quot;text&amp;quot;: &amp;quot;and pretty easy too!&amp;quot;,
...   &amp;quot;date&amp;quot;: datetime.datetime(2009, 11, 10, 10, 45)}]
&amp;gt;&amp;gt;&amp;gt; result = posts.insert_many(new_posts)
&amp;gt;&amp;gt;&amp;gt; result.inserted_ids
[ObjectId(&amp;apos;...&amp;apos;), ObjectId(&amp;apos;...&amp;apos;)]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于这个栗子，需要多去咀嚼的地方：&lt;/p&gt;
&lt;p&gt;结果返回了两个对象ID实例，就是我们批量插入地文档；&lt;/p&gt;
&lt;p&gt;两个文档的键并不一样哦，一个是“tags”，另一个是“title”，这就是我们之前所说的MongoDB是模式自由的。&lt;/p&gt;
&lt;h2 id=&quot;查询多个文档&quot;&gt;&lt;a href=&quot;#查询多个文档&quot; class=&quot;headerlink&quot; title=&quot;查询多个文档&quot;&gt;&lt;/a&gt;查询多个文档&lt;/h2&gt;&lt;p&gt;为了能够返回多个文档，我们可以使用find( )方法，返回一个游标实例，它允许我们遍历所有匹配的文档。&lt;/p&gt;
&lt;p&gt;又一个栗子，我们可以遍历集合中所有的文档：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; for post in posts.find():
...   post
...
{u&amp;apos;date&amp;apos;: datetime.datetime(...), u&amp;apos;text&amp;apos;: u&amp;apos;My first blog post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;mongodb&amp;apos;, u&amp;apos;python&amp;apos;, u&amp;apos;pymongo&amp;apos;]}
{u&amp;apos;date&amp;apos;: datetime.datetime(2009, 11, 12, 11, 14), u&amp;apos;text&amp;apos;: u&amp;apos;Another post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;bulk&amp;apos;, u&amp;apos;insert&amp;apos;]}
{u&amp;apos;date&amp;apos;: datetime.datetime(2009, 11, 10, 10, 45), u&amp;apos;text&amp;apos;: u&amp;apos;and pretty easy too!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Eliot&amp;apos;, u&amp;apos;title&amp;apos;: u&amp;apos;MongoDB is fun&amp;apos;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它也可以支持限制查找，我们可以限制作者为”Mike”：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; for post in posts.find({&amp;quot;author&amp;quot;: &amp;quot;Mike&amp;quot;}):
...   post
...
{u&amp;apos;date&amp;apos;: datetime.datetime(...), u&amp;apos;text&amp;apos;: u&amp;apos;My first blog post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;mongodb&amp;apos;, u&amp;apos;python&amp;apos;, u&amp;apos;pymongo&amp;apos;]}
{u&amp;apos;date&amp;apos;: datetime.datetime(2009, 11, 12, 11, 14), u&amp;apos;text&amp;apos;: u&amp;apos;Another post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;bulk&amp;apos;, u&amp;apos;insert&amp;apos;]}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;计数&quot;&gt;&lt;a href=&quot;#计数&quot; class=&quot;headerlink&quot; title=&quot;计数&quot;&gt;&lt;/a&gt;计数&lt;/h2&gt;&lt;p&gt;如果我们只想知道文档数，可以用count()来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; posts.count()
3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你们懂得，这里也可以做限制查找&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; posts.find({&amp;quot;author&amp;quot;: &amp;quot;Mike&amp;quot;}).count()
2
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;范围查询&quot;&gt;&lt;a href=&quot;#范围查询&quot; class=&quot;headerlink&quot; title=&quot;范围查询&quot;&gt;&lt;/a&gt;范围查询&lt;/h2&gt;&lt;p&gt;MongoDB支持许多不同类型的高级查询。&lt;/p&gt;
&lt;p&gt;栗子~栗子~,可以执行一个查询,我们限制结果为一个特定日期,同时按照作者排序:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d=datetime.datetime(2009,11,12,12)&amp;gt;&amp;gt;&amp;gt; forpostinposts.find({&amp;quot;date&amp;quot;:{&amp;quot;$lt&amp;quot;:d}}).sort(&amp;quot;author&amp;quot;):... printpost...{u&amp;apos;date&amp;apos;: datetime.datetime(2009, 11, 10, 10, 45), u&amp;apos;text&amp;apos;: u&amp;apos;and pretty easy too!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Eliot&amp;apos;, u&amp;apos;title&amp;apos;: u&amp;apos;MongoDB is fun&amp;apos;}{u&amp;apos;date&amp;apos;: datetime.datetime(2009, 11, 12, 11, 14), u&amp;apos;text&amp;apos;: u&amp;apos;Another post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;bulk&amp;apos;, u&amp;apos;insert&amp;apos;]}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里我们用特殊的操作符”$lt”来做范围查询，同时用sort()做作者排序。&lt;/p&gt;
&lt;h2 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h2&gt;&lt;p&gt;添加索引可以加快某些查询，也可以增加一些额外的查询和存储文档功能。&lt;/p&gt;
&lt;p&gt;在这个例子中,我们将演示如何创建一个惟一的键索引来拒绝那些已经在索引中存在的键对应的值的文档。&lt;br&gt;首先，创建一个索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; result=db.profiles.create_index([(&amp;apos;user_id&amp;apos;,pymongo.ASCENDING)],... unique=True)&amp;gt;&amp;gt;&amp;gt; list(db.profiles.index_information())[u&amp;apos;user_id_1&amp;apos;, u&amp;apos;_id_&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意，我们现在有两个索引，一个是数据库自动创建的“_id”，另一个是我们刚创建的“user_id”。&lt;br&gt;现在让我们设置一些用户配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; user_profiles = [
... {&amp;apos;user_id&amp;apos;: 211, &amp;apos;name&amp;apos;: &amp;apos;Luke&amp;apos;},
... {&amp;apos;user_id&amp;apos;: 212, &amp;apos;name&amp;apos;: &amp;apos;Ziltoid&amp;apos;}]
&amp;gt;&amp;gt;&amp;gt; result = db.profiles.insert_many(user_profiles)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;索引可以防止插入时user_id重复：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; new_profile={&amp;apos;user_id&amp;apos;:213,&amp;apos;name&amp;apos;:&amp;apos;Drew&amp;apos;}&amp;gt;&amp;gt;&amp;gt; duplicate_profile={&amp;apos;user_id&amp;apos;:212,&amp;apos;name&amp;apos;:&amp;apos;Tommy&amp;apos;}&amp;gt;&amp;gt;&amp;gt; result=db.profiles.insert_one(new_profile)# This is fine.&amp;gt;&amp;gt;&amp;gt; result=db.profiles.insert_one(duplicate_profile)Traceback (most recent call last):pymongo.errors.DuplicateKeyError:E11000 duplicate key error index: test_database.profiles.$user_id_1 dup key: { : 212 }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原创文章，转载请注明： 转载自零の杂货铺&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近做的几个项目都用到了Python+MongoDB，好像更新一版的Mongo刚刚发布。既然是使用python，肯定是绕不过Pymongo库了，先从官方文档看起。&lt;/p&gt;
&lt;p&gt;想练习英语的戳这里~&lt;a href=&quot;http://api.mongodb.org/python
    
    </summary>
    
      <category term="python" scheme="http://phantom0301.github.io/categories/python/"/>
    
    
      <category term="pymongo" scheme="http://phantom0301.github.io/tags/pymongo/"/>
    
      <category term="python" scheme="http://phantom0301.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>博客纪元，写在前面</title>
    <link href="http://phantom0301.github.io/2016/02/19/%E5%8D%9A%E5%AE%A2%E7%BA%AA%E5%85%83%EF%BC%8C%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
    <id>http://phantom0301.github.io/2016/02/19/博客纪元，写在前面/</id>
    <published>2016-02-19T08:51:02.000Z</published>
    <updated>2016-02-21T04:46:10.754Z</updated>
    
    <content type="html">&lt;p&gt;其实很早之前就希望能够开通一个个人博客，在这里分享所见、所学，将头脑里零碎的知识和感悟整理成系统的结构。&lt;/p&gt;
&lt;p&gt;最初，是打算用wp搭建博客，然后再买个阿里云的服务器和独立域名。wp的博客年前就已经搭好了，但是谁知买服务器的时候，提示说大四不能享受学生优惠~啊摔&lt;/p&gt;
&lt;p&gt;没办法，又折腾起github的个人页面来了，用的是hexo+github，折腾了一天，解决了各种奇葩的问题，终于能够勉强运行了。&lt;/p&gt;
&lt;p&gt;先简单的从之前wp的博客上搬几篇文章过来填白，话说如果有前端牛想要帮我美化一下，尽管来联系我：）&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;其实很早之前就希望能够开通一个个人博客，在这里分享所见、所学，将头脑里零碎的知识和感悟整理成系统的结构。&lt;/p&gt;
&lt;p&gt;最初，是打算用wp搭建博客，然后再买个阿里云的服务器和独立域名。wp的博客年前就已经搭好了，但是谁知买服务器的时候，提示说大四不能享受学生优惠~啊摔&lt;/p
    
    </summary>
    
      <category term="感悟" scheme="http://phantom0301.github.io/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="感悟" scheme="http://phantom0301.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
</feed>
