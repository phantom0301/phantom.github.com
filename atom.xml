<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>零の杂货铺</title>
  <subtitle>Free and Share</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://phantom0301.github.io/"/>
  <updated>2016-02-20T08:23:05.048Z</updated>
  <id>http://phantom0301.github.io/</id>
  
  <author>
    <name>Phantom</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HEXO+github搭建博客总结</title>
    <link href="http://phantom0301.github.io/2016/02/20/HEXO+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93/"/>
    <id>http://phantom0301.github.io/2016/02/20/HEXO+github搭建博客总结/</id>
    <published>2016-02-20T08:21:27.000Z</published>
    <updated>2016-02-20T08:23:05.048Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;用hexo+github搭建个人博客，有许多坑值得去填，这里就把从各个博客学到的填坑方式在这里说一下。&lt;/p&gt;
&lt;p&gt;另外，有许多资料都是针对hexo2.x版本的，我现在的版本是3.1.1。查找资料的时候一定要注意。这里只是列出问题查找的方向，根据这个方向更便于在网上找到解决的方法。&lt;/p&gt;
&lt;h2 id=&quot;0x01-准备&quot;&gt;&lt;a href=&quot;#0x01-准备&quot; class=&quot;headerlink&quot; title=&quot;0x01 准备&quot;&gt;&lt;/a&gt;0x01 准备&lt;/h2&gt;&lt;p&gt;1.github账号：安装git，申请github账号，设置好ssh。再新建一个项目，然后在项目的setting中设置为个人页面。&lt;/p&gt;
&lt;p&gt;2.安装node.js，使用npm命令安装hexo，后面还会大量的用到npm来安装。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g hexo
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;0x02-搭建基本框架&quot;&gt;&lt;a href=&quot;#0x02-搭建基本框架&quot; class=&quot;headerlink&quot; title=&quot;0x02 搭建基本框架&quot;&gt;&lt;/a&gt;0x02 搭建基本框架&lt;/h2&gt;&lt;p&gt;在本地电脑新建一个文件夹a，在a里使用git bash初始化一个hexo项目。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo init
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时会生成许多文件夹，在输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装一些必要包。&lt;/p&gt;
&lt;p&gt;执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo generate
hexo server -p 8080
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时候应该可以在本地用&lt;a href=&quot;http://localhost:8080打开原始框架页面了&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:8080打开原始框架页面了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;-p后面的端口要根据自己的情况来写，网上大多使用默认的4000，可是我的4000端口已经用了，这样就会导致网页打不开。&lt;/p&gt;
&lt;p&gt;在本地打开成功后，就可以开始上传到github上了。&lt;/p&gt;
&lt;p&gt;打开a里的_config.yml,推荐使用sublime，如果使用其他工具，请注意要保存时格式应为&lt;strong&gt;utf-8&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找到deploy一栏，修改如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;deploy:
  type: git
  repository: https://github.com/你的github名/你的github名.github.io.git
  branch: master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意，这里作为个人页面的github项目一定要和用户名相同。&lt;/p&gt;
&lt;p&gt;然后在git bash中输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo deploy
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里注意有两种deploy的方式，&lt;a href=&quot;https://的方式会要求你输入github的账号密码；ssh的方式只要事先设置好密钥就不再需要多余的操作了。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://的方式会要求你输入github的账号密码；ssh的方式只要事先设置好密钥就不再需要多余的操作了。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这时，就可以用&lt;strong&gt;你的github名.github.io&lt;/strong&gt;来访问&lt;/p&gt;
&lt;h2 id=&quot;0x03-打磨博客&quot;&gt;&lt;a href=&quot;#0x03-打磨博客&quot; class=&quot;headerlink&quot; title=&quot;0x03 打磨博客&quot;&gt;&lt;/a&gt;0x03 打磨博客&lt;/h2&gt;&lt;p&gt;1.发表博文&lt;br&gt;使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo new “文章名”
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;新建博文，这时会在a/source/_post下生成相应的.md文件，打开编辑。&lt;br&gt;在——下面就可以使用markdown语法写博文。&lt;/p&gt;
&lt;p&gt;写好后，保存，执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo generate
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就可以在a/public中相应的位置生成博文。&lt;/p&gt;
&lt;p&gt;那么以后的程式化操作就是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo new “  ” 写博文
hexo clean 清除public
hexo generate 编译
hexo server -p 8080 本地测试
hexo deploy 部署到远程服务器
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.装饰博客&lt;br&gt;基本框架布置好，装饰的事大家就各显神通了。&lt;/p&gt;
&lt;p&gt;通常会在以下几个点进行修改&lt;/p&gt;
&lt;p&gt;a/_config.yml&lt;/p&gt;
&lt;p&gt;这里修改博客主页的名字，源信息，子页面url格式等&lt;/p&gt;
&lt;p&gt;最重要的是主题的选用，插件的使用都在这里编辑完成。&lt;br&gt;如果你要使用rss、sitemap、更改deploy的对象就需要在这里修改&lt;/p&gt;
&lt;p&gt;a/themes/&lt;br&gt;存放你找来的各种主题b、c、d……&lt;/p&gt;
&lt;p&gt;a/themes/b/_config.yml&lt;br&gt;负责单个主题的框架修改，&lt;br&gt;包括网页的logo图片选择、框架中主菜单显示的文本及连接&lt;/p&gt;
&lt;p&gt;a/public&lt;br&gt;静态生成的网页，也就是会上传到github上的文件。&lt;/p&gt;
&lt;p&gt;网上有很多教程，而且如果前面都部署成功了，后面就可以自己慢慢geek了&lt;/p&gt;
&lt;h2 id=&quot;0x04-其他的一些坑&quot;&gt;&lt;a href=&quot;#0x04-其他的一些坑&quot; class=&quot;headerlink&quot; title=&quot;0x04 其他的一些坑&quot;&gt;&lt;/a&gt;0x04 其他的一些坑&lt;/h2&gt;&lt;p&gt;github的博客可以被google站长收录，但是baidu被禁止爬去github，所以，如果想让baidu也能搜得到你，就部署在gitcafe上。&lt;/p&gt;
&lt;p&gt;如果hexo generate报错，多半是两个地方的_config.yml更改的有问题，所以一是要备份yml文件或者从git上拉取之前部署成功的文件，二是要边改边generate在本地查看，一点点琢磨不同位置的属性。&lt;/p&gt;
&lt;p&gt;a/_config.yml中的url设置如果没有购买域名的话，看似没有作用，但会影响生成的sitemap中的路径，所以在多个平台（github、gitcafe）部署的时候，不仅要修改deploy，还要根据需要修改url。&lt;/p&gt;
&lt;p&gt;否则，即便sitemap能被百度站长工具访问到，也会提示说 &lt;strong&gt;主域验证错误&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为是事后总结，暂时想到的就这么多，其他还有什么安装过程中的问题可以直接博客留言，&lt;strong&gt;见即回 &lt;/strong&gt;  ：）&lt;/p&gt;
&lt;p&gt;原创文章，转载请注明： 转载自零の杂货铺&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;用hexo+github搭建个人博客，有许多坑值得去填，这里就把从各个博客学到的填坑方式在这里说一下
    
    </summary>
    
    
      <category term="HEXO" scheme="http://phantom0301.github.io/tags/HEXO/"/>
    
      <category term="个人博客" scheme="http://phantom0301.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>MHN开源蜜罐项目学习笔记（一）——基本架构</title>
    <link href="http://phantom0301.github.io/2016/02/19/MHN%E5%BC%80%E6%BA%90%E8%9C%9C%E7%BD%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/"/>
    <id>http://phantom0301.github.io/2016/02/19/MHN开源蜜罐项目学习笔记（一）——基本架构/</id>
    <published>2016-02-19T09:13:55.000Z</published>
    <updated>2016-02-19T09:19:13.276Z</updated>
    
    <content type="html">&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00  前言&quot;&gt;&lt;/a&gt;0x00  前言&lt;/h2&gt;&lt;p&gt;MHN是一个开源的蜜网部署项目，通过简单的脚本编译，可以快速部署蜜网服务器以及蜜罐节点，想玩的，详细的部署过程参考这篇文章&lt;br&gt;&lt;a href=&quot;http://drops.wooyun.org/papers/5968&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://drops.wooyun.org/papers/5968&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;怎么安装上面说的很详细，但是网上对这个开源项目架构介绍的比较少，因为毕业论文打算写这方面，所以我在这里写写我的收获。&lt;/p&gt;
&lt;p&gt;特别提醒：MHN的honeymap需要VPN才能安装成功~~&lt;/p&gt;
&lt;h2 id=&quot;0x01-基本架构&quot;&gt;&lt;a href=&quot;#0x01-基本架构&quot; class=&quot;headerlink&quot; title=&quot;0x01 基本架构&quot;&gt;&lt;/a&gt;0x01 基本架构&lt;/h2&gt;&lt;p&gt;之前也说过了，mhn是由两部分组成，服务器和监测节点。&lt;/p&gt;
&lt;p&gt;服务器，主要由三部分来实现，一个攻击检测地图，一个通信协议，一个服务端框架。主要不是研究前端的，攻击地图部分涉及的点就请前端牛来讲解了。第一篇笔记打算着重介绍一下服务器和节点都使用到的通信协议，hpfeeds协议。&lt;/p&gt;
&lt;h2 id=&quot;0x02-hpfeeds协议&quot;&gt;&lt;a href=&quot;#0x02-hpfeeds协议&quot; class=&quot;headerlink&quot; title=&quot;0x02 hpfeeds协议&quot;&gt;&lt;/a&gt;0x02 hpfeeds协议&lt;/h2&gt;&lt;p&gt;hpfeeds是一个轻量级的验证发布-订阅协议，可以传递有效的二进制载荷。什么是发布-订阅协议呢？Pub-Sub协议类似于发传单，目标发送通知，没有指定特定的对象，通知会自动传播，观察者自己决定是否需要订阅通知，目标对此一无所知。使用这种方式降低了应用与业务逻辑之间的耦合，统一一个对外的发布接口，只需要关心监听的类型，不关心监听的具体处理人。只管发，不管到不到。很方便的建立一种一对多的依赖关系。&lt;/p&gt;
&lt;p&gt;hpfeeds协议希望能够实现一个单一的连线形式，使得每一个人都可以在任何时间以任何语言去订阅发布数据，不同的数据以通道来划分，由通道的使用者来决定数据结构形式。而通道的验证通过authkey来完成，它由两部分组成，ident和secret，相当于身份和密码。密码在hash后和每一个临时连接标志一起发送给服务器，这样保证不会被窃听，所以它可以运行在SSL、TLS下。&lt;/p&gt;
&lt;p&gt;具体的协议组成如下：&lt;br&gt;线路协议：每个消息有一个消息头，消息头使用（长度，数据）对实现。&lt;br&gt;一个MsgHeader的构造体，里面有长度和数据两个参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; length | opcode | next | identifier | next | channelname|payload
&amp;gt; ----------------------------------------------------------------
&amp;gt;  85  39   b4aa2@hp19  mwcapture 137941a3d8589f6728924c08561070bceb5d72b8,http://1.2.3.4/calc.exe
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从左到右分别是：消息总长，请求类型，ident长度，ident值，channel长度，channel值，payload&lt;br&gt;?????? 总长度自己数，opcode决定了后面的请求格式&lt;br&gt;详细参数如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error (0): errormessage
info (1): server name, nonce
auth (2): client id, sha1(nonce+authkey)
publish (3): client id, channelname, payload
subscribe (4): client id, channelname
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;认证过程：&lt;br&gt;服务器为每一个连接生成一个标志&lt;br&gt;客户端发送id和标志+key组成的sha1&lt;br&gt;服务器检查id和sha1&lt;br&gt;服务器检查数据类型，是要发布还是要订阅&lt;/p&gt;
&lt;h2 id=&quot;0x03-使用&quot;&gt;&lt;a href=&quot;#0x03-使用&quot; class=&quot;headerlink&quot; title=&quot;0x03 使用&quot;&gt;&lt;/a&gt;0x03 使用&lt;/h2&gt;&lt;p&gt;下载完成，运行setup.py build+setup.py install后的hpfeeds有如下文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://192.168.21.44/phantom/wp-content/uploads/2016/01/B31FCD2B6E14487BA0E14BBE77821FEC.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;第一个文件夹里面是支持的应用，git上的没有蜜网项目上的多&lt;/p&gt;
&lt;p&gt;第二个是中间服务器，在这里就称作服务器&lt;/p&gt;
&lt;p&gt;第四个是客户端&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://192.168.21.44/phantom/wp-content/uploads/2016/01/B31FCD2B6E14487BA0E14BBE77821FEC-1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用broker时，先要安装mongoDB和pymongo以及gevent库，且需要SSH的模块，暂时只在LINUX下运行成功&lt;br&gt;运行broker前，运行add_user.py在数据库中增加验证用户信息，设置key和id&lt;br&gt;服务器host和port可以在config中设置&lt;br&gt;其他设置在README中都有详细说明&lt;br&gt;客户端运行较简单，按照说明文件设置参数即可&lt;/p&gt;
&lt;p&gt;原创文章，转载请注明： 转载自零の杂货铺&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00  前言&quot;&gt;&lt;/a&gt;0x00  前言&lt;/h2&gt;&lt;p&gt;MHN是一个开源的蜜网部署项目，通过简单的脚本编译，可以快速部署蜜网服务器以及蜜罐节点，想玩的，
    
    </summary>
    
    
      <category term="安全，蜜罐，原创" scheme="http://phantom0301.github.io/tags/%E5%AE%89%E5%85%A8%EF%BC%8C%E8%9C%9C%E7%BD%90%EF%BC%8C%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>PyMongo官方文档翻译</title>
    <link href="http://phantom0301.github.io/2016/02/19/PyMongo%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    <id>http://phantom0301.github.io/2016/02/19/PyMongo官方文档翻译/</id>
    <published>2016-02-19T09:00:36.000Z</published>
    <updated>2016-02-19T09:20:31.629Z</updated>
    
    <content type="html">&lt;p&gt;最近做的几个项目都用到了Python+MongoDB，好像更新一版的Mongo刚刚发布。既然是使用python，肯定是绕不过Pymongo库了，先从官方文档看起。&lt;/p&gt;
&lt;p&gt;想练习英语的戳这里~&lt;a href=&quot;http://api.mongodb.org/python/current/tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://api.mongodb.org/python/current/tutorial.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;教程&quot;&gt;&lt;a href=&quot;#教程&quot; class=&quot;headerlink&quot; title=&quot;教程&quot;&gt;&lt;/a&gt;教程&lt;/h2&gt;&lt;p&gt;本教程旨在介绍使用MongoDB和PyMongo&lt;/p&gt;
&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;安装&lt;strong&gt;PyMongo&lt;/strong&gt;模块，&lt;strong&gt;MongoDB&lt;/strong&gt;数据库。&lt;br&gt;恩，在python的shell里，下面这句话没报错就算安装成功了（废话~）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;import pymongo
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;本教程还假设MongoDB实例运行在默认的主机（127.0.0.1）和端口（27017）。假设您已经下载并安装MongoDB,您可以启动它就像这样:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mongod
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;使用MongoClient完成数据库连接&quot;&gt;&lt;a href=&quot;#使用MongoClient完成数据库连接&quot; class=&quot;headerlink&quot; title=&quot;使用MongoClient完成数据库连接&quot;&gt;&lt;/a&gt;使用MongoClient完成数据库连接&lt;/h2&gt;&lt;p&gt;第一步就是使用PyMongo中的MongoClient来完成程序和数据库之间的连接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from pymongo import MongoClient
&amp;gt;&amp;gt;&amp;gt; client = MongoClient()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码将在默认的主机和端口连接。我们也可以显式地指定主机和端口,如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; client = MongoClient(&amp;apos;localhost&amp;apos;, 27017)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以使用另一种形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; client = MongoClient(&amp;apos;mongodb://localhost:27017/&amp;apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;获得数据库&quot;&gt;&lt;a href=&quot;#获得数据库&quot; class=&quot;headerlink&quot; title=&quot;获得数据库&quot;&gt;&lt;/a&gt;获得数据库&lt;/h2&gt;&lt;p&gt;MongoDB的单个实例可以支持多个独立的数据库。PyMongo支持使用属性的形式来获得数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; db = client.test_database
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果上面的形式无法访问到数据库，可以采用另一种字典的形式来访问：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; db = client[&amp;apos;test-database&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;获得集合&quot;&gt;&lt;a href=&quot;#获得集合&quot; class=&quot;headerlink&quot; title=&quot;获得集合&quot;&gt;&lt;/a&gt;获得集合&lt;/h2&gt;&lt;p&gt;集合是MongoDB中存储的一组文档，可以类比为关系型数据库中的表，获得集合的方式与获得数据库方式相同&lt;/p&gt;
&lt;p&gt;拥有两种方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; collection = db.test_collection
&amp;gt;&amp;gt;&amp;gt; collection = db[&amp;apos;test-collection&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;值得注意的是，集合和库在MongoDB中的创建是松散的，以上命令实际上并没有在服务器端做任何操作。&lt;/p&gt;
&lt;p&gt;当有文档（数据）插入到里面的时候，集合和库才被创建。&lt;/p&gt;
&lt;h2 id=&quot;文档（数据）&quot;&gt;&lt;a href=&quot;#文档（数据）&quot; class=&quot;headerlink&quot; title=&quot;文档（数据）&quot;&gt;&lt;/a&gt;文档（数据）&lt;/h2&gt;&lt;p&gt;MongoDB中的数据使用（存储为）JSON格式文件。在PyMongo中使用字典来表示这种结构。&lt;/p&gt;
&lt;p&gt;举个栗子,下面的字典可以用来代表一篇博文:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import datetime
&amp;gt;&amp;gt;&amp;gt; post = {&amp;quot;author&amp;quot;: &amp;quot;Mike&amp;quot;,
... &amp;quot;text&amp;quot;: &amp;quot;My first blog post!&amp;quot;,
... &amp;quot;tags&amp;quot;: [&amp;quot;mongodb&amp;quot;, &amp;quot;python&amp;quot;, &amp;quot;pymongo&amp;quot;],
... &amp;quot;date&amp;quot;: datetime.datetime.utcnow()}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意,文档可以包含本地Python类型(如datetime.datetime实例),这些会自动转换为合适的BSON类型。&lt;/p&gt;
&lt;h2 id=&quot;插入文件&quot;&gt;&lt;a href=&quot;#插入文件&quot; class=&quot;headerlink&quot; title=&quot;插入文件&quot;&gt;&lt;/a&gt;插入文件&lt;/h2&gt;&lt;p&gt;要插入一个文件到集合中，我们可以使用insert_one( )方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; posts = db.posts
&amp;gt;&amp;gt;&amp;gt; post_id = posts.insert_one(post).inserted_id
&amp;gt;&amp;gt;&amp;gt; post_id
ObjectId(&amp;apos;...&amp;apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果插入的文档没有“_id”这个键的话，系统会自动给它加上。“_id”键的值在整个集合中是唯一的（有点主键的意思）。insert _one( )返回一个InsertOneResult的实例。更多关于”_id“的信息，参阅 _id。&lt;/p&gt;
&lt;p&gt;在插入第一个文档后，集合就真正在服务器上创建。通过列出库中所有的集合，我们可以验证这一点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; db.collection_names(include_system_collections=False)
[u&amp;apos;posts&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;通过find-one-获取单个文档&quot;&gt;&lt;a href=&quot;#通过find-one-获取单个文档&quot; class=&quot;headerlink&quot; title=&quot;通过find_one( )获取单个文档&quot;&gt;&lt;/a&gt;通过find_one( )获取单个文档&lt;/h2&gt;&lt;p&gt;最基本的可以执行的查询类型有find_one( )。这个方法根据查询返回一个匹配的文档。如果没有匹配就返回None。&lt;/p&gt;
&lt;p&gt;对于只有单一匹配或者只对第一个匹配感兴趣的情况下，可以选用这种方法。下面是一个获取第一个文档的栗子~&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; posts.find_one()
{u&amp;apos;date&amp;apos;: datetime.datetime(...), u&amp;apos;text&amp;apos;: u&amp;apos;My first blog post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;mongodb&amp;apos;, u&amp;apos;python&amp;apos;, u&amp;apos;pymongo&amp;apos;]}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果是我们之前插入的那个注意到返回结果中”_id”这个键是自动加入的。&lt;br&gt;find_one()也支持特定的结果匹配。比如我们用作者”Mike”来限制返回的查找结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; posts.find_one({&amp;quot;author&amp;quot;: &amp;quot;Mike&amp;quot;})
{u&amp;apos;date&amp;apos;: datetime.datetime(...), u&amp;apos;text&amp;apos;: u&amp;apos;My first blog post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;mongodb&amp;apos;, u&amp;apos;python&amp;apos;, u&amp;apos;pymongo&amp;apos;]}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果我们用另一个文档中不存在的字典“Eliot”来查找，将得不到结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; posts.find_one({&amp;quot;author&amp;quot;: &amp;quot;Eliot&amp;quot;})
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;通过对象ID查询&quot;&gt;&lt;a href=&quot;#通过对象ID查询&quot; class=&quot;headerlink&quot; title=&quot;通过对象ID查询&quot;&gt;&lt;/a&gt;通过对象ID查询&lt;/h2&gt;&lt;p&gt;我们也可以通过“_id”来查找&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; post_id
ObjectId(...)
&amp;gt;&amp;gt;&amp;gt; posts.find_one({&amp;quot;_id&amp;quot;: post_id})
{u&amp;apos;date&amp;apos;: datetime.datetime(...), u&amp;apos;text&amp;apos;: u&amp;apos;My first blog post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;mongodb&amp;apos;, u&amp;apos;python&amp;apos;, u&amp;apos;pymongo&amp;apos;]}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意，对象ID不是一个字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; post_id_as_str = str(post_id)
&amp;gt;&amp;gt;&amp;gt; posts.find_one({&amp;quot;_id&amp;quot;: post_id_as_str}) # No result
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;web应用程序中的一个常见任务是从URL得到对象ID,找到匹配的文档。&lt;br&gt;这种情况下，需要将对象ID从字符串类型转换到ObjectId(符合find_one格式的类型):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from bson.objectid import ObjectId
# The web framework gets post_id from the URL and passes it as a string
def get(post_id):
# Convert from string to ObjectId:
document = client.db.collection.find_one({&amp;apos;_id&amp;apos;: ObjectId(post_id)})
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;UNICODE字符串注意&quot;&gt;&lt;a href=&quot;#UNICODE字符串注意&quot; class=&quot;headerlink&quot; title=&quot;UNICODE字符串注意&quot;&gt;&lt;/a&gt;UNICODE字符串注意&lt;/h2&gt;&lt;p&gt;你可能注意到，服务器中得到的数据和常规的Python字符串不太一样（例如用u’Mike’来代替’Mike’）&lt;/p&gt;
&lt;p&gt;这是因为我们的数据库以BSON的格式存储数据。这种格式采用UTF-8编码，所以PyMongo需要确保所有&lt;/p&gt;
&lt;p&gt;存储的字符串包含唯一可用的UTF-8数据。基于此，PyMongo解码每一个BSON字符为Python的unicode字符，而不是常见的字符串。&lt;/p&gt;
&lt;h2 id=&quot;批量插入&quot;&gt;&lt;a href=&quot;#批量插入&quot; class=&quot;headerlink&quot; title=&quot;批量插入&quot;&gt;&lt;/a&gt;批量插入&lt;/h2&gt;&lt;p&gt;为了使查询更加有趣,让我们插入更多的文档。&lt;/p&gt;
&lt;p&gt;除了插入一个文档,我们也可以执行批量插入操作,&lt;br&gt;通过insert_many插入列表的方式，可以插入列表中的每一个文档，而只向服务器发送一次指令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; new_posts = [{&amp;quot;author&amp;quot;: &amp;quot;Mike&amp;quot;,
...   &amp;quot;text&amp;quot;: &amp;quot;Another post!&amp;quot;,
...   &amp;quot;tags&amp;quot;: [&amp;quot;bulk&amp;quot;, &amp;quot;insert&amp;quot;],
...   &amp;quot;date&amp;quot;: datetime.datetime(2009, 11, 12, 11, 14)},
...  {&amp;quot;author&amp;quot;: &amp;quot;Eliot&amp;quot;,
...   &amp;quot;title&amp;quot;: &amp;quot;MongoDB is fun&amp;quot;,
...   &amp;quot;text&amp;quot;: &amp;quot;and pretty easy too!&amp;quot;,
...   &amp;quot;date&amp;quot;: datetime.datetime(2009, 11, 10, 10, 45)}]
&amp;gt;&amp;gt;&amp;gt; result = posts.insert_many(new_posts)
&amp;gt;&amp;gt;&amp;gt; result.inserted_ids
[ObjectId(&amp;apos;...&amp;apos;), ObjectId(&amp;apos;...&amp;apos;)]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于这个栗子，需要多去咀嚼的地方：&lt;/p&gt;
&lt;p&gt;结果返回了两个对象ID实例，就是我们批量插入地文档；&lt;/p&gt;
&lt;p&gt;两个文档的键并不一样哦，一个是“tags”，另一个是“title”，这就是我们之前所说的MongoDB是模式自由的。&lt;/p&gt;
&lt;h2 id=&quot;查询多个文档&quot;&gt;&lt;a href=&quot;#查询多个文档&quot; class=&quot;headerlink&quot; title=&quot;查询多个文档&quot;&gt;&lt;/a&gt;查询多个文档&lt;/h2&gt;&lt;p&gt;为了能够返回多个文档，我们可以使用find( )方法，返回一个游标实例，它允许我们遍历所有匹配的文档。&lt;/p&gt;
&lt;p&gt;又一个栗子，我们可以遍历集合中所有的文档：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; for post in posts.find():
...   post
...
{u&amp;apos;date&amp;apos;: datetime.datetime(...), u&amp;apos;text&amp;apos;: u&amp;apos;My first blog post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;mongodb&amp;apos;, u&amp;apos;python&amp;apos;, u&amp;apos;pymongo&amp;apos;]}
{u&amp;apos;date&amp;apos;: datetime.datetime(2009, 11, 12, 11, 14), u&amp;apos;text&amp;apos;: u&amp;apos;Another post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;bulk&amp;apos;, u&amp;apos;insert&amp;apos;]}
{u&amp;apos;date&amp;apos;: datetime.datetime(2009, 11, 10, 10, 45), u&amp;apos;text&amp;apos;: u&amp;apos;and pretty easy too!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Eliot&amp;apos;, u&amp;apos;title&amp;apos;: u&amp;apos;MongoDB is fun&amp;apos;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它也可以支持限制查找，我们可以限制作者为”Mike”：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; for post in posts.find({&amp;quot;author&amp;quot;: &amp;quot;Mike&amp;quot;}):
...   post
...
{u&amp;apos;date&amp;apos;: datetime.datetime(...), u&amp;apos;text&amp;apos;: u&amp;apos;My first blog post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;mongodb&amp;apos;, u&amp;apos;python&amp;apos;, u&amp;apos;pymongo&amp;apos;]}
{u&amp;apos;date&amp;apos;: datetime.datetime(2009, 11, 12, 11, 14), u&amp;apos;text&amp;apos;: u&amp;apos;Another post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;bulk&amp;apos;, u&amp;apos;insert&amp;apos;]}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;计数&quot;&gt;&lt;a href=&quot;#计数&quot; class=&quot;headerlink&quot; title=&quot;计数&quot;&gt;&lt;/a&gt;计数&lt;/h2&gt;&lt;p&gt;如果我们只想知道文档数，可以用count()来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; posts.count()
3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你们懂得，这里也可以做限制查找&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; posts.find({&amp;quot;author&amp;quot;: &amp;quot;Mike&amp;quot;}).count()
2
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;范围查询&quot;&gt;&lt;a href=&quot;#范围查询&quot; class=&quot;headerlink&quot; title=&quot;范围查询&quot;&gt;&lt;/a&gt;范围查询&lt;/h2&gt;&lt;p&gt;MongoDB支持许多不同类型的高级查询。&lt;/p&gt;
&lt;p&gt;栗子~栗子~,可以执行一个查询,我们限制结果为一个特定日期,同时按照作者排序:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d=datetime.datetime(2009,11,12,12)&amp;gt;&amp;gt;&amp;gt; forpostinposts.find({&amp;quot;date&amp;quot;:{&amp;quot;$lt&amp;quot;:d}}).sort(&amp;quot;author&amp;quot;):... printpost...{u&amp;apos;date&amp;apos;: datetime.datetime(2009, 11, 10, 10, 45), u&amp;apos;text&amp;apos;: u&amp;apos;and pretty easy too!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Eliot&amp;apos;, u&amp;apos;title&amp;apos;: u&amp;apos;MongoDB is fun&amp;apos;}{u&amp;apos;date&amp;apos;: datetime.datetime(2009, 11, 12, 11, 14), u&amp;apos;text&amp;apos;: u&amp;apos;Another post!&amp;apos;, u&amp;apos;_id&amp;apos;: ObjectId(&amp;apos;...&amp;apos;), u&amp;apos;author&amp;apos;: u&amp;apos;Mike&amp;apos;, u&amp;apos;tags&amp;apos;: [u&amp;apos;bulk&amp;apos;, u&amp;apos;insert&amp;apos;]}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里我们用特殊的操作符”$lt”来做范围查询，同时用sort()做作者排序。&lt;/p&gt;
&lt;h2 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h2&gt;&lt;p&gt;添加索引可以加快某些查询，也可以增加一些额外的查询和存储文档功能。&lt;/p&gt;
&lt;p&gt;在这个例子中,我们将演示如何创建一个惟一的键索引来拒绝那些已经在索引中存在的键对应的值的文档。&lt;br&gt;首先，创建一个索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; result=db.profiles.create_index([(&amp;apos;user_id&amp;apos;,pymongo.ASCENDING)],... unique=True)&amp;gt;&amp;gt;&amp;gt; list(db.profiles.index_information())[u&amp;apos;user_id_1&amp;apos;, u&amp;apos;_id_&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意，我们现在有两个索引，一个是数据库自动创建的“_id”，另一个是我们刚创建的“user_id”。&lt;br&gt;现在让我们设置一些用户配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; user_profiles = [
... {&amp;apos;user_id&amp;apos;: 211, &amp;apos;name&amp;apos;: &amp;apos;Luke&amp;apos;},
... {&amp;apos;user_id&amp;apos;: 212, &amp;apos;name&amp;apos;: &amp;apos;Ziltoid&amp;apos;}]
&amp;gt;&amp;gt;&amp;gt; result = db.profiles.insert_many(user_profiles)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;索引可以防止插入时user_id重复：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; new_profile={&amp;apos;user_id&amp;apos;:213,&amp;apos;name&amp;apos;:&amp;apos;Drew&amp;apos;}&amp;gt;&amp;gt;&amp;gt; duplicate_profile={&amp;apos;user_id&amp;apos;:212,&amp;apos;name&amp;apos;:&amp;apos;Tommy&amp;apos;}&amp;gt;&amp;gt;&amp;gt; result=db.profiles.insert_one(new_profile)# This is fine.&amp;gt;&amp;gt;&amp;gt; result=db.profiles.insert_one(duplicate_profile)Traceback (most recent call last):pymongo.errors.DuplicateKeyError:E11000 duplicate key error index: test_database.profiles.$user_id_1 dup key: { : 212 }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原创文章，转载请注明： 转载自零の杂货铺&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近做的几个项目都用到了Python+MongoDB，好像更新一版的Mongo刚刚发布。既然是使用python，肯定是绕不过Pymongo库了，先从官方文档看起。&lt;/p&gt;
&lt;p&gt;想练习英语的戳这里~&lt;a href=&quot;http://api.mongodb.org/python
    
    </summary>
    
    
      <category term="python" scheme="http://phantom0301.github.io/tags/python/"/>
    
      <category term="翻译，原创" scheme="http://phantom0301.github.io/tags/%E7%BF%BB%E8%AF%91%EF%BC%8C%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>博客纪元，写在前面</title>
    <link href="http://phantom0301.github.io/2016/02/19/%E5%8D%9A%E5%AE%A2%E7%BA%AA%E5%85%83%EF%BC%8C%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
    <id>http://phantom0301.github.io/2016/02/19/博客纪元，写在前面/</id>
    <published>2016-02-19T08:51:02.000Z</published>
    <updated>2016-02-19T08:59:44.453Z</updated>
    
    <content type="html">&lt;p&gt;其实很早之前就希望能够开通一个个人博客，在这里分享所见、所学，将头脑里零碎的知识和感悟整理成系统的结构。&lt;/p&gt;
&lt;p&gt;最初，是打算用wp搭建博客，然后再买个阿里云的服务器和独立域名。wp的博客年前就已经搭好了，但是谁知买服务器的时候，提示说大四不能享受学生优惠~啊摔&lt;/p&gt;
&lt;p&gt;没办法，又折腾起github的个人页面来了，用的是hexo+github，折腾了一天，解决了各种奇葩的问题，终于能够勉强运行了。&lt;/p&gt;
&lt;p&gt;先简单的从之前wp的博客上搬几篇文章过来填白，话说如果有前端牛想要帮我美化一下，尽管来联系我：）&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;其实很早之前就希望能够开通一个个人博客，在这里分享所见、所学，将头脑里零碎的知识和感悟整理成系统的结构。&lt;/p&gt;
&lt;p&gt;最初，是打算用wp搭建博客，然后再买个阿里云的服务器和独立域名。wp的博客年前就已经搭好了，但是谁知买服务器的时候，提示说大四不能享受学生优惠~啊摔&lt;/p
    
    </summary>
    
    
      <category term="感悟" scheme="http://phantom0301.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://phantom0301.github.io/2016/02/19/hello-world/"/>
    <id>http://phantom0301.github.io/2016/02/19/hello-world/</id>
    <published>2016-02-19T06:24:13.982Z</published>
    <updated>2016-02-19T06:24:13.982Z</updated>
    
    <content type="html">&lt;p&gt;Welcome to &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;http://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;http://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;http://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;http://hexo.io/docs/server.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Generate-static-files&quot;&gt;&lt;a href=&quot;#Generate-static-files&quot; class=&quot;headerlink&quot; title=&quot;Generate static files&quot;&gt;&lt;/a&gt;Generate static files&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;http://hexo.io/docs/generating.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Generating&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Deploy-to-remote-sites&quot;&gt;&lt;a href=&quot;#Deploy-to-remote-sites&quot; class=&quot;headerlink&quot; title=&quot;Deploy to remote sites&quot;&gt;&lt;/a&gt;Deploy to remote sites&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;http://hexo.io/docs/deployment.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;http://hexo.io
    
    </summary>
    
    
  </entry>
  
</feed>
